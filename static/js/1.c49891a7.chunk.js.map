{"version":3,"sources":["../static/js/1.c49891a7.chunk.js","pages/vis/HCIM.jsx","../node_modules/dc/dc.js","../node_modules/d3/d3.js","../node_modules/dc/node_modules/crossfilter2/index.js","../node_modules/dc/node_modules/crossfilter2/crossfilter.js","components/Chart.jsx"],"names":["webpackJsonp","268","module","__webpack_exports__","__webpack_require__","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","n","__WEBPACK_IMPORTED_MODULE_1_reactstrap__","__WEBPACK_IMPORTED_MODULE_2__components_Chart__","HCIM","props","a","createElement","fluid","style","marginBottom","className","href","target","rel","field","nullValue","chartOptions","cap","height","270","exports","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_dc","d3","crossfilter","dc","version","constants","CHART_CLASS","DEBUG_GROUP_CLASS","STACK_CLASS","DESELECTED_CLASS","SELECTED_CLASS","NODE_INDEX_NAME","GROUP_INDEX_NAME","DEFAULT_CHART_GROUP","EVENT_DELAY","NEGLIGIBLE_NUMBER","_renderlet","chartRegistry","initializeChartGroup","group","_chartMap","has","chart","e","indexOf","register","push","deregister","i","length","anchorName","splice","clear","list","registerChart","deregisterChart","hasChart","deregisterAllCharts","filterAll","charts","refocusAll","focus","renderAll","render","redrawAll","redraw","disableTransitions","transition","selection","duration","delay","name","s","undefined","optionalTransition","enable","afterTransition","callback","empty","call","each","units","integers","start","end","Math","abs","ordinal","domain","fp","precision","_f","d","resolution","utils","isNegligible","floor","ceil","round","override","obj","functionName","newFunction","existingFunction","renderlet","_","arguments","instanceOfChart","o","__dcFlag__","errors","Exception","msg","_msg","this","message","toString","stack","Error","prototype","create","constructor","InvalidStateException","apply","BadArgumentException","dateFormat","time","format","printers","filters","filter","Array","printSingleValue","pluck","f","Date","isFloat","fformat","isInteger","add","l","r","t","replace","getTime","offset","percentage","subtract","isNumber","clamp","val","min","max","_idCounter","uniqueId","nameToId","toLowerCase","appendOrSelect","parent","selector","tag","element","select","append","safeNumber","logger","enableDebugLog","warn","console","log","debug","deprecate","fn","deprecated","warned","events","current","trigger","closure","setTimeout","RangedFilter","low","high","range","isFiltered","filterType","TwoDimensionalFilter","RangedTwoDimensionalFilter","fromBottomLeft","Infinity","x","y","baseMixin","_chart","sizeSvg","_svg","_useViewBoxResizing","attr","width","generateSvg","root","checkForMandatoryAttributes","applyFilters","dimension","fs","_filterHandler","_dimension","_group","_anchor","_root","_isChild","_width","_height","_orderSort","_legend","_commitHandler","_minWidth","_defaultWidthCalc","getBoundingClientRect","_widthCalc","_minHeight","_defaultHeightCalc","_heightCalc","_keyAccessor","_valueAccessor","_label","_ordering","_renderLabel","_title","keyAccessor","valueAccessor","_renderTitle","_controlsUseVisibility","_transitionDuration","_transitionDelay","_filterPrinter","_mandatoryAttributes","_chartGroup","_listeners","dispatch","_filters","filterRange","filterFunction","filterExact","_data","all","functor","node","minWidth","minHeight","useViewBoxResizing","expireCache","data","_groupName","ordering","orderFunction","quicksort","by","_computeOrderedGroups","dataCopy","slice","selectAll","anchor","chartGroup","classed","id","chartID","rootElement","svg","svgElement","resetSvg","remove","filterPrinter","filterPrinterFunction","controlsUseVisibility","useVisibility","turnOnControls","attribute","text","turnOffControls","transitionDuration","transitionDelay","preRender","forEach","result","_doRender","_activateRenderlets","event","pretransition","preRedraw","_doRedraw","commitHandler","redrawGroup","error","renderGroup","_invokeFilteredListener","filtered","_invokeZoomedListener","zoomed","_hasFilterHandler","some","hasFilterHandler","hasFilter","_removeFilterHandler","removeFilterHandler","_addFilterHandler","addFilterHandler","_resetFilterHandler","resetFilterHandler","replaceFilter","highlightSelected","fadeDeselected","resetHighlight","onClick","datum","filterHandler","legendables","legendHighlight","legendReset","legendToggle","isLegendableHidden","label","labelFunction","enableLabels","renderLabel","title","titleFunction","renderTitle","renderletFunction","on","legend","options","opts","applyOptions","listener","marginMixin","_margin","top","right","bottom","left","margins","effectiveWidth","effectiveHeight","colorMixin","_colors","scale","category20c","_defaultAccessor","_colorAccessor","colors","colorScale","quantize","ordinalColors","linearColors","linear","interpolate","interpolateHcl","colorAccessor","defaultColorAccessor","colorDomain","calculateColorDomain","newDomain","getColor","colorCalculator","coordinateGridMixin","compareDomains","d1","d2","elem","prepareXAxis","g","isOrdinal","elasticX","_x","_ordinalXDomain","xAxisMin","xAxisMax","xdom","_lastXDomain","rescale","rangeBands","xAxisLength","_rangeBandPadding","_useOuterPadding","_outerRangeBandPadding","_xAxis","renderVerticalGridLines","gridLineG","VERTICAL_CLASS","_renderVerticalGridLine","insert","GRID_LINE_CLASS","ticks","tickValues","lines","linesGEnter","enter","_xAxisY","exit","brushHeight","getClipPathId","generateClipPath","defs","_parent","chartBodyClip","padding","_clipPadding","yAxisHeight","drawChart","_brushOn","_prepareYAxis","plotData","_resizing","renderXAxis","elasticY","renderYAxis","renderBrush","redrawBrush","fadeDeselectedArea","configureMouseZoom","_mouseZoomable","_enableMouseZoom","_hasBeenMouseZoomable","_disableMouseZoom","zoomHandler","_refocused","_zoomOutRestrict","constraint","_xOriginalDomain","_rangeChart","intersectExtents","constrained","constrainExtent","domFilter","rangesEqual","ext1","ext2","extent","size","range1","range2","valueOf","hasRangeSelected","category10","_g","_chartBodyG","_xAxisLabel","_y","_yAxisLabel","_round","_unitCount","_focusChart","axis","orient","_xUnits","_xAxisPadding","_xAxisPaddingUnit","_xElasticity","_xAxisLabelPadding","_yAxis","_yAxisPadding","_yElasticity","_yAxisLabelPadding","_brush","brush","_renderHorizontalGridLine","_zoomScale","_zoom","behavior","zoom","_nullZoom","_useRightYAxis","resizing","rangeChart","focusChart","zoomScale","zoomOutRestrict","_generateG","window","location","split","gElement","mouseZoomable","chartBodyG","xScale","xOriginalDomain","xUnits","xAxis","xAxisPadding","xAxisPaddingUnit","unit","xUnitCount","useRightYAxis","map","axisXG","axisXLab","xAxisLabel","labelText","yAxisMin","yAxisMax","rangeRound","_renderHorizontalGridLinesForAxis","renderYAxisLabel","axisClass","rotation","labelXPosition","axisYLab","labelYPosition","Y_AXIS_LABEL_CLASS","renderYAxisAt","position","axisYG","axisPosition","_yAxisX","labelPosition","yAxisLabel","yScale","yAxis","renderHorizontalGridLines","yAxisPadding","_filter","_brushing","gBrush","setBrushY","setHandlePaths","resizeHandlePath","extendBrush","brushIsEmpty","rangedFilter","doTransition","clipPadding","_preprocessData","scaleExtent","refocused","c","brushOn","stackMixin","prepareValues","layer","layerIdx","valAccessor","accessor","String","values","hidden","domainFilter","_evadeDomainFilter","xDomain","p","findLayerByName","_stack","flattenStack","valueses","concat","visability","_stackLayout","layout","_titles","_hidableStacks","hidableStacks","hideStack","stackName","showStack","getValueAccessorByIndex","index","y0","titleAccessor","stackLayout","evadeDomainFilter","layers","flat","color","capMixin","_cap","_takeFront","_othersLabel","kv","_othersGrouper","topItems","restItems","restItemsSum","sum","restKeys","others","key","othersLabel","cappedKeyAccessor","cappedValueAccessor","rest","items","count","takeFront","othersGrouper","grouperFunction","_onClick","bubbleMixin","_maxBubbleRelativeSize","_minRadiusWithLabel","_sortBubbleSize","_elasticRadius","BUBBLE_NODE_CLASS","BUBBLE_CLASS","MIN_RADIUS","radiusAccessor","radiusValueAccessor","sort","b","descending","_r","_rValueAccessor","bubbleRadiusScale","elasticRadius","calculateRadiusDomain","rMin","rMax","bubbleR","isNaN","shouldLabel","labelOpacity","labelPointerEvent","_doRenderLabel","bubbleGEnter","doUpdateLabels","labels","_doRenderTitles","doUpdateTitles","sortBubbleSize","minRadius","radius","minRadiusWithLabel","maxBubbleRelativeSize","relativeSize","isSelectedNode","pieChart","maxRadius","_radius","_givenRadius","pieData","arc","buildArcs","pie","pieLayout","_emptyCssClass","_emptyTitle","slices","_sliceGroupCssClass","_sliceCssClass","_labelGroupCssClass","_labelCssClass","createElements","updateElements","removeElements","highlightFilter","cx","cy","slicesEnter","createSliceNodes","createSlicePath","createTitles","createLabels","slicePath","fill","safeArc","attrTween","tweenPie","positionLabels","_applyLabelText","highlightSlice","whether","classes","_externalLabelRadius","_drawPaths","updateLabelPaths","polyline","arc2","outerRadius","_externalRadiusPadding","innerRadius","_current","startAngle","endAngle","centroid","updateSlicePaths","updateLabels","updateTitles","slicePaths","isSelectedSlice","_innerRadius","sliceTooSmall","angle","_minAngleForLabel","sliceHasNoData","isOffCanvas","path","highlightSliceFromLegendable","legendable","highlighted","_cx","_cy","slicesCap","externalRadiusPadding","minAngleForLabel","emptyTitle","externalLabels","externalLabelRadius","drawPaths","barChart","barHeight","renderLabels","layerIndex","_centerBar","_barWidth","LABEL_PADDING","renderBars","bars","_gap","calculateBarWidth","numberOfBars","rangeBand","barPadding","MIN_BAR_WIDTH","colorFilter","inv","item","match","_alwaysUseRounding","_rescale","_render","last","centerBar","outerPadding","gap","alwaysUseRounding","_xAxisMax","lineChart","drawLine","layersEnter","line","_interpolate","tension","_tension","_defined","defined","_dashStyle","safeD","drawArea","_renderArea","area","drawDots","chartBody","xyTipsOn","tooltipListClass","TOOLTIP_G_CLASS","tooltips","points","createRefLines","dots","DOT_CIRCLE_CLASS","getDotRadius","_dataPointFillOpacity","_dataPointStrokeOpacity","dot","showDot","showRefLines","hideDot","hideRefLines","drawLabels","Y_AXIS_REF_LINE_CLASS","X_AXIS_REF_LINE_CLASS","_dotRadius","yAxisX","yAxisRefPathD","xAxisRefPathD","_dataPointRadius","dashstyle","join","_xyTipsOn","layersList","dashStyle","renderArea","dotRadius","renderDataPoints","fillOpacity","strokeOpacity","_legendables","dataCount","_formatNumber","_html","html","formatNumber","formatter","tot","selected","dataTable","renderGroups","bAllFunctions","_columns","thead","headrow","headcols","HEAD_CSS_CLASS","_doColumnHeaderFormat","groups","nestEntries","rowGroup","_showGroups","GROUP_CSS_CLASS","LABEL_CSS_CLASS","entries","_order","ascending","_size","nest","sortKeys","_sortBy","_beginSlice","_endSlice","renderRows","rows","order","ROW_CSS_CLASS","rowEnter","v","COLUMN_CSS_CLASS","_doColumnValueFormat","_doColumnHeaderFnToString","_doColumnHeaderCapitalize","charAt","toUpperCase","i1","i2","lastIndexOf","substring","beginSlice","endSlice","columns","sortBy","showGroups","dataGrid","GRID_CSS_CLASS","itemGroup","_htmlGroup","renderItems","ITEM_CSS_CLASS","JSON","stringify","htmlGroup","sortByFunction","bubbleChart","renderNodes","bubbleG","bubbleLocator","updateNodes","removeNodes","bubbleX","bubbleY","compositeChart","calculateYAxisRanges","lyAxisMin","lyAxisMax","ryAxisMin","ryAxisMax","ranges","rightYAxisMin","rightYAxisMax","alignYAxes","alignYAxisRanges","extentRatio","prepareRightYAxis","needDomain","rightY","needRange","rightYAxis","prepareLeftYAxis","generateChildG","child","SUB_CHART_CLASS","leftYAxisChildren","_children","rightYAxisChildren","getYAxisMin","getYAxisMax","getAllXAxisMinFromChildCharts","getAllXAxisMaxFromChildCharts","_rightY","_childOptions","_shareColors","_shareTitle","_alignYAxes","_rightYAxis","_rightYAxisLabel","_rightYAxisLabelPadding","_rightAxisGridLines","__generateG","rightYAxisLabel","useRightAxisGridLines","childOptions","compose","subChartArray","children","shareColors","shareTitle","reduce","j","seriesChart","keySort","clearChart","_charts","resetChildren","keys","_seriesAccessor","_chartFunction","_seriesSort","_valueSort","childrenChanged","keep","nester","sortValues","nesting","sub","subChart","_compose","chartFunction","seriesAccessor","seriesSort","sortFunction","valueSort","geoChoroplethChart","generateLayeredData","isDataLayer","regionG","renderRegionG","renderPaths","groupAll","geoJson","layerSelector","isSelected","isDeselected","layerNameClass","regionClass","baseClasses","getKey","_geoJsons","paths","currentFill","_projectionFlag","_geoPath","geo","states","selectedRegion","overlayGeoJson","json","projection","geoJsons","geoPath","removeGeoJson","bubbleOverlay","initOverlayG","BUBBLE_OVERLAY_CLASS","initializeBubbles","mapData","_points","point","nodeG","getNodeG","circle","bubbleNodeClass","updateBubbles","flag","debugG","debugText","mouse","rowChart","calculateAxisScale","_elasticX","_rowData","drawAxis","axisG","drawGridLines","_rowCssClass","rootValue","_fixedBarHeight","_hasLabelOffsetY","_labelOffsetY","rect","isSelectedRow","translateX","renderTitleLabel","_titleRowCssClass","lab","_labelOffsetX","_dyOffset","titlelab","_titleLabelOffsetX","x0","_renderTitleLabel","rowsCap","fixedBarHeight","labelOffsetX","labelOffsetY","labelOffsety","titleLabelOffsetX","legendItemHeight","_itemHeight","_maxItems","_horizontal","_legendWidth","_itemWidth","_autoItemWidth","_legendText","itemEnter","clientHeight","_cumulativeLegendTextWidth","row","itemWidth","getBBox","translateBy","itemHeight","horizontal","legendWidth","autoItemWidth","legendText","maxItems","scatterPlot","elementSize","_existenceAccessor","_filtered","pow","_symbolSize","_excludedSize","_emptySize","renderTitles","symbol","resizeSymbolsWhere","condition","symbols","oldSize","_symbol","originalKeyAccessor","existenceAccessor","_locator","_highlightedSize","_excludedColor","_excludedOpacity","_emptyOpacity","_nonemptyOpacity","_emptyColor","__filter","excludedOpacity","excludedColor","type","customSymbol","symbolSize","highlightedSize","excludedSize","hiddenSize","emptySize","emptyColor","emptyOpacity","nonemptyOpacity","ranged2DFilter","numberDisplay","maxBin","sorted","_lastValue","one","none","valObj","newValue","span","ease","tween","interpStart","isFinite","interp","interpolateNumber","num","innerHTML","heatMap","filterAxis","cellsOnAxis","unfilteredCellsOnAxis","_chartBody","_cols","_rows","_colOrdering","_rowOrdering","_colScale","_rowScale","_xBorderRadius","_yBorderRadius","_colsLabel","_rowsLabel","colsLabel","rowsLabel","_xAxisOnClick","_yAxisOnClick","_boxOnClick","rowOrdering","cols","colOrdering","rowCount","colCount","boxWidth","boxHeight","rangeRoundBands","boxes","gEnter","boxOnClick","gCols","gColsText","xAxisOnClick","gRows","gRowsText","yAxisOnClick","handler","xBorderRadius","yBorderRadius","boxWhiskers","boxQuartiles","quantile","box","quartileData","quartiles","whiskerIndices","whiskers","whiskerData","outlierIndices","x1","__chart__","center","medianLine","whisker","outlier","Number","tickFormat","boxTick","whiskerTick","timer","flush","boxPlot","DEFAULT_WHISKERS_IQR","k","q1","q3","iqr","renderBoxes","boxesG","boxTransform","_box","updateBoxes","removeBoxes","_whiskersIqr","_whiskers","_tickFormat","_boxWidth","innerChartWidth","boxPadding","_calculatedBoxWidth","selectMenu","renderOptions","_select","OPTION_CSS_CLASS","onChange","selectedOptions","option","_promptValue","_multiple","setAttributes","_numberVisible","_promptText","_filterDisplayed","property","promptText","filterDisplayed","multiple","promptValue","numberVisible","abstractBubbleChart","baseChart","capped","colorChart","coordinateGridChart","marginable","stackableChart","271","d3_documentElement","ownerDocument","document","documentElement","d3_window","defaultView","d3_ascending","NaN","d3_number","d3_numeric","d3_bisector","compare","lo","hi","mid","d3_transposeLength","d3_range_integerScale","d3_class","ctor","properties","enumerable","d3_Map","d3_map_escape","d3_map_proto","d3_map_zero","d3_map_unescape","d3_map_has","d3_map_remove","d3_map_keys","d3_map_size","d3_map_empty","d3_Set","d3_identity","d3_rebind","source","method","d3_vendorSymbol","object","d3_vendorPrefixes","prefixName","d3_noop","d3_dispatch","d3_dispatch_event","z","listeners","listenerByName","get","set","d3_eventPreventDefault","preventDefault","d3_eventSource","sourceEvent","d3_eventDispatch","of","thiz","argumentz","e1","e0","d3_selection","d3_subclass","d3_selectionPrototype","d3_selection_selector","d3_select","d3_selection_selectorAll","d3_selectAll","d3_selection_attr","attrNull","removeAttribute","attrNullNS","removeAttributeNS","space","local","attrConstant","setAttribute","attrConstantNS","setAttributeNS","attrFunction","attrFunctionNS","ns","qualify","d3_collapse","trim","d3_selection_classedRe","RegExp","requote","d3_selection_classes","d3_selection_classed","classedConstant","classedFunction","d3_selection_classedName","re","classList","getAttribute","lastIndex","test","d3_selection_style","priority","styleNull","removeProperty","styleConstant","setProperty","styleFunction","d3_selection_property","propertyNull","propertyConstant","propertyFunction","d3_selection_creator","namespace","namespaceURI","d3_nsXhtml","createElementNS","createNS","d3_selectionRemove","parentNode","removeChild","d3_selection_dataNode","__data__","d3_selection_filter","d3_selectMatches","d3_selection_sortComparator","comparator","d3_selection_each","m","d3_selection_enter","d3_selection_enterPrototype","d3_selection_enterInsertBefore","i0","j0","update","d3_selection_on","capture","onRemove","removeEventListener","$","onAdd","wrap","d3_array","addEventListener","removeAll","d3_selection_onListener","d3_selection_onFilters","d3_selection_onFilter","related","relatedTarget","compareDocumentPosition","d3_event_dragSuppress","d3_event_dragId","click","w","d3_event_dragSelect","suppressClick","off","d3_mousePoint","container","changedTouches","ownerSVGElement","createSVGPoint","d3_mouse_bug44083","scrollX","scrollY","margin","border","ctm","getScreenCTM","pageX","pageY","clientX","clientY","matrixTransform","inverse","clientLeft","clientTop","d3_behavior_dragTouchId","identifier","d3_sgn","d3_cross2d","d3_acos","π","acos","d3_asin","halfπ","asin","d3_sinh","exp","d3_cosh","d3_tanh","d3_haversin","sin","d3_color","d3_hsl","h","d3_rgb_parse","d3_rgb_hsl","d3_hsl_rgb","m1","m2","vv","d3_rgb","d3_hcl","d3_lab","d3_lab_hcl","d3_rgb_lab","rgb","d3_hcl_lab","cos","d3_radians","d3_lab_rgb","d3_lab_xyz","d3_lab_X","d3_lab_Y","d3_lab_Z","d3_xyz_rgb","atan2","d3_degrees","sqrt","d3_xyz_lab","d3_rgbNumber","d3_rgbString","d3_rgb_hex","hsl","exec","parseFloat","d3_rgb_parseNumber","d3_rgb_names","parseInt","d3_rgb_xyz","d3_functor","d3_xhrType","response","url","mimeType","d3_xhr","respond","status","request","d3_xhrHasResponse","xhr","load","headers","XMLHttpRequest","responseType","XDomainRequest","onload","onerror","onreadystatechange","readyState","onprogress","progress","header","send","open","setRequestHeader","overrideMimeType","beforesend","abort","rebind","d3_xhr_fixCallback","responseText","d3_timer","then","now","d3_timer_queueTail","d3_timer_queueHead","d3_timer_interval","d3_timer_timeout","clearTimeout","d3_timer_frame","d3_timer_step","d3_timer_mark","d3_timer_sweep","t0","t1","d3_format_precision","LN10","d3_formatPrefix","d3_locale_numberFormat","locale","locale_decimal","decimal","locale_thousands","thousands","locale_grouping","grouping","locale_currency","currency","formatGroup","reverse","specifier","d3_format_re","align","sign","zfill","comma","prefix","suffix","integer","exponent","d3_format_types","d3_format_typeDefault","zcomma","fullSuffix","negative","formatPrefix","before","after","d3_date_utc","UTC","d3_time_interval","step","number","date","d0","d3_date","dt","times","range_utc","utc","d3_time_interval_utc","d3_locale_timeFormat","d3_time_format","template","string","charCodeAt","d3_time_formatPads","d3_time_formats","parse","H","M","S","L","Z","d3_time_parse","localZ","setFullYear","W","getDay","U","setHours","d3_time_parsers","d3_time_parseWeekdayAbbrev","d3_time_dayAbbrevRe","d3_time_dayAbbrevLookup","d3_time_parseWeekday","d3_time_dayRe","d3_time_dayLookup","d3_time_parseMonthAbbrev","d3_time_monthAbbrevRe","d3_time_monthAbbrevLookup","d3_time_parseMonth","d3_time_monthRe","d3_time_monthLookup","d3_time_parseLocaleFull","d3_time_parseLocaleDate","d3_time_parseLocaleTime","X","d3_time_parseAmPm","d3_time_periodLookup","locale_dateTime","dateTime","locale_date","locale_time","locale_periods","periods","locale_days","days","locale_shortDays","shortDays","locale_months","months","locale_shortMonths","shortMonths","multi","d3_time_formatMulti","d3_time_formatRe","d3_time_formatLookup","A","getMonth","B","d3_time_formatPad","getDate","getHours","I","d3_time","dayOfYear","getMilliseconds","getMinutes","getSeconds","sundayOfYear","mondayOfYear","getFullYear","Y","d3_time_zone","%","d3_time_parseDay","d3_time_parseHour24","d3_time_parseDayOfYear","d3_time_parseMilliseconds","d3_time_parseMonthNumber","d3_time_parseMinutes","d3_time_parseSeconds","d3_time_parseWeekNumberSunday","d3_time_parseWeekdayNumber","d3_time_parseWeekNumberMonday","d3_time_parseYear","d3_time_parseFullYear","d3_time_parseZone","d3_time_parseLiteralPercent","names","d3_time_numberRe","d3_time_expandYear","getTimezoneOffset","zs","zh","zm","d3_time_percentRe","formats","d3_adder","d3_adderSum","bv","av","d3_geo_streamGeometry","geometry","d3_geo_streamGeometryType","hasOwnProperty","d3_geo_streamLine","coordinates","closed","coordinate","lineStart","lineEnd","d3_geo_streamPolygon","polygonStart","polygonEnd","d3_geo_areaRingStart","nextPoint","λ","φ","dλ","λ0","sdλ","adλ","cosφ","sinφ","sinφ0","u","cosφ0","d3_geo_areaRingSum","λ00","φ00","d3_geo_area","d3_geo_cartesian","spherical","d3_geo_cartesianDot","d3_geo_cartesianCross","d3_geo_cartesianAdd","d3_geo_cartesianScale","vector","d3_geo_cartesianNormalize","d3_geo_spherical","cartesian","d3_geo_sphericalEqual","ε","d3_geo_centroidPoint","d3_geo_centroidPointXYZ","d3_geo_centroidW0","d3_geo_centroidX0","d3_geo_centroidY0","d3_geo_centroidZ0","d3_geo_centroidLineStart","z0","d3_geo_centroidW1","d3_geo_centroidX1","d3_geo_centroidY1","d3_geo_centroidZ1","d3_geo_centroid","d3_geo_centroidLineEnd","d3_geo_centroidRingStart","cz","d3_geo_centroidX2","d3_geo_centroidY2","d3_geo_centroidZ2","d3_geo_compose","invert","d3_true","d3_geo_clipPolygon","segments","clipStartInside","subject","clip","segment","p0","p1","d3_geo_clipPolygonIntersection","d3_geo_clipPolygonLinkCircular","entry","isSubject","array","other","d3_geo_clip","pointVisible","clipLine","clipStart","rotate","pointLine","pointRing","ring","ringListener","ringStart","ringEnd","clean","ringSegments","buffer","pop","polygon","polygonStarted","shift","d3_geo_clipSegmentLength1","rotatedClipStart","merge","d3_geo_pointInPolygon","d3_geo_clipSort","sphere","d3_geo_clipBufferListener","rejoin","d3_geo_clipAntimeridianLine","φ0","sλ0","λ1","φ1","sλ1","d3_geo_clipAntimeridianIntersect","cosφ1","sinλ0_λ1","atan","d3_geo_clipAntimeridianInterpolate","from","to","direction","meridian","parallel","meridianNormal","polarAngle","winding","reset","point0","antimeridian","τ","intersection","φarc","d3_geo_clipCircle","visible","cr","c0","v0","v00","point2","point1","smallRadius","code","intersect","notHemisphere","two","pa","pb","n1","n2","n2n2","n1n2","determinant","c1","c2","n1xn2","uu","t2","q","δλ","polar","d3_geo_circleInterpolate","d3_geom_clipLine","y1","ax","ay","bx","dx","dy","d3_geo_clipExtent","corner","comparePoints","ca","cb","insidePolygon","wn","a1","linePoint","first","v_","x_","y_","x__","y__","v__","bufferListener","d3_geo_clipExtentMAX","listener_","inside","d3_geo_conic","projectAt","d3_geo_projectionMutator","parallels","d3_geo_conicEqualArea","forward","ρ","C","ρ0","ρ0_y","d3_geo_pathAreaRingStart","d3_geo_pathAreaPolygon","x00","y00","d3_geo_pathArea","d3_geo_pathBoundsPoint","d3_geo_pathBoundsX0","d3_geo_pathBoundsX1","d3_geo_pathBoundsY0","d3_geo_pathBoundsY1","d3_geo_pathBuffer","pointCircle","pointLineStart","stream","lineEndPolygon","d3_geo_pathBufferCircle","pointRadius","d3_geo_pathCentroidPoint","d3_geo_pathCentroidLineStart","d3_geo_pathCentroid","d3_geo_pathCentroidLineEnd","d3_geo_pathCentroidRingStart","d3_geo_pathContext","context","moveTo","lineTo","closePath","d3_geo_resample","project","resample","maxDepth","resampleRecursive","resampleNone","d3_geo_transformPoint","resampleLineTo","a0","b0","ringPoint","a00","b00","c00","b1","depth","δ2","φ2","λ2","x2","y2","dx2","dy2","dz","cosMinDistance","d3_geo_pathProjectStream","d3_geo_projectionRadians","d3_geo_transform","d3_geo_projection","projectRotate","δx","δy","d3_geo_rotation","δφ","δγ","invalidate","valid","projectResample","preclip","d3_geo_clipAntimeridian","postclip","clipAngle","clipExtent","output","translate","d3_geo_equirectangular","d3_geo_identityRotation","d3_geo_rotationλ","d3_geo_rotationφγ","d3_geo_forwardRotationλ","cosδφ","sinδφ","cosδγ","sinδγ","sr","d3_geo_circleAngle","PI","d3_geo_graticuleX","d3_geo_graticuleY","d3_source","d3_target","d3_geo_interpolate","cy0","sy0","cy1","sy1","kx0","ky0","kx1","ky1","distance","d3_geo_lengthLineStart","cosΔλ","d3_geo_lengthSum","d3_geo_length","d3_geo_azimuthal","azimuthal","cosλ","sinc","cosc","d3_geo_conicConformal","F","tan","d3_geo_mercator","d3_geo_conicEquidistant","G","d3_geo_mercatorProjection","clipAuto","d3_geo_transverseMercator","d3_geom_pointX","d3_geom_pointY","d3_geom_hullUpper","hull","hs","d3_geom_hullOrder","d3_geom_polygonInside","d3_geom_polygonIntersect","x3","x21","x43","y3","y21","y43","ua","d3_geom_polygonClosed","d3_geom_voronoiBeach","d3_geom_voronoiRedBlackNode","edge","site","d3_geom_voronoiCreateBeach","beach","d3_geom_voronoiBeachPool","d3_geom_voronoiDetachBeach","d3_geom_voronoiDetachCircle","d3_geom_voronoiBeaches","d3_geom_voronoiRemoveBeach","vertex","previous","P","next","N","disappearing","lArc","unshift","rArc","iArc","nArcs","d3_geom_voronoiSetEdgeEnd","d3_geom_voronoiCreateEdge","d3_geom_voronoiAttachCircle","d3_geom_voronoiAddBeach","dxl","dxr","directrix","d3_geom_voronoiLeftBreakPoint","d3_geom_voronoiRightBreakPoint","R","newArc","lSite","rSite","hb","hc","rfocx","rfocy","pby2","lfocx","lfocy","plby2","hl","aby2","d3_geom_voronoiCell","edges","d3_geom_voronoiCloseCells","cell","iHalfEdge","halfEdges","nHalfEdges","cells","d3_geom_voronoiCells","iCell","prepare","d3_geom_voronoiHalfEdge","d3_geom_voronoiCreateBorderEdge","d3_geom_voronoiHalfEdgeOrder","d3_geom_voronoiCircle","cSite","ε2","ha","d3_geom_voronoiCirclePool","d3_geom_voronoiCircles","d3_geom_voronoiFirstCircle","d3_geom_voronoiClipEdges","d3_geom_voronoiEdges","d3_geom_voronoiConnectEdge","vb","fm","fb","va","lx","ly","rx","ry","fx","fy","d3_geom_voronoiEdge","d3_geom_voronoiRedBlackTree","d3_geom_voronoiRedBlackRotateLeft","tree","d3_geom_voronoiRedBlackRotateRight","d3_geom_voronoiRedBlackFirst","d3_geom_voronoi","sites","bbox","d3_geom_voronoiVertexOrder","diagram","d3_geom_voronoiTriangleArea","d3_geom_quadtreeCompatX","d3_geom_quadtreeCompatY","d3_geom_quadtreeNode","leaf","nodes","d3_geom_quadtreeVisit","sx","sy","d3_geom_quadtreeFind","closestPoint","minDistance2","find","distance2","xm","ym","below","d3_interpolateRgb","ar","ag","ab","br","bg","bb","d3_interpolateObject","d3_interpolate","d3_interpolateNumber","d3_interpolateString","am","bm","bs","bi","d3_interpolate_numberA","d3_interpolate_numberB","interpolators","d3_interpolateArray","na","nb","n0","d3_ease_clamp","d3_ease_reverse","d3_ease_reflect","d3_ease_quad","d3_ease_cubic","d3_ease_cubicInOut","t3","d3_ease_poly","d3_ease_sin","d3_ease_exp","d3_ease_circle","d3_ease_elastic","d3_ease_back","d3_ease_bounce","d3_interpolateHcl","hcl","ah","ac","al","bh","bc","bl","d3_interpolateHsl","as","d3_interpolateLab","aa","ba","d3_interpolateRound","d3_transform","r0","r1","kx","d3_transformNormalize","kz","d3_transformDot","ky","d3_transformCombine","skew","d3_interpolateTransformPop","d3_interpolateTranslate","ta","tb","d3_interpolateRotate","ra","rb","d3_interpolateSkew","wa","wb","d3_interpolateScale","ka","kb","d3_interpolateTransform","transform","d3_uninterpolateNumber","d3_uninterpolateClamp","d3_layout_bundlePath","link","lca","d3_layout_bundleLeastCommonAncestor","d3_layout_bundleAncestors","ancestors","aNodes","bNodes","aNode","bNode","sharedNode","d3_layout_forceDragstart","fixed","d3_layout_forceDragend","d3_layout_forceMouseover","px","py","d3_layout_forceMouseout","d3_layout_forceAccumulate","quad","alpha","charges","charge","random","pointCharge","d3_layout_hierarchyRebind","hierarchy","links","d3_layout_hierarchyLinks","d3_layout_hierarchyVisitBefore","d3_layout_hierarchyVisitAfter","nodes2","d3_layout_hierarchyChildren","d3_layout_hierarchyValue","d3_layout_hierarchySort","d3_layout_stackX","d3_layout_stackY","d3_layout_stackOut","d3_layout_stackOrderDefault","d3_layout_stackOffsetZero","d3_layout_stackMaxIndex","d3_layout_stackReduceSum","d3_layout_stackSum","d3_layout_histogramBinSturges","d3_layout_histogramBinFixed","LN2","d3_layout_histogramRange","d3_layout_packSort","d3_layout_packInsert","_pack_next","_pack_prev","d3_layout_packSplice","d3_layout_packIntersects","dr","d3_layout_packSiblings","bound","xMin","xMax","yMin","yMax","d3_layout_packLink","d3_layout_packPlace","isect","s1","s2","d3_layout_packUnlink","d3_layout_packTransform","db","da","d3_layout_treeSeparation","d3_layout_treeLeft","d3_layout_treeRight","d3_layout_treeMove","wm","wp","change","d3_layout_treeShift","d3_layout_treeAncestor","vim","ancestor","d3_layout_clusterY","d3_layout_clusterX","d3_layout_clusterLeft","d3_layout_clusterRight","d3_layout_treemapPadNull","d3_layout_treemapPad","d3_scaleExtent","stop","d3_scaleRange","rangeExtent","d3_scale_bilinear","uninterpolate","d3_scale_nice","nice","d3_scale_niceStep","d3_scale_niceIdentity","d3_scale_polylinear","bisect","d3_scale_linear","input","d3_scale_linearTicks","d3_scale_linearTickFormat","d3_scale_linearNice","copy","d3_scale_linearRebind","d3_scale_linearTickRange","err","d3_scale_linearPrecision","d3_scale_linearFormatPrecision","d3_scale_linearFormatSignificant","d3_scale_log","base","positive","niced","d3_scale_logNiceNegative","d3_scale_logFormat","d3_scale_pow","powp","d3_scale_powPow","powb","d3_scale_ordinal","ranger","steps","xi","rangePoints","rangeRoundPoints","d3_scale_quantile","thresholds","quantiles","invertExtent","d3_scale_quantize","d3_scale_threshold","d3_scale_identity","identity","d3_zero","d3_svg_arcInnerRadius","d3_svg_arcOuterRadius","d3_svg_arcStartAngle","d3_svg_arcEndAngle","d3_svg_arcPadAngle","padAngle","d3_svg_arcSweep","d3_svg_arcCornerTangents","rc","cw","x01","y01","ox","oy","D","cx0","cx1","dx0","dy0","dx1","dy1","d3_svg_line","d3_svg_lineLinear","interpolateKey","d3_svg_lineInterpolators","d3_svg_lineLinearClosed","d3_svg_lineStep","d3_svg_lineStepBefore","d3_svg_lineStepAfter","d3_svg_lineCardinalOpen","d3_svg_lineHermite","d3_svg_lineCardinalTangents","d3_svg_lineCardinalClosed","d3_svg_lineCardinal","tangents","pi","lp","p2","d3_svg_lineBasis","d3_svg_lineDot4","d3_svg_lineBasisBezier3","d3_svg_lineBasisBezier","d3_svg_lineBasisOpen","d3_svg_lineBasisClosed","d3_svg_lineBundle","d3_svg_lineBasisBezier1","d3_svg_lineBasisBezier2","d3_svg_lineSlope","d3_svg_lineFiniteDifferences","d3_svg_lineMonotoneTangents","d3_svg_lineMonotone","d3_svg_lineRadial","d3_svg_area","points1","interpolateReverse","points0","fx0","fy0","fx1","fy1","d3_svg_chordRadius","d3_svg_diagonalProjection","d3_svg_diagonalRadialProjection","d3_svg_symbolSize","d3_svg_symbolType","d3_svg_symbolCircle","d3_selection_interruptNS","lock","activeId","active","interrupt","d3_transition","d3_transitionPrototype","d3_transition_tween","d3_transition_text","textContent","d3_transitionNamespace","d3_transitionNode","inherit","schedule","elapsed","cancelId","cancel","tick","tweens","d3_svg_axisX","d3_svg_axisY","d3_time_formatIsoNative","toISOString","d3_time_scale","methods","tickMethod","d3_time_scaleSteps","year","d3_time_scaleMilliseconds","d3_time_scaleDate","interval","skip","skipped","d3_json","d3_html","d3_document","createRange","selectNode","body","createContextualFragment","d3_arraySlice","childNodes","nodeType","d3_element_prototype","Element","d3_element_setAttribute","d3_element_setAttributeNS","d3_style_prototype","CSSStyleDeclaration","d3_style_setProperty","mean","median","numbers","variance","deviation","d3_bisect","bisectLeft","bisectRight","bisector","shuffle","permute","indexes","permutes","pairs","transpose","matrix","zip","arrays","merged","isArray","mapType","rollup","keyValue","setter","valuesByKey","sortKey","keyMap","d3_requote_re","__proto__","querySelector","querySelectorAll","d3_selectMatcher","matches","Sizzle","matchesSelector","subgroup","subnode","subgroups","d3_nsPrefix","xhtml","xlink","xml","xmlns","getAttributeNS","contains","getComputedStyle","getPropertyValue","appendChild","insertBefore","bind","groupData","nodeData","enterNodes","exitNodes","nodeByKeyValue","keyValues","nextSibling","args","upgroup","mouseenter","mouseleave","navigator","userAgent","touch","touches","drag","mousedown","touchstart","dragstart","move","moved","position1","dragId","position0","dragged","dragOffset","ended","dragSubject","dragName","dragRestore","that","correspondingElement","origin","τε","SQRT2","interpolateZoom","ux0","uy0","w0","ux1","uy1","w1","coshr0","mousedowned","d3_behavior_zoomWheel","mousewheeled","dblclicked","touchstarted","view","scaleTo","translateTo","zoomTo","center0","zoomstarted","zooming","zoomended","location0","mousemove","mouseup","d3_selection_interrupt","relocate","scale0","locations0","started","touchmove","touchend","targets","changed","touchtime","distance0","l0","l1","distance1","scale1","zoomName","mousewheelTimer","translate0","d3_behavior_zoomDelta","shiftKey","d3_behavior_zoomInfinity","deltaY","deltaMode","wheelDelta","detail","view1","d3_transitionInheritId","d3_hslPrototype","brighter","darker","d3_hclPrototype","d3_lab_K","d3_labPrototype","d3_rgbPrototype","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","dsv","delimiter","typedResponse","formatRow","formatValue","reFormat","delimiterCode","parseRows","Function","token","EOF","eol","EOL","formatRows","fieldSet","fields","csv","tsv","d3_formatPrefixes","fromCharCode","toPrecision","toExponential","toFixed","getUTCDate","getUTCDay","getUTCFullYear","getUTCHours","getUTCMilliseconds","getUTCMinutes","getUTCMonth","getUTCSeconds","setDate","d3_time_prototype","setUTCDate","setDay","setUTCDay","setUTCFullYear","setUTCHours","setMilliseconds","setUTCMilliseconds","setMinutes","setUTCMinutes","setMonth","setUTCMonth","setSeconds","setUTCSeconds","setTime","day","years","week","sunday","weeks","weekOfYear","-","0","numberFormat","timeFormat","d3_locale_enUS","d3_adderTemp","d3_geo_streamObjectType","Feature","feature","FeatureCollection","features","Sphere","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","GeometryCollection","geometries","d3_geo_areaSum","bounds","normal","equatorial","inflection","λ_","λi","φi","dλSum","λ__","φ__","compareRanges","withinRange","best","conicEqualArea","raw","albers","albersUsa","lower48Point","alaskaPoint","hawaiiPoint","lower48","alaska","hawaii","pointStream","lower48Stream","alaskaStream","hawaiiStream","d3_geo_pathAreaSum","d3_geo_pathBounds","contextStream","cacheStream","projectStream","projectionMutator","equirectangular","Δλ","sinΔλ","sinφ1","graticule","X0","DX","X1","Y0","DY","Y1","outline","majorExtent","minorExtent","majorStep","minorStep","greatArc","source_","target_","d3_geo_azimuthalEqualArea","cosλcosφ","azimuthalEqualArea","d3_geo_azimuthalEquidistant","azimuthalEquidistant","conicConformal","conicEquidistant","d3_geo_gnomonic","gnomonic","mercator","d3_geo_orthographic","orthographic","d3_geo_stereographic","stereographic","transverseMercator","geom","vertices","flippedPoints","upper","lower","skipLeft","skipRight","d3_geom_polygonPrototype","grandpa","uncle","sibling","voronoi","polygons","d3_geom_voronoiClipExtent","triangles","s0","delaunay","quadtree","nx","ny","insertChild","nPoint","xs","ys","x1_","y1_","x2_","y2_","compat","visit","interpolateRgb","interpolateObject","interpolateString","interpolateArray","d3_ease_default","d3_ease","poly","cubic","elastic","back","bounce","d3_ease_mode","in","out","in-out","out-in","interpolateHsl","interpolateLab","interpolateRound","baseVal","consolidate","d3_transformIdentity","interpolateTransform","bundle","chord","relayout","groupSums","groupIndex","subgroupIndex","chords","sortGroups","sortSubgroups","di","dj","subindex","sortChords","resort","force","repulse","dw","dn","theta2","chargeDistance2","dragmove","resume","distances","strengths","friction","linkDistance","d3_layout_forceLinkDistance","linkStrength","d3_layout_forceLinkStrength","d3_layout_forceChargeDistance2","gravity","weight","chargeDistance","theta","neighbors","candidates","childs","revalue","partition","arcs","d3_layout_pieSortByValue","series","orders","offsets","d3_layout_stackOrders","d3_layout_stackOffsets","inside-out","sums","tops","bottoms","default","silhouette","wiggle","s3","o0","expand","zero","histogram","bin","bins","valuer","binner","frequency","pack","root0","root1","wrapTree","firstWalk","secondWalk","nodeSize","sizeNode","tx","separation","node1","queue","siblings","midpoint","apportion","vip","vop","vom","sip","sop","sim","som","cluster","previousNode","treemap","squarify","score","pad","remaining","mode","worst","stickify","rmax","rmin","ratio","stickies","sticky","padFunction","padConstant","µ","σ","logNormal","bates","irwinHall","d3_category10","category20","d3_category20","category20b","d3_category20b","d3_category20c","threshold","circleSegment","rp","ap","padRadius","d3_svg_arcAuto","h1","h0","cornerRadius","rc1","rc0","oc","kc","lc","t30","t12","t03","t21","linear-closed","step-before","step-after","basis","basis-open","basis-closed","cardinal","cardinal-open","cardinal-closed","monotone","radial","equals","curve","self","diagonal","p3","projection_","d3_svg_symbols","cross","diamond","d3_svg_symbolTan30","square","triangle-down","d3_svg_symbolSqrt3","triangle-up","symbolTypes","d3_transitionId","d3_transitionInherit","subnodes","nameNS","attrTweenNS","styleString","styleTween","inheritId","id0","id1","tickTransform","tickArguments_","tickFormat_","tickEnter","tickExit","tickUpdate","tickSpacing","innerTickSize","tickPadding","pathUpdate","lineEnter","lineUpdate","textEnter","textUpdate","outerTickSize","d3_svg_axisDefaultOrient","d3_svg_axisOrients","tickSize","tickSubdivide","brushstart","background","resize","resizes","d3_svg_brushCursor","gUpdate","backgroundUpdate","redrawX","redrawY","xExtent","yExtent","keydown","keyCode","dragging","keyup","brushmove","altKey","resizingX","move1","resizingY","event_","yClamp","xClamp","yExtentDomain","xExtentDomain","brushend","eventTarget","ex","ey","d3_svg_brushResizes","extent1","extent0","yi","nw","ne","se","sw","d3_time_formatUtc","d3_time_formatIso","iso","second","seconds","minute","minutes","hour","timezone","hours","month","d3_time_scaleLocalMethods","d3_time_scaleLocalFormat","d3_time_scaleUtcMethods","d3_time_scaleUtcFormat","responseXML","272","273","crossfilter_identity","bisect_by","heap_by","heap","sift","heapselect_by","heapselect","insertionsort_by","insertionsort","quicksort_by","quicksort_sizeThreshold","sixth","i5","i3","i4","e2","e3","e4","x4","e5","x5","pivot1","pivotValue1","pivot2","pivotValue2","less","great","pivotsEqual","ek","xk","greatValue","lessValue","crossfilter_arrayUntyped","crossfilter_arrayLengthenUntyped","crossfilter_arrayWidenUntyped","crossfilter_filterExact","crossfilter_filterRange","crossfilter_filterAll","crossfilter_null","crossfilter_zero","crossfilter_reduceIncrement","crossfilter_reduceDecrement","crossfilter_reduceAdd","crossfilter_reduceSubtract","newData","crossfilter_arrayLengthen","dataListeners","removeData","newIndex","crossfilter_index","removed","filterListeners","removeDataListeners","preAdd","newValues","crossfilter_range","refilter","lo1","hi1","refilterFunction","lo0","hi0","oldValues","oldIndex","postAdd","indexListeners","reIndex","filterIndexBounds","filterIndexFunction","added","groupIncrement","groupCapacity","crossfilter_arrayWiden","groupWidth","crossfilter_capacity","g0","oldGroups","reduceAdd","initial","reduceInitial","k0","resetNeeded","updateMany","resetMany","updateOne","resetOne","oldK","seenGroups","filterOne","reduceRemove","reduceCount","reduceSum","orderNatural","dispose","dimensionGroups","reduceValue","crossfilter_array8","crossfilter_array16","crossfilter_array32","Uint8Array","Uint16Array","Uint32Array","293","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","writable","configurable","setPrototypeOf","__WEBPACK_IMPORTED_MODULE_1_react_dom__","__WEBPACK_IMPORTED_MODULE_2_reactstrap__","__WEBPACK_IMPORTED_MODULE_3_prop_types__","__WEBPACK_IMPORTED_MODULE_3_prop_types___default","__WEBPACK_IMPORTED_MODULE_4_dc__","__WEBPACK_IMPORTED_MODULE_4_dc___default","_createClass","defineProperties","descriptor","protoProps","staticProps","Chart","_PureComponent","_this","getPrototypeOf","_this2","dim","ndx","refs","el","_props","wrapperProps","ref","display","contextTypes","isRequired","defaultProps","propTypes","bool"],"mappings":"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","file":"static/js/1.c49891a7.chunk.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 268:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_reactstrap__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_Chart__ = __webpack_require__(293);\nvar HCIM=function HCIM(props){return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1_reactstrap__[\"d\" /* Container */],{fluid:true},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1_reactstrap__[\"e\" /* Jumbotron */],{style:{marginBottom:\"1rem\"}},__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"h2\",null,\"WIP: Explore Hardcore Ironman Deaths (from Runescape)\"),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"p\",{className:\"lead\"},\"The data this is based on is pulled from the spreadsheet\",\" \",__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"a\",{href:\"https://www.reddit.com/user/CaptainP\",target:\"_blank\",rel:\"noopener noreferrer\"},\"CaptainP\"),\" \",\"provided on reddit after his own analyis of his scraped data.\"),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"p\",null,\"This includes over 10.5 thousand HCIM deaths from 18/11/2014 to 2/09/2017.\",__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"br\",null),\"If you're interested, you can view the reddit post and comments \",__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"a\",{href:\"https://www.reddit.com/r/runescape/comments/6y0oit/i_used_an_html_parser_to_pull_all_105k_hcim/\",target:\"_blank\",rel:\"noopener noreferrer\"},\"here\"),\".\")),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1_reactstrap__[\"l\" /* Row */],null,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_Chart__[\"a\" /* default */],{field:\"Location\",nullValue:\"Unknown\",chartOptions:{cap:10,height:400}}),__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__components_Chart__[\"a\" /* default */],{field:\"Death\",nullValue:\"Unknown\",chartOptions:{cap:10,height:400}})));};/* harmony default export */ __webpack_exports__[\"default\"] = (HCIM);\n\n/***/ }),\n\n/***/ 270:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n *  dc 2.1.8\n *  http://dc-js.github.io/dc.js/\n *  Copyright 2012-2016 Nick Zhu & the dc.js Developers\n *  https://github.com/dc-js/dc.js/blob/master/AUTHORS\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n(function() { function _dc(d3, crossfilter) {\n'use strict';\n\n/**\n * The entire dc.js library is scoped under the **dc** name space. It does not introduce\n * anything else into the global name space.\n *\n * Most `dc` functions are designed to allow function chaining, meaning they return the current chart\n * instance whenever it is appropriate.  The getter forms of functions do not participate in function\n * chaining because they return values that are not the chart, although some,\n * such as {@link dc.baseMixin#svg .svg} and {@link dc.coordinateGridMixin#xAxis .xAxis},\n * return values that are themselves chainable d3 objects.\n * @namespace dc\n * @version 2.1.8\n * @example\n * // Example chaining\n * chart.width(300)\n *      .height(300)\n *      .filter('sunday');\n */\n/*jshint -W079*/\nvar dc = {\n    version: '2.1.8',\n    constants: {\n        CHART_CLASS: 'dc-chart',\n        DEBUG_GROUP_CLASS: 'debug',\n        STACK_CLASS: 'stack',\n        DESELECTED_CLASS: 'deselected',\n        SELECTED_CLASS: 'selected',\n        NODE_INDEX_NAME: '__index__',\n        GROUP_INDEX_NAME: '__group_index__',\n        DEFAULT_CHART_GROUP: '__default_chart_group__',\n        EVENT_DELAY: 40,\n        NEGLIGIBLE_NUMBER: 1e-10\n    },\n    _renderlet: null\n};\n/*jshint +W079*/\n\n/**\n * The dc.chartRegistry object maintains sets of all instantiated dc.js charts under named groups\n * and the default group.\n *\n * A chart group often corresponds to a crossfilter instance. It specifies\n * the set of charts which should be updated when a filter changes on one of the charts or when the\n * global functions {@link dc.filterAll dc.filterAll}, {@link dc.refocusAll dc.refocusAll},\n * {@link dc.renderAll dc.renderAll}, {@link dc.redrawAll dc.redrawAll}, or chart functions\n * {@link dc.baseMixin#renderGroup baseMixin.renderGroup},\n * {@link dc.baseMixin#redrawGroup baseMixin.redrawGroup} are called.\n *\n * @namespace chartRegistry\n * @memberof dc\n * @type {{has, register, deregister, clear, list}}\n */\ndc.chartRegistry = (function () {\n    // chartGroup:string => charts:array\n    var _chartMap = {};\n\n    function initializeChartGroup (group) {\n        if (!group) {\n            group = dc.constants.DEFAULT_CHART_GROUP;\n        }\n\n        if (!_chartMap[group]) {\n            _chartMap[group] = [];\n        }\n\n        return group;\n    }\n\n    return {\n        /**\n         * Determine if a given chart instance resides in any group in the registry.\n         * @method has\n         * @memberof dc.chartRegistry\n         * @param {Object} chart dc.js chart instance\n         * @returns {Boolean}\n         */\n        has: function (chart) {\n            for (var e in _chartMap) {\n                if (_chartMap[e].indexOf(chart) >= 0) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /**\n         * Add given chart instance to the given group, creating the group if necessary.\n         * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n         * @method register\n         * @memberof dc.chartRegistry\n         * @param {Object} chart dc.js chart instance\n         * @param {String} [group] Group name\n         */\n        register: function (chart, group) {\n            group = initializeChartGroup(group);\n            _chartMap[group].push(chart);\n        },\n\n        /**\n         * Remove given chart instance from the given group, creating the group if necessary.\n         * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n         * @method deregister\n         * @memberof dc.chartRegistry\n         * @param {Object} chart dc.js chart instance\n         * @param {String} [group] Group name\n         */\n        deregister: function (chart, group) {\n            group = initializeChartGroup(group);\n            for (var i = 0; i < _chartMap[group].length; i++) {\n                if (_chartMap[group][i].anchorName() === chart.anchorName()) {\n                    _chartMap[group].splice(i, 1);\n                    break;\n                }\n            }\n        },\n\n        /**\n         * Clear given group if one is provided, otherwise clears all groups.\n         * @method clear\n         * @memberof dc.chartRegistry\n         * @param {String} group Group name\n         */\n        clear: function (group) {\n            if (group) {\n                delete _chartMap[group];\n            } else {\n                _chartMap = {};\n            }\n        },\n\n        /**\n         * Get an array of each chart instance in the given group.\n         * If no group is provided, the charts in the default group are returned.\n         * @method list\n         * @memberof dc.chartRegistry\n         * @param {String} [group] Group name\n         * @returns {Array<Object>}\n         */\n        list: function (group) {\n            group = initializeChartGroup(group);\n            return _chartMap[group];\n        }\n    };\n})();\n\n/**\n * Add given chart instance to the given group, creating the group if necessary.\n * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n * @memberof dc\n * @method registerChart\n * @param {Object} chart dc.js chart instance\n * @param {String} [group] Group name\n */\ndc.registerChart = function (chart, group) {\n    dc.chartRegistry.register(chart, group);\n};\n\n/**\n * Remove given chart instance from the given group, creating the group if necessary.\n * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n * @memberof dc\n * @method deregisterChart\n * @param {Object} chart dc.js chart instance\n * @param {String} [group] Group name\n */\ndc.deregisterChart = function (chart, group) {\n    dc.chartRegistry.deregister(chart, group);\n};\n\n/**\n * Determine if a given chart instance resides in any group in the registry.\n * @memberof dc\n * @method hasChart\n * @param {Object} chart dc.js chart instance\n * @returns {Boolean}\n */\ndc.hasChart = function (chart) {\n    return dc.chartRegistry.has(chart);\n};\n\n/**\n * Clear given group if one is provided, otherwise clears all groups.\n * @memberof dc\n * @method deregisterAllCharts\n * @param {String} group Group name\n */\ndc.deregisterAllCharts = function (group) {\n    dc.chartRegistry.clear(group);\n};\n\n/**\n * Clear all filters on all charts within the given chart group. If the chart group is not given then\n * only charts that belong to the default chart group will be reset.\n * @memberof dc\n * @method filterAll\n * @param {String} [group]\n */\ndc.filterAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].filterAll();\n    }\n};\n\n/**\n * Reset zoom level / focus on all charts that belong to the given chart group. If the chart group is\n * not given then only charts that belong to the default chart group will be reset.\n * @memberof dc\n * @method refocusAll\n * @param {String} [group]\n */\ndc.refocusAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        if (charts[i].focus) {\n            charts[i].focus();\n        }\n    }\n};\n\n/**\n * Re-render all charts belong to the given chart group. If the chart group is not given then only\n * charts that belong to the default chart group will be re-rendered.\n * @memberof dc\n * @method renderAll\n * @param {String} [group]\n */\ndc.renderAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].render();\n    }\n\n    if (dc._renderlet !== null) {\n        dc._renderlet(group);\n    }\n};\n\n/**\n * Redraw all charts belong to the given chart group. If the chart group is not given then only charts\n * that belong to the default chart group will be re-drawn. Redraw is different from re-render since\n * when redrawing dc tries to update the graphic incrementally, using transitions, instead of starting\n * from scratch.\n * @memberof dc\n * @method redrawAll\n * @param {String} [group]\n */\ndc.redrawAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].redraw();\n    }\n\n    if (dc._renderlet !== null) {\n        dc._renderlet(group);\n    }\n};\n\n/**\n * If this boolean is set truthy, all transitions will be disabled, and changes to the charts will happen\n * immediately.\n * @memberof dc\n * @member disableTransitions\n * @type {Boolean}\n * @default false\n */\ndc.disableTransitions = false;\n\n/**\n * Start a transition on a selection if transitions are globally enabled\n * ({@link dc.disableTransitions} is false) and the duration is greater than zero; otherwise return\n * the selection. Since most operations are the same on a d3 selection and a d3 transition, this\n * allows a common code path for both cases.\n * @memberof dc\n * @method transition\n * @param {d3.selection} selection - the selection to be transitioned\n * @param {Number|Function} [duration=250] - the duration of the transition in milliseconds, a\n * function returning the duration, or 0 for no transition\n * @param {Number|Function} [delay] - the delay of the transition in milliseconds, or a function\n * returning the delay, or 0 for no delay\n * @param {String} [name] - the name of the transition (if concurrent transitions on the same\n * elements are needed)\n * @returns {d3.transition|d3.selection}\n */\ndc.transition = function (selection, duration, delay, name) {\n    if (dc.disableTransitions || duration <= 0) {\n        return selection;\n    }\n\n    var s = selection.transition(name);\n\n    if (duration >= 0 || duration !== undefined) {\n        s = s.duration(duration);\n    }\n    if (delay >= 0 || delay !== undefined) {\n        s = s.delay(delay);\n    }\n\n    return s;\n};\n\n/* somewhat silly, but to avoid duplicating logic */\ndc.optionalTransition = function (enable, duration, delay, name) {\n    if (enable) {\n        return function (selection) {\n            return dc.transition(selection, duration, delay, name);\n        };\n    } else {\n        return function (selection) {\n            return selection;\n        };\n    }\n};\n\n// See http://stackoverflow.com/a/20773846\ndc.afterTransition = function (transition, callback) {\n    if (transition.empty() || !transition.duration) {\n        callback.call(transition);\n    } else {\n        var n = 0;\n        transition\n            .each(function () { ++n; })\n            .each('end', function () {\n                if (!--n) {\n                    callback.call(transition);\n                }\n            });\n    }\n};\n\n/**\n * @namespace units\n * @memberof dc\n * @type {{}}\n */\ndc.units = {};\n\n/**\n * The default value for {@link dc.coordinateGridMixin#xUnits .xUnits} for the\n * {@link dc.coordinateGridMixin Coordinate Grid Chart} and should\n * be used when the x values are a sequence of integers.\n * It is a function that counts the number of integers in the range supplied in its start and end parameters.\n * @method integers\n * @memberof dc.units\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\n * @example\n * chart.xUnits(dc.units.integers) // already the default\n * @param {Number} start\n * @param {Number} end\n * @returns {Number}\n */\ndc.units.integers = function (start, end) {\n    return Math.abs(end - start);\n};\n\n/**\n * This argument can be passed to the {@link dc.coordinateGridMixin#xUnits .xUnits} function of the to\n * specify ordinal units for the x axis. Usually this parameter is used in combination with passing\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md d3.scale.ordinal} to\n * {@link dc.coordinateGridMixin#x .x}.\n * It just returns the domain passed to it, which for ordinal charts is an array of all values.\n * @method ordinal\n * @memberof dc.units\n * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md d3.scale.ordinal}\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\n * @see {@link dc.coordinateGridMixin#x coordinateGridMixin.x}\n * @example\n * chart.xUnits(dc.units.ordinal)\n *      .x(d3.scale.ordinal())\n * @param {*} start\n * @param {*} end\n * @param {Array<String>} domain\n * @returns {Array<String>}\n */\ndc.units.ordinal = function (start, end, domain) {\n    return domain;\n};\n\n/**\n * @namespace fp\n * @memberof dc.units\n * @type {{}}\n */\ndc.units.fp = {};\n/**\n * This function generates an argument for the {@link dc.coordinateGridMixin Coordinate Grid Chart}\n * {@link dc.coordinateGridMixin#xUnits .xUnits} function specifying that the x values are floating-point\n * numbers with the given precision.\n * The returned function determines how many values at the given precision will fit into the range\n * supplied in its start and end parameters.\n * @method precision\n * @memberof dc.units.fp\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\n * @example\n * // specify values (and ticks) every 0.1 units\n * chart.xUnits(dc.units.fp.precision(0.1)\n * // there are 500 units between 0.5 and 1 if the precision is 0.001\n * var thousandths = dc.units.fp.precision(0.001);\n * thousandths(0.5, 1.0) // returns 500\n * @param {Number} precision\n * @returns {Function} start-end unit function\n */\ndc.units.fp.precision = function (precision) {\n    var _f = function (s, e) {\n        var d = Math.abs((e - s) / _f.resolution);\n        if (dc.utils.isNegligible(d - Math.floor(d))) {\n            return Math.floor(d);\n        } else {\n            return Math.ceil(d);\n        }\n    };\n    _f.resolution = precision;\n    return _f;\n};\n\ndc.round = {};\ndc.round.floor = function (n) {\n    return Math.floor(n);\n};\ndc.round.ceil = function (n) {\n    return Math.ceil(n);\n};\ndc.round.round = function (n) {\n    return Math.round(n);\n};\n\ndc.override = function (obj, functionName, newFunction) {\n    var existingFunction = obj[functionName];\n    obj['_' + functionName] = existingFunction;\n    obj[functionName] = newFunction;\n};\n\ndc.renderlet = function (_) {\n    if (!arguments.length) {\n        return dc._renderlet;\n    }\n    dc._renderlet = _;\n    return dc;\n};\n\ndc.instanceOfChart = function (o) {\n    return o instanceof Object && o.__dcFlag__ && true;\n};\n\ndc.errors = {};\n\ndc.errors.Exception = function (msg) {\n    var _msg = msg || 'Unexpected internal error';\n\n    this.message = _msg;\n\n    this.toString = function () {\n        return _msg;\n    };\n    this.stack = (new Error()).stack;\n};\ndc.errors.Exception.prototype = Object.create(Error.prototype);\ndc.errors.Exception.prototype.constructor = dc.errors.Exception;\n\ndc.errors.InvalidStateException = function () {\n    dc.errors.Exception.apply(this, arguments);\n};\n\ndc.errors.InvalidStateException.prototype = Object.create(dc.errors.Exception.prototype);\ndc.errors.InvalidStateException.prototype.constructor = dc.errors.InvalidStateException;\n\ndc.errors.BadArgumentException = function () {\n    dc.errors.Exception.apply(this, arguments);\n};\n\ndc.errors.BadArgumentException.prototype = Object.create(dc.errors.Exception.prototype);\ndc.errors.BadArgumentException.prototype.constructor = dc.errors.BadArgumentException;\n\n/**\n * The default date format for dc.js\n * @name dateFormat\n * @memberof dc\n * @type {Function}\n * @default d3.time.format('%m/%d/%Y')\n */\ndc.dateFormat = d3.time.format('%m/%d/%Y');\n\n/**\n * @namespace printers\n * @memberof dc\n * @type {{}}\n */\ndc.printers = {};\n\n/**\n * Converts a list of filters into a readable string.\n * @method filters\n * @memberof dc.printers\n * @param {Array<dc.filters>} filters\n * @returns {String}\n */\ndc.printers.filters = function (filters) {\n    var s = '';\n\n    for (var i = 0; i < filters.length; ++i) {\n        if (i > 0) {\n            s += ', ';\n        }\n        s += dc.printers.filter(filters[i]);\n    }\n\n    return s;\n};\n\n/**\n * Converts a filter into a readable string.\n * @method filter\n * @memberof dc.printers\n * @param {dc.filters|any|Array<any>} filter\n * @returns {String}\n */\ndc.printers.filter = function (filter) {\n    var s = '';\n\n    if (typeof filter !== 'undefined' && filter !== null) {\n        if (filter instanceof Array) {\n            if (filter.length >= 2) {\n                s = '[' + dc.utils.printSingleValue(filter[0]) + ' -> ' + dc.utils.printSingleValue(filter[1]) + ']';\n            } else if (filter.length >= 1) {\n                s = dc.utils.printSingleValue(filter[0]);\n            }\n        } else {\n            s = dc.utils.printSingleValue(filter);\n        }\n    }\n\n    return s;\n};\n\n/**\n * Returns a function that given a string property name, can be used to pluck the property off an object.  A function\n * can be passed as the second argument to also alter the data being returned.\n *\n * This can be a useful shorthand method to create accessor functions.\n * @method pluck\n * @memberof dc\n * @example\n * var xPluck = dc.pluck('x');\n * var objA = {x: 1};\n * xPluck(objA) // 1\n * @example\n * var xPosition = dc.pluck('x', function (x, i) {\n *     // `this` is the original datum,\n *     // `x` is the x property of the datum,\n *     // `i` is the position in the array\n *     return this.radius + x;\n * });\n * dc.selectAll('.circle').data(...).x(xPosition);\n * @param {String} n\n * @param {Function} [f]\n * @returns {Function}\n */\ndc.pluck = function (n, f) {\n    if (!f) {\n        return function (d) { return d[n]; };\n    }\n    return function (d, i) { return f.call(d, d[n], i); };\n};\n\n/**\n * @namespace utils\n * @memberof dc\n * @type {{}}\n */\ndc.utils = {};\n\n/**\n * Print a single value filter.\n * @method printSingleValue\n * @memberof dc.utils\n * @param {any} filter\n * @returns {String}\n */\ndc.utils.printSingleValue = function (filter) {\n    var s = '' + filter;\n\n    if (filter instanceof Date) {\n        s = dc.dateFormat(filter);\n    } else if (typeof(filter) === 'string') {\n        s = filter;\n    } else if (dc.utils.isFloat(filter)) {\n        s = dc.utils.printSingleValue.fformat(filter);\n    } else if (dc.utils.isInteger(filter)) {\n        s = Math.round(filter);\n    }\n\n    return s;\n};\ndc.utils.printSingleValue.fformat = d3.format('.2f');\n\n/**\n * Arbitrary add one value to another.\n * @method add\n * @memberof dc.utils\n * @todo\n * These assume than any string r is a percentage (whether or not it includes %).\n * They also generate strange results if l is a string.\n * @param {String|Date|Number} l the value to modify\n * @param {Number} r the amount by which to modify the value\n * @param {String} [t] if `l` is a `Date`, the\n * [interval](https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#interval) in\n * the `d3.time` namespace\n * @returns {String|Date|Number}\n */\ndc.utils.add = function (l, r, t) {\n    if (typeof r === 'string') {\n        r = r.replace('%', '');\n    }\n\n    if (l instanceof Date) {\n        if (typeof r === 'string') {\n            r = +r;\n        }\n        if (t === 'millis') {\n            return new Date(l.getTime() + r);\n        }\n        t = t || 'day';\n        return d3.time[t].offset(l, r);\n    } else if (typeof r === 'string') {\n        var percentage = (+r / 100);\n        return l > 0 ? l * (1 + percentage) : l * (1 - percentage);\n    } else {\n        return l + r;\n    }\n};\n\n/**\n * Arbitrary subtract one value from another.\n * @method subtract\n * @memberof dc.utils\n * @todo\n * These assume than any string r is a percentage (whether or not it includes %).\n * They also generate strange results if l is a string.\n * @param {String|Date|Number} l the value to modify\n * @param {Number} r the amount by which to modify the value\n * @param {String} [t] if `l` is a `Date`, the\n * [interval](https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#interval) in\n * the `d3.time` namespace\n * @returns {String|Date|Number}\n */\ndc.utils.subtract = function (l, r, t) {\n    if (typeof r === 'string') {\n        r = r.replace('%', '');\n    }\n\n    if (l instanceof Date) {\n        if (typeof r === 'string') {\n            r = +r;\n        }\n        if (t === 'millis') {\n            return new Date(l.getTime() - r);\n        }\n        t = t || 'day';\n        return d3.time[t].offset(l, -r);\n    } else if (typeof r === 'string') {\n        var percentage = (+r / 100);\n        return l < 0 ? l * (1 + percentage) : l * (1 - percentage);\n    } else {\n        return l - r;\n    }\n};\n\n/**\n * Is the value a number?\n * @method isNumber\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isNumber = function (n) {\n    return n === +n;\n};\n\n/**\n * Is the value a float?\n * @method isFloat\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isFloat = function (n) {\n    return n === +n && n !== (n | 0);\n};\n\n/**\n * Is the value an integer?\n * @method isInteger\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isInteger = function (n) {\n    return n === +n && n === (n | 0);\n};\n\n/**\n * Is the value very close to zero?\n * @method isNegligible\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isNegligible = function (n) {\n    return !dc.utils.isNumber(n) || (n < dc.constants.NEGLIGIBLE_NUMBER && n > -dc.constants.NEGLIGIBLE_NUMBER);\n};\n\n/**\n * Ensure the value is no greater or less than the min/max values.  If it is return the boundary value.\n * @method clamp\n * @memberof dc.utils\n * @param {any} val\n * @param {any} min\n * @param {any} max\n * @returns {any}\n */\ndc.utils.clamp = function (val, min, max) {\n    return val < min ? min : (val > max ? max : val);\n};\n\n/**\n * Using a simple static counter, provide a unique integer id.\n * @method uniqueId\n * @memberof dc.utils\n * @returns {Number}\n */\nvar _idCounter = 0;\ndc.utils.uniqueId = function () {\n    return ++_idCounter;\n};\n\n/**\n * Convert a name to an ID.\n * @method nameToId\n * @memberof dc.utils\n * @param {String} name\n * @returns {String}\n */\ndc.utils.nameToId = function (name) {\n    return name.toLowerCase().replace(/[\\s]/g, '_').replace(/[\\.']/g, '');\n};\n\n/**\n * Append or select an item on a parent element.\n * @method appendOrSelect\n * @memberof dc.utils\n * @param {d3.selection} parent\n * @param {String} selector\n * @param {String} tag\n * @returns {d3.selection}\n */\ndc.utils.appendOrSelect = function (parent, selector, tag) {\n    tag = tag || selector;\n    var element = parent.select(selector);\n    if (element.empty()) {\n        element = parent.append(tag);\n    }\n    return element;\n};\n\n/**\n * Return the number if the value is a number; else 0.\n * @method safeNumber\n * @memberof dc.utils\n * @param {Number|any} n\n * @returns {Number}\n */\ndc.utils.safeNumber = function (n) { return dc.utils.isNumber(+n) ? +n : 0;};\n\ndc.logger = {};\n\ndc.logger.enableDebugLog = false;\n\ndc.logger.warn = function (msg) {\n    if (console) {\n        if (console.warn) {\n            console.warn(msg);\n        } else if (console.log) {\n            console.log(msg);\n        }\n    }\n\n    return dc.logger;\n};\n\ndc.logger.debug = function (msg) {\n    if (dc.logger.enableDebugLog && console) {\n        if (console.debug) {\n            console.debug(msg);\n        } else if (console.log) {\n            console.log(msg);\n        }\n    }\n\n    return dc.logger;\n};\n\ndc.logger.deprecate = function (fn, msg) {\n    // Allow logging of deprecation\n    var warned = false;\n    function deprecated () {\n        if (!warned) {\n            dc.logger.warn(msg);\n            warned = true;\n        }\n        return fn.apply(this, arguments);\n    }\n    return deprecated;\n};\n\ndc.events = {\n    current: null\n};\n\n/**\n * This function triggers a throttled event function with a specified delay (in milli-seconds).  Events\n * that are triggered repetitively due to user interaction such brush dragging might flood the library\n * and invoke more renders than can be executed in time. Using this function to wrap your event\n * function allows the library to smooth out the rendering by throttling events and only responding to\n * the most recent event.\n * @name events.trigger\n * @memberof dc\n * @example\n * chart.on('renderlet', function(chart) {\n *     // smooth the rendering through event throttling\n *     dc.events.trigger(function(){\n *         // focus some other chart to the range selected by user on this chart\n *         someOtherChart.focus(chart.filter());\n *     });\n * })\n * @param {Function} closure\n * @param {Number} [delay]\n */\ndc.events.trigger = function (closure, delay) {\n    if (!delay) {\n        closure();\n        return;\n    }\n\n    dc.events.current = closure;\n\n    setTimeout(function () {\n        if (closure === dc.events.current) {\n            closure();\n        }\n    }, delay);\n};\n\n/**\n * The dc.js filters are functions which are passed into crossfilter to chose which records will be\n * accumulated to produce values for the charts.  In the crossfilter model, any filters applied on one\n * dimension will affect all the other dimensions but not that one.  dc always applies a filter\n * function to the dimension; the function combines multiple filters and if any of them accept a\n * record, it is filtered in.\n *\n * These filter constructors are used as appropriate by the various charts to implement brushing.  We\n * mention below which chart uses which filter.  In some cases, many instances of a filter will be added.\n *\n * Each of the dc.js filters is an object with the following properties:\n * * `isFiltered` - a function that returns true if a value is within the filter\n * * `filterType` - a string identifying the filter, here the name of the constructor\n *\n * Currently these filter objects are also arrays, but this is not a requirement. Custom filters\n * can be used as long as they have the properties above.\n * @namespace filters\n * @memberof dc\n * @type {{}}\n */\ndc.filters = {};\n\n/**\n * RangedFilter is a filter which accepts keys between `low` and `high`.  It is used to implement X\n * axis brushing for the {@link dc.coordinateGridMixin coordinate grid charts}.\n *\n * Its `filterType` is 'RangedFilter'\n * @name RangedFilter\n * @memberof dc.filters\n * @param {Number} low\n * @param {Number} high\n * @returns {Array<Number>}\n * @constructor\n */\ndc.filters.RangedFilter = function (low, high) {\n    var range = new Array(low, high);\n    range.isFiltered = function (value) {\n        return value >= this[0] && value < this[1];\n    };\n    range.filterType = 'RangedFilter';\n\n    return range;\n};\n\n/**\n * TwoDimensionalFilter is a filter which accepts a single two-dimensional value.  It is used by the\n * {@link dc.heatMap heat map chart} to include particular cells as they are clicked.  (Rows and columns are\n * filtered by filtering all the cells in the row or column.)\n *\n * Its `filterType` is 'TwoDimensionalFilter'\n * @name TwoDimensionalFilter\n * @memberof dc.filters\n * @param {Array<Number>} filter\n * @returns {Array<Number>}\n * @constructor\n */\ndc.filters.TwoDimensionalFilter = function (filter) {\n    if (filter === null) { return null; }\n\n    var f = filter;\n    f.isFiltered = function (value) {\n        return value.length && value.length === f.length &&\n               value[0] === f[0] && value[1] === f[1];\n    };\n    f.filterType = 'TwoDimensionalFilter';\n\n    return f;\n};\n\n/**\n * The RangedTwoDimensionalFilter allows filtering all values which fit within a rectangular\n * region. It is used by the {@link dc.scatterPlot scatter plot} to implement rectangular brushing.\n *\n * It takes two two-dimensional points in the form `[[x1,y1],[x2,y2]]`, and normalizes them so that\n * `x1 <= x2` and `y1 <= y2`. It then returns a filter which accepts any points which are in the\n * rectangular range including the lower values but excluding the higher values.\n *\n * If an array of two values are given to the RangedTwoDimensionalFilter, it interprets the values as\n * two x coordinates `x1` and `x2` and returns a filter which accepts any points for which `x1 <= x <\n * x2`.\n *\n * Its `filterType` is 'RangedTwoDimensionalFilter'\n * @name RangedTwoDimensionalFilter\n * @memberof dc.filters\n * @param {Array<Array<Number>>} filter\n * @returns {Array<Array<Number>>}\n * @constructor\n */\ndc.filters.RangedTwoDimensionalFilter = function (filter) {\n    if (filter === null) { return null; }\n\n    var f = filter;\n    var fromBottomLeft;\n\n    if (f[0] instanceof Array) {\n        fromBottomLeft = [\n            [Math.min(filter[0][0], filter[1][0]), Math.min(filter[0][1], filter[1][1])],\n            [Math.max(filter[0][0], filter[1][0]), Math.max(filter[0][1], filter[1][1])]\n        ];\n    } else {\n        fromBottomLeft = [[filter[0], -Infinity], [filter[1], Infinity]];\n    }\n\n    f.isFiltered = function (value) {\n        var x, y;\n\n        if (value instanceof Array) {\n            x = value[0];\n            y = value[1];\n        } else {\n            x = value;\n            y = fromBottomLeft[0][1];\n        }\n\n        return x >= fromBottomLeft[0][0] && x < fromBottomLeft[1][0] &&\n               y >= fromBottomLeft[0][1] && y < fromBottomLeft[1][1];\n    };\n    f.filterType = 'RangedTwoDimensionalFilter';\n\n    return f;\n};\n\n/**\n * `dc.baseMixin` is an abstract functional object representing a basic `dc` chart object\n * for all chart and widget implementations. Methods from the {@link #dc.baseMixin dc.baseMixin} are inherited\n * and available on all chart implementations in the `dc` library.\n * @name baseMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.baseMixin}\n */\ndc.baseMixin = function (_chart) {\n    _chart.__dcFlag__ = dc.utils.uniqueId();\n\n    var _dimension;\n    var _group;\n\n    var _anchor;\n    var _root;\n    var _svg;\n    var _isChild;\n\n    var _minWidth = 200;\n    var _defaultWidthCalc = function (element) {\n        var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;\n        return (width && width > _minWidth) ? width : _minWidth;\n    };\n    var _widthCalc = _defaultWidthCalc;\n\n    var _minHeight = 200;\n    var _defaultHeightCalc = function (element) {\n        var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;\n        return (height && height > _minHeight) ? height : _minHeight;\n    };\n    var _heightCalc = _defaultHeightCalc;\n    var _width, _height;\n    var _useViewBoxResizing = false;\n\n    var _keyAccessor = dc.pluck('key');\n    var _valueAccessor = dc.pluck('value');\n    var _label = dc.pluck('key');\n\n    var _ordering = dc.pluck('key');\n    var _orderSort;\n\n    var _renderLabel = false;\n\n    var _title = function (d) {\n        return _chart.keyAccessor()(d) + ': ' + _chart.valueAccessor()(d);\n    };\n    var _renderTitle = true;\n    var _controlsUseVisibility = false;\n\n    var _transitionDuration = 750;\n\n    var _transitionDelay = 0;\n\n    var _filterPrinter = dc.printers.filters;\n\n    var _mandatoryAttributes = ['dimension', 'group'];\n\n    var _chartGroup = dc.constants.DEFAULT_CHART_GROUP;\n\n    var _listeners = d3.dispatch(\n        'preRender',\n        'postRender',\n        'preRedraw',\n        'postRedraw',\n        'filtered',\n        'zoomed',\n        'renderlet',\n        'pretransition');\n\n    var _legend;\n    var _commitHandler;\n\n    var _filters = [];\n    var _filterHandler = function (dimension, filters) {\n        if (filters.length === 0) {\n            dimension.filter(null);\n        } else if (filters.length === 1 && !filters[0].isFiltered) {\n            // single value and not a function-based filter\n            dimension.filterExact(filters[0]);\n        } else if (filters.length === 1 && filters[0].filterType === 'RangedFilter') {\n            // single range-based filter\n            dimension.filterRange(filters[0]);\n        } else {\n            dimension.filterFunction(function (d) {\n                for (var i = 0; i < filters.length; i++) {\n                    var filter = filters[i];\n                    if (filter.isFiltered && filter.isFiltered(d)) {\n                        return true;\n                    } else if (filter <= d && filter >= d) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n        }\n        return filters;\n    };\n\n    var _data = function (group) {\n        return group.all();\n    };\n\n    /**\n     * Set or get the height attribute of a chart. The height is applied to the SVGElement generated by\n     * the chart when rendered (or re-rendered). If a value is given, then it will be used to calculate\n     * the new height and the chart returned for method chaining.  The value can either be a numeric, a\n     * function, or falsy. If no value is specified then the value of the current height attribute will\n     * be returned.\n     *\n     * By default, without an explicit height being given, the chart will select the width of its\n     * anchor element. If that isn't possible it defaults to 200 (provided by the\n     * {@link dc.baseMixin#minHeight minHeight} property). Setting the value falsy will return\n     * the chart to the default behavior.\n     * @method height\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#minHeight minHeight}\n     * @example\n     * // Default height\n     * chart.height(function (element) {\n     *     var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;\n     *     return (height && height > chart.minHeight()) ? height : chart.minHeight();\n     * });\n     *\n     * chart.height(250); // Set the chart's height to 250px;\n     * chart.height(function(anchor) { return doSomethingWith(anchor); }); // set the chart's height with a function\n     * chart.height(null); // reset the height to the default auto calculation\n     * @param {Number|Function} [height]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.height = function (height) {\n        if (!arguments.length) {\n            if (!dc.utils.isNumber(_height)) {\n                // only calculate once\n                _height = _heightCalc(_root.node());\n            }\n            return _height;\n        }\n        _heightCalc = d3.functor(height || _defaultHeightCalc);\n        _height = undefined;\n        return _chart;\n    };\n\n    /**\n     * Set or get the width attribute of a chart.\n     * @method width\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#height height}\n     * @see {@link dc.baseMixin#minWidth minWidth}\n     * @example\n     * // Default width\n     * chart.width(function (element) {\n     *     var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;\n     *     return (width && width > chart.minWidth()) ? width : chart.minWidth();\n     * });\n     * @param {Number|Function} [width]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.width = function (width) {\n        if (!arguments.length) {\n            if (!dc.utils.isNumber(_width)) {\n                // only calculate once\n                _width = _widthCalc(_root.node());\n            }\n            return _width;\n        }\n        _widthCalc = d3.functor(width || _defaultWidthCalc);\n        _width = undefined;\n        return _chart;\n    };\n\n    /**\n     * Set or get the minimum width attribute of a chart. This only has effect when used with the default\n     * {@link dc.baseMixin#width width} function.\n     * @method minWidth\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#width width}\n     * @param {Number} [minWidth=200]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.minWidth = function (minWidth) {\n        if (!arguments.length) {\n            return _minWidth;\n        }\n        _minWidth = minWidth;\n        return _chart;\n    };\n\n    /**\n     * Set or get the minimum height attribute of a chart. This only has effect when used with the default\n     * {@link dc.baseMixin#height height} function.\n     * @method minHeight\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#height height}\n     * @param {Number} [minHeight=200]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.minHeight = function (minHeight) {\n        if (!arguments.length) {\n            return _minHeight;\n        }\n        _minHeight = minHeight;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off using the SVG\n     * {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox `viewBox` attribute}.\n     * When enabled, `viewBox` will be set on the svg root element instead of `width` and `height`.\n     * Requires that the chart aspect ratio be defined using chart.width(w) and chart.height(h).\n     *\n     * This will maintain the aspect ratio while enabling the chart to resize responsively to the\n     * space given to the chart using CSS. For example, the chart can use `width: 100%; height:\n     * 100%` or absolute positioning to resize to its parent div.\n     *\n     * Since the text will be sized as if the chart is drawn according to the width and height, and\n     * will be resized if the chart is any other size, you need to set the chart width and height so\n     * that the text looks good. In practice, 600x400 seems to work pretty well for most charts.\n     *\n     * You can see examples of this resizing strategy in the [Chart Resizing\n     * Examples](http://dc-js.github.io/dc.js/resizing/); just add `?resize=viewbox` to any of the\n     * one-chart examples to enable `useViewBoxResizing`.\n     * @method useViewBoxResizing\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [useViewBoxResizing=false]\n     * @returns {Boolean|dc.baseMixin}\n     */\n    _chart.useViewBoxResizing = function (useViewBoxResizing) {\n        if (!arguments.length) {\n            return _useViewBoxResizing;\n        }\n        _useViewBoxResizing = useViewBoxResizing;\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Set or get the dimension attribute of a chart. In `dc`, a dimension can be any valid\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension crossfilter dimension}\n     *\n     * If a value is given, then it will be used as the new dimension. If no value is specified then\n     * the current dimension will be returned.\n     * @method dimension\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension crossfilter.dimension}\n     * @example\n     * var index = crossfilter([]);\n     * var dimension = index.dimension(dc.pluck('key'));\n     * chart.dimension(dimension);\n     * @param {crossfilter.dimension} [dimension]\n     * @returns {crossfilter.dimension|dc.baseMixin}\n     */\n    _chart.dimension = function (dimension) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = dimension;\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\n     * Set the data callback or retrieve the chart's data set. The data callback is passed the chart's\n     * group and by default will return\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all}.\n     * This behavior may be modified to, for instance, return only the top 5 groups.\n     * @method data\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // Default data function\n     * chart.data(function (group) { return group.all(); });\n     *\n     * chart.data(function (group) { return group.top(5); });\n     * @param {Function} [callback]\n     * @returns {*|dc.baseMixin}\n     */\n    _chart.data = function (callback) {\n        if (!arguments.length) {\n            return _data.call(_chart, _group);\n        }\n        _data = d3.functor(callback);\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Set or get the group attribute of a chart. In `dc` a group is a\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter group}.\n     * Usually the group should be created from the particular dimension associated with the same chart. If a value is\n     * given, then it will be used as the new group.\n     *\n     * If no value specified then the current group will be returned.\n     * If `name` is specified then it will be used to generate legend label.\n     * @method group\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}\n     * @example\n     * var index = crossfilter([]);\n     * var dimension = index.dimension(dc.pluck('key'));\n     * chart.dimension(dimension);\n     * chart.group(dimension.group(crossfilter.reduceSum()));\n     * @param {crossfilter.group} [group]\n     * @param {String} [name]\n     * @returns {crossfilter.group|dc.baseMixin}\n     */\n    _chart.group = function (group, name) {\n        if (!arguments.length) {\n            return _group;\n        }\n        _group = group;\n        _chart._groupName = name;\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\n     * Get or set an accessor to order ordinal dimensions.  The chart uses\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}\n     * to sort elements; this accessor returns the value to order on.\n     * @method ordering\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}\n     * @example\n     * // Default ordering accessor\n     * _chart.ordering(dc.pluck('key'));\n     * @param {Function} [orderFunction]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.ordering = function (orderFunction) {\n        if (!arguments.length) {\n            return _ordering;\n        }\n        _ordering = orderFunction;\n        _orderSort = crossfilter.quicksort.by(_ordering);\n        _chart.expireCache();\n        return _chart;\n    };\n\n    _chart._computeOrderedGroups = function (data) {\n        var dataCopy = data.slice(0);\n\n        if (dataCopy.length <= 1) {\n            return dataCopy;\n        }\n\n        if (!_orderSort) {\n            _orderSort = crossfilter.quicksort.by(_ordering);\n        }\n\n        return _orderSort(dataCopy, 0, dataCopy.length);\n    };\n\n    /**\n     * Clear all filters associated with this chart. The same effect can be achieved by calling\n     * {@link dc.baseMixin#filter chart.filter(null)}.\n     * @method filterAll\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.filterAll = function () {\n        return _chart.filter(null);\n    };\n\n    /**\n     * Execute d3 single selection in the chart's scope using the given selector and return the d3\n     * selection.\n     *\n     * This function is **not chainable** since it does not return a chart instance; however the d3\n     * selection result can be chained to d3 function calls.\n     * @method select\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#d3_select d3.select}\n     * @example\n     * // Has the same effect as d3.select('#chart-id').select(selector)\n     * chart.select(selector)\n     * @returns {d3.selection}\n     */\n    _chart.select = function (s) {\n        return _root.select(s);\n    };\n\n    /**\n     * Execute in scope d3 selectAll using the given selector and return d3 selection result.\n     *\n     * This function is **not chainable** since it does not return a chart instance; however the d3\n     * selection result can be chained to d3 function calls.\n     * @method selectAll\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#d3_selectAll d3.selectAll}\n     * @example\n     * // Has the same effect as d3.select('#chart-id').selectAll(selector)\n     * chart.selectAll(selector)\n     * @returns {d3.selection}\n     */\n    _chart.selectAll = function (s) {\n        return _root ? _root.selectAll(s) : null;\n    };\n\n    /**\n     * Set the root SVGElement to either be an existing chart's root; or any valid [d3 single\n     * selector](https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements) specifying a dom\n     * block element such as a div; or a dom element or d3 selection. Optionally registers the chart\n     * within the chartGroup. This class is called internally on chart initialization, but be called\n     * again to relocate the chart. However, it will orphan any previously created SVGElements.\n     * @method anchor\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {anchorChart|anchorSelector|anchorNode} [parent]\n     * @param {String} [chartGroup]\n     * @returns {String|node|d3.selection|dc.baseMixin}\n     */\n    _chart.anchor = function (parent, chartGroup) {\n        if (!arguments.length) {\n            return _anchor;\n        }\n        if (dc.instanceOfChart(parent)) {\n            _anchor = parent.anchor();\n            _root = parent.root();\n            _isChild = true;\n        } else if (parent) {\n            if (parent.select && parent.classed) { // detect d3 selection\n                _anchor = parent.node();\n            } else {\n                _anchor = parent;\n            }\n            _root = d3.select(_anchor);\n            _root.classed(dc.constants.CHART_CLASS, true);\n            dc.registerChart(_chart, chartGroup);\n            _isChild = false;\n        } else {\n            throw new dc.errors.BadArgumentException('parent must be defined');\n        }\n        _chartGroup = chartGroup;\n        return _chart;\n    };\n\n    /**\n     * Returns the DOM id for the chart's anchored location.\n     * @method anchorName\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {String}\n     */\n    _chart.anchorName = function () {\n        var a = _chart.anchor();\n        if (a && a.id) {\n            return a.id;\n        }\n        if (a && a.replace) {\n            return a.replace('#', '');\n        }\n        return 'dc-chart' + _chart.chartID();\n    };\n\n    /**\n     * Returns the root element where a chart resides. Usually it will be the parent div element where\n     * the SVGElement was created. You can also pass in a new root element however this is usually handled by\n     * dc internally. Resetting the root element on a chart outside of dc internals may have\n     * unexpected consequences.\n     * @method root\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement HTMLElement}\n     * @param {HTMLElement} [rootElement]\n     * @returns {HTMLElement|dc.baseMixin}\n     */\n    _chart.root = function (rootElement) {\n        if (!arguments.length) {\n            return _root;\n        }\n        _root = rootElement;\n        return _chart;\n    };\n\n    /**\n     * Returns the top SVGElement for this specific chart. You can also pass in a new SVGElement,\n     * however this is usually handled by dc internally. Resetting the SVGElement on a chart outside\n     * of dc internals may have unexpected consequences.\n     * @method svg\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}\n     * @param {SVGElement|d3.selection} [svgElement]\n     * @returns {SVGElement|d3.selection|dc.baseMixin}\n     */\n    _chart.svg = function (svgElement) {\n        if (!arguments.length) {\n            return _svg;\n        }\n        _svg = svgElement;\n        return _chart;\n    };\n\n    /**\n     * Remove the chart's SVGElements from the dom and recreate the container SVGElement.\n     * @method resetSvg\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}\n     * @returns {SVGElement}\n     */\n    _chart.resetSvg = function () {\n        _chart.select('svg').remove();\n        return generateSvg();\n    };\n\n    function sizeSvg () {\n        if (_svg) {\n            if (!_useViewBoxResizing) {\n                _svg\n                    .attr('width', _chart.width())\n                    .attr('height', _chart.height());\n            } else if (!_svg.attr('viewBox')) {\n                _svg\n                    .attr('viewBox', '0 0 ' + _chart.width() + ' ' + _chart.height());\n            }\n        }\n    }\n\n    function generateSvg () {\n        _svg = _chart.root().append('svg');\n        sizeSvg();\n        return _svg;\n    }\n\n    /**\n     * Set or get the filter printer function. The filter printer function is used to generate human\n     * friendly text for filter value(s) associated with the chart instance. The text will get shown\n     * in the `.filter element; see {@link dc.baseMixin#turnOnControls turnOnControls}.\n     *\n     * By default dc charts use a default filter printer {@link dc.printers.filters dc.printers.filters}\n     * that provides simple printing support for both single value and ranged filters.\n     * @method filterPrinter\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // for a chart with an ordinal brush, print the filters in upper case\n     * chart.filterPrinter(function(filters) {\n     *   return filters.map(function(f) { return f.toUpperCase(); }).join(', ');\n     * });\n     * // for a chart with a range brush, print the filter as start and extent\n     * chart.filterPrinter(function(filters) {\n     *   return 'start ' + dc.utils.printSingleValue(filters[0][0]) +\n     *     ' extent ' + dc.utils.printSingleValue(filters[0][1] - filters[0][0]);\n     * });\n     * @param {Function} [filterPrinterFunction=dc.printers.filters]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.filterPrinter = function (filterPrinterFunction) {\n        if (!arguments.length) {\n            return _filterPrinter;\n        }\n        _filterPrinter = filterPrinterFunction;\n        return _chart;\n    };\n\n    /**\n     * If set, use the `visibility` attribute instead of the `display` attribute for showing/hiding\n     * chart reset and filter controls, for less disruption to the layout.\n     * @method controlsUseVisibility\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [controlsUseVisibility=false]\n     * @returns {Boolean|dc.baseMixin}\n     **/\n    _chart.controlsUseVisibility = function (useVisibility) {\n        if (!arguments.length) {\n            return _controlsUseVisibility;\n        }\n        _controlsUseVisibility = useVisibility;\n        return _chart;\n    };\n\n    /**\n     * Turn on optional control elements within the root element. dc currently supports the\n     * following html control elements.\n     * * root.selectAll('.reset') - elements are turned on if the chart has an active filter. This type\n     * of control element is usually used to store a reset link to allow user to reset filter on a\n     * certain chart. This element will be turned off automatically if the filter is cleared.\n     * * root.selectAll('.filter') elements are turned on if the chart has an active filter. The text\n     * content of this element is then replaced with the current filter value using the filter printer\n     * function. This type of element will be turned off automatically if the filter is cleared.\n     * @method turnOnControls\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.turnOnControls = function () {\n        if (_root) {\n            var attribute = _chart.controlsUseVisibility() ? 'visibility' : 'display';\n            _chart.selectAll('.reset').style(attribute, null);\n            _chart.selectAll('.filter').text(_filterPrinter(_chart.filters())).style(attribute, null);\n        }\n        return _chart;\n    };\n\n    /**\n     * Turn off optional control elements within the root element.\n     * @method turnOffControls\n     * @memberof dc.baseMixin\n     * @see {@link dc.baseMixin#turnOnControls turnOnControls}\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.turnOffControls = function () {\n        if (_root) {\n            var attribute = _chart.controlsUseVisibility() ? 'visibility' : 'display';\n            var value = _chart.controlsUseVisibility() ? 'hidden' : 'none';\n            _chart.selectAll('.reset').style(attribute, value);\n            _chart.selectAll('.filter').style(attribute, value).text(_chart.filter());\n        }\n        return _chart;\n    };\n\n    /**\n     * Set or get the animation transition duration (in milliseconds) for this chart instance.\n     * @method transitionDuration\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Number} [duration=750]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.transitionDuration = function (duration) {\n        if (!arguments.length) {\n            return _transitionDuration;\n        }\n        _transitionDuration = duration;\n        return _chart;\n    };\n\n    /**\n     * Set or get the animation transition delay (in milliseconds) for this chart instance.\n     * @method transitionDelay\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Number} [delay=0]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.transitionDelay = function (delay) {\n        if (!arguments.length) {\n            return _transitionDelay;\n        }\n        _transitionDelay = delay;\n        return _chart;\n    };\n\n    _chart._mandatoryAttributes = function (_) {\n        if (!arguments.length) {\n            return _mandatoryAttributes;\n        }\n        _mandatoryAttributes = _;\n        return _chart;\n    };\n\n    function checkForMandatoryAttributes (a) {\n        if (!_chart[a] || !_chart[a]()) {\n            throw new dc.errors.InvalidStateException('Mandatory attribute chart.' + a +\n                ' is missing on chart[#' + _chart.anchorName() + ']');\n        }\n    }\n\n    /**\n     * Invoking this method will force the chart to re-render everything from scratch. Generally it\n     * should only be used to render the chart for the first time on the page or if you want to make\n     * sure everything is redrawn from scratch instead of relying on the default incremental redrawing\n     * behaviour.\n     * @method render\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.render = function () {\n        _height = _width = undefined; // force recalculate\n        _listeners.preRender(_chart);\n\n        if (_mandatoryAttributes) {\n            _mandatoryAttributes.forEach(checkForMandatoryAttributes);\n        }\n\n        var result = _chart._doRender();\n\n        if (_legend) {\n            _legend.render();\n        }\n\n        _chart._activateRenderlets('postRender');\n\n        return result;\n    };\n\n    _chart._activateRenderlets = function (event) {\n        _listeners.pretransition(_chart);\n        if (_chart.transitionDuration() > 0 && _svg) {\n            _svg.transition().duration(_chart.transitionDuration()).delay(_chart.transitionDelay())\n                .each('end', function () {\n                    _listeners.renderlet(_chart);\n                    if (event) {\n                        _listeners[event](_chart);\n                    }\n                });\n        } else {\n            _listeners.renderlet(_chart);\n            if (event) {\n                _listeners[event](_chart);\n            }\n        }\n    };\n\n    /**\n     * Calling redraw will cause the chart to re-render data changes incrementally. If there is no\n     * change in the underlying data dimension then calling this method will have no effect on the\n     * chart. Most chart interaction in dc will automatically trigger this method through internal\n     * events (in particular {@link dc.redrawAll dc.redrawAll}); therefore, you only need to\n     * manually invoke this function if data is manipulated outside of dc's control (for example if\n     * data is loaded in the background using\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}).\n     * @method redraw\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.redraw = function () {\n        sizeSvg();\n        _listeners.preRedraw(_chart);\n\n        var result = _chart._doRedraw();\n\n        if (_legend) {\n            _legend.render();\n        }\n\n        _chart._activateRenderlets('postRedraw');\n\n        return result;\n    };\n\n    /**\n     * Gets/sets the commit handler. If the chart has a commit handler, the handler will be called when\n     * the chart's filters have changed, in order to send the filter data asynchronously to a server.\n     *\n     * Unlike other functions in dc.js, the commit handler is asynchronous. It takes two arguments:\n     * a flag indicating whether this is a render (true) or a redraw (false), and a callback to be\n     * triggered once the commit is filtered. The callback has the standard node.js continuation signature\n     * with error first and result second.\n     * @method commitHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.commitHandler = function (commitHandler) {\n        if (!arguments.length) {\n            return _commitHandler;\n        }\n        _commitHandler = commitHandler;\n        return _chart;\n    };\n\n    /**\n     * Redraws all charts in the same group as this chart, typically in reaction to a filter\n     * change. If the chart has a {@link dc.baseMixin.commitFilter commitHandler}, it will\n     * be executed and waited for.\n     * @method redrawGroup\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.redrawGroup = function () {\n        if (_commitHandler) {\n            _commitHandler(false, function (error, result) {\n                if (error) {\n                    console.log(error);\n                } else {\n                    dc.redrawAll(_chart.chartGroup());\n                }\n            });\n        } else {\n            dc.redrawAll(_chart.chartGroup());\n        }\n        return _chart;\n    };\n\n    /**\n     * Renders all charts in the same group as this chart. If the chart has a\n     * {@link dc.baseMixin.commitFilter commitHandler}, it will be executed and waited for\n     * @method renderGroup\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.renderGroup = function () {\n        if (_commitHandler) {\n            _commitHandler(false, function (error, result) {\n                if (error) {\n                    console.log(error);\n                } else {\n                    dc.renderAll(_chart.chartGroup());\n                }\n            });\n        } else {\n            dc.renderAll(_chart.chartGroup());\n        }\n        return _chart;\n    };\n\n    _chart._invokeFilteredListener = function (f) {\n        if (f !== undefined) {\n            _listeners.filtered(_chart, f);\n        }\n    };\n\n    _chart._invokeZoomedListener = function () {\n        _listeners.zoomed(_chart);\n    };\n\n    var _hasFilterHandler = function (filters, filter) {\n        if (filter === null || typeof(filter) === 'undefined') {\n            return filters.length > 0;\n        }\n        return filters.some(function (f) {\n            return filter <= f && filter >= f;\n        });\n    };\n\n    /**\n     * Set or get the has-filter handler. The has-filter handler is a function that checks to see if\n     * the chart's current filters (first argument) include a specific filter (second argument).  Using a custom has-filter handler allows\n     * you to change the way filters are checked for and replaced.\n     * @method hasFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default has-filter handler\n     * chart.hasFilterHandler(function (filters, filter) {\n     *     if (filter === null || typeof(filter) === 'undefined') {\n     *         return filters.length > 0;\n     *     }\n     *     return filters.some(function (f) {\n     *         return filter <= f && filter >= f;\n     *     });\n     * });\n     *\n     * // custom filter handler (no-op)\n     * chart.hasFilterHandler(function(filters, filter) {\n     *     return false;\n     * });\n     * @param {Function} [hasFilterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.hasFilterHandler = function (hasFilterHandler) {\n        if (!arguments.length) {\n            return _hasFilterHandler;\n        }\n        _hasFilterHandler = hasFilterHandler;\n        return _chart;\n    };\n\n    /**\n     * Check whether any active filter or a specific filter is associated with particular chart instance.\n     * This function is **not chainable**.\n     * @method hasFilter\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#hasFilterHandler hasFilterHandler}\n     * @param {*} [filter]\n     * @returns {Boolean}\n     */\n    _chart.hasFilter = function (filter) {\n        return _hasFilterHandler(_filters, filter);\n    };\n\n    var _removeFilterHandler = function (filters, filter) {\n        for (var i = 0; i < filters.length; i++) {\n            if (filters[i] <= filter && filters[i] >= filter) {\n                filters.splice(i, 1);\n                break;\n            }\n        }\n        return filters;\n    };\n\n    /**\n     * Set or get the remove filter handler. The remove filter handler is a function that removes a\n     * filter from the chart's current filters. Using a custom remove filter handler allows you to\n     * change how filters are removed or perform additional work when removing a filter, e.g. when\n     * using a filter server other than crossfilter.\n     *\n     * The handler should return a new or modified array as the result.\n     * @method removeFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default remove filter handler\n     * chart.removeFilterHandler(function (filters, filter) {\n     *     for (var i = 0; i < filters.length; i++) {\n     *         if (filters[i] <= filter && filters[i] >= filter) {\n     *             filters.splice(i, 1);\n     *             break;\n     *         }\n     *     }\n     *     return filters;\n     * });\n     *\n     * // custom filter handler (no-op)\n     * chart.removeFilterHandler(function(filters, filter) {\n     *     return filters;\n     * });\n     * @param {Function} [removeFilterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.removeFilterHandler = function (removeFilterHandler) {\n        if (!arguments.length) {\n            return _removeFilterHandler;\n        }\n        _removeFilterHandler = removeFilterHandler;\n        return _chart;\n    };\n\n    var _addFilterHandler = function (filters, filter) {\n        filters.push(filter);\n        return filters;\n    };\n\n    /**\n     * Set or get the add filter handler. The add filter handler is a function that adds a filter to\n     * the chart's filter list. Using a custom add filter handler allows you to change the way filters\n     * are added or perform additional work when adding a filter, e.g. when using a filter server other\n     * than crossfilter.\n     *\n     * The handler should return a new or modified array as the result.\n     * @method addFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default add filter handler\n     * chart.addFilterHandler(function (filters, filter) {\n     *     filters.push(filter);\n     *     return filters;\n     * });\n     *\n     * // custom filter handler (no-op)\n     * chart.addFilterHandler(function(filters, filter) {\n     *     return filters;\n     * });\n     * @param {Function} [addFilterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.addFilterHandler = function (addFilterHandler) {\n        if (!arguments.length) {\n            return _addFilterHandler;\n        }\n        _addFilterHandler = addFilterHandler;\n        return _chart;\n    };\n\n    var _resetFilterHandler = function (filters) {\n        return [];\n    };\n\n    /**\n     * Set or get the reset filter handler. The reset filter handler is a function that resets the\n     * chart's filter list by returning a new list. Using a custom reset filter handler allows you to\n     * change the way filters are reset, or perform additional work when resetting the filters,\n     * e.g. when using a filter server other than crossfilter.\n     *\n     * The handler should return a new or modified array as the result.\n     * @method resetFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default remove filter handler\n     * function (filters) {\n     *     return [];\n     * }\n     *\n     * // custom filter handler (no-op)\n     * chart.resetFilterHandler(function(filters) {\n     *     return filters;\n     * });\n     * @param {Function} [resetFilterHandler]\n     * @returns {dc.baseMixin}\n     */\n    _chart.resetFilterHandler = function (resetFilterHandler) {\n        if (!arguments.length) {\n            return _resetFilterHandler;\n        }\n        _resetFilterHandler = resetFilterHandler;\n        return _chart;\n    };\n\n    function applyFilters (filters) {\n        if (_chart.dimension() && _chart.dimension().filter) {\n            var fs = _filterHandler(_chart.dimension(), filters);\n            if (fs) {\n                filters = fs;\n            }\n        }\n        return filters;\n    }\n\n    /**\n     * Replace the chart filter. This is equivalent to calling `chart.filter(null).filter(filter)`\n     * but more efficient because the filter is only applied once.\n     *\n     * @method replaceFilter\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {*} [filter]\n     * @returns {dc.baseMixin}\n     **/\n    _chart.replaceFilter = function (filter) {\n        _filters = _resetFilterHandler(_filters);\n        _chart.filter(filter);\n        return _chart;\n    };\n\n    /**\n     * Filter the chart by the given parameter, or return the current filter if no input parameter\n     * is given.\n     *\n     * The filter parameter can take one of these forms:\n     * * A single value: the value will be toggled (added if it is not present in the current\n     * filters, removed if it is present)\n     * * An array containing a single array of values (`[[value,value,value]]`): each value is\n     * toggled\n     * * When appropriate for the chart, a {@link dc.filters dc filter object} such as\n     *   * {@link dc.filters.RangedFilter `dc.filters.RangedFilter`} for the\n     * {@link dc.coordinateGridMixin dc.coordinateGridMixin} charts\n     *   * {@link dc.filters.TwoDimensionalFilter `dc.filters.TwoDimensionalFilter`} for the\n     * {@link dc.heatMap heat map}\n     *   * {@link dc.filters.RangedTwoDimensionalFilter `dc.filters.RangedTwoDimensionalFilter`}\n     * for the {@link dc.scatterPlot scatter plot}\n     * * `null`: the filter will be reset using the\n     * {@link dc.baseMixin#resetFilterHandler resetFilterHandler}\n     *\n     * Note that this is always a toggle (even when it doesn't make sense for the filter type). If\n     * you wish to replace the current filter, either call `chart.filter(null)` first - or it's more\n     * efficient to call {@link dc.baseMixin#replaceFilter `chart.replaceFilter(filter)`} instead.\n     *\n     * Each toggle is executed by checking if the value is already present using the\n     * {@link dc.baseMixin#hasFilterHandler hasFilterHandler}; if it is not present, it is added\n     * using the {@link dc.baseMixin#addFilterHandler addFilterHandler}; if it is already present,\n     * it is removed using the {@link dc.baseMixin#removeFilterHandler removeFilterHandler}.\n     *\n     * Once the filters array has been updated, the filters are applied to the\n     * crossfilter dimension, using the {@link dc.baseMixin#filterHandler filterHandler}.\n     *\n     * Once you have set the filters, call {@link dc.baseMixin#redrawGroup `chart.redrawGroup()`}\n     * (or {@link dc.redrawAll `dc.redrawAll()`}) to redraw the chart's group.\n     * @method filter\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#addFilterHandler addFilterHandler}\n     * @see {@link dc.baseMixin#removeFilterHandler removeFilterHandler}\n     * @see {@link dc.baseMixin#resetFilterHandler resetFilterHandler}\n     * @see {@link dc.baseMixin#filterHandler filterHandler}\n     * @example\n     * // filter by a single string\n     * chart.filter('Sunday');\n     * // filter by a single age\n     * chart.filter(18);\n     * // filter by a set of states\n     * chart.filter([['MA', 'TX', 'ND', 'WA']]);\n     * // filter by range -- note the use of dc.filters.RangedFilter, which is different\n     * // from the syntax for filtering a crossfilter dimension directly, dimension.filter([15,20])\n     * chart.filter(dc.filters.RangedFilter(15,20));\n     * @param {*} [filter]\n     * @returns {dc.baseMixin}\n     */\n    _chart.filter = function (filter) {\n        if (!arguments.length) {\n            return _filters.length > 0 ? _filters[0] : null;\n        }\n        var filters = _filters;\n        if (filter instanceof Array && filter[0] instanceof Array && !filter.isFiltered) {\n            // toggle each filter\n            filter[0].forEach(function (f) {\n                if (_hasFilterHandler(filters, f)) {\n                    filters = _removeFilterHandler(filters, f);\n                } else {\n                    filters = _addFilterHandler(filters, f);\n                }\n            });\n        } else if (filter === null) {\n            filters = _resetFilterHandler(filters);\n        } else {\n            if (_hasFilterHandler(filters, filter)) {\n                filters = _removeFilterHandler(filters, filter);\n            } else {\n                filters = _addFilterHandler(filters, filter);\n            }\n        }\n        _filters = applyFilters(filters);\n        _chart._invokeFilteredListener(filter);\n\n        if (_root !== null && _chart.hasFilter()) {\n            _chart.turnOnControls();\n        } else {\n            _chart.turnOffControls();\n        }\n\n        return _chart;\n    };\n\n    /**\n     * Returns all current filters. This method does not perform defensive cloning of the internal\n     * filter array before returning, therefore any modification of the returned array will effect the\n     * chart's internal filter storage.\n     * @method filters\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {Array<*>}\n     */\n    _chart.filters = function () {\n        return _filters;\n    };\n\n    _chart.highlightSelected = function (e) {\n        d3.select(e).classed(dc.constants.SELECTED_CLASS, true);\n        d3.select(e).classed(dc.constants.DESELECTED_CLASS, false);\n    };\n\n    _chart.fadeDeselected = function (e) {\n        d3.select(e).classed(dc.constants.SELECTED_CLASS, false);\n        d3.select(e).classed(dc.constants.DESELECTED_CLASS, true);\n    };\n\n    _chart.resetHighlight = function (e) {\n        d3.select(e).classed(dc.constants.SELECTED_CLASS, false);\n        d3.select(e).classed(dc.constants.DESELECTED_CLASS, false);\n    };\n\n    /**\n     * This function is passed to d3 as the onClick handler for each chart. The default behavior is to\n     * filter on the clicked datum (passed to the callback) and redraw the chart group.\n     * @method onClick\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {*} datum\n     */\n    _chart.onClick = function (datum) {\n        var filter = _chart.keyAccessor()(datum);\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    /**\n     * Set or get the filter handler. The filter handler is a function that performs the filter action\n     * on a specific dimension. Using a custom filter handler allows you to perform additional logic\n     * before or after filtering.\n     * @method filterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension_filter crossfilter.dimension.filter}\n     * @example\n     * // the default filter handler handles all possible cases for the charts in dc.js\n     * // you can replace it with something more specialized for your own chart\n     * chart.filterHandler(function (dimension, filters) {\n     *     if (filters.length === 0) {\n     *         // the empty case (no filtering)\n     *         dimension.filter(null);\n     *     } else if (filters.length === 1 && !filters[0].isFiltered) {\n     *         // single value and not a function-based filter\n     *         dimension.filterExact(filters[0]);\n     *     } else if (filters.length === 1 && filters[0].filterType === 'RangedFilter') {\n     *         // single range-based filter\n     *         dimension.filterRange(filters[0]);\n     *     } else {\n     *         // an array of values, or an array of filter objects\n     *         dimension.filterFunction(function (d) {\n     *             for (var i = 0; i < filters.length; i++) {\n     *                 var filter = filters[i];\n     *                 if (filter.isFiltered && filter.isFiltered(d)) {\n     *                     return true;\n     *                 } else if (filter <= d && filter >= d) {\n     *                     return true;\n     *                 }\n     *             }\n     *             return false;\n     *         });\n     *     }\n     *     return filters;\n     * });\n     *\n     * // custom filter handler\n     * chart.filterHandler(function(dimension, filter){\n     *     var newFilter = filter + 10;\n     *     dimension.filter(newFilter);\n     *     return newFilter; // set the actual filter value to the new value\n     * });\n     * @param {Function} [filterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.filterHandler = function (filterHandler) {\n        if (!arguments.length) {\n            return _filterHandler;\n        }\n        _filterHandler = filterHandler;\n        return _chart;\n    };\n\n    // abstract function stub\n    _chart._doRender = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    _chart.legendables = function () {\n        // do nothing in base, should be overridden by sub-function\n        return [];\n    };\n\n    _chart.legendHighlight = function () {\n        // do nothing in base, should be overridden by sub-function\n    };\n\n    _chart.legendReset = function () {\n        // do nothing in base, should be overridden by sub-function\n    };\n\n    _chart.legendToggle = function () {\n        // do nothing in base, should be overriden by sub-function\n    };\n\n    _chart.isLegendableHidden = function () {\n        // do nothing in base, should be overridden by sub-function\n        return false;\n    };\n\n    /**\n     * Set or get the key accessor function. The key accessor function is used to retrieve the key\n     * value from the crossfilter group. Key values are used differently in different charts, for\n     * example keys correspond to slices in a pie chart and x axis positions in a grid coordinate chart.\n     * @method keyAccessor\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default key accessor\n     * chart.keyAccessor(function(d) { return d.key; });\n     * // custom key accessor for a multi-value crossfilter reduction\n     * chart.keyAccessor(function(p) { return p.value.absGain; });\n     * @param {Function} [keyAccessor]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.keyAccessor = function (keyAccessor) {\n        if (!arguments.length) {\n            return _keyAccessor;\n        }\n        _keyAccessor = keyAccessor;\n        return _chart;\n    };\n\n    /**\n     * Set or get the value accessor function. The value accessor function is used to retrieve the\n     * value from the crossfilter group. Group values are used differently in different charts, for\n     * example values correspond to slice sizes in a pie chart and y axis positions in a grid\n     * coordinate chart.\n     * @method valueAccessor\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default value accessor\n     * chart.valueAccessor(function(d) { return d.value; });\n     * // custom value accessor for a multi-value crossfilter reduction\n     * chart.valueAccessor(function(p) { return p.value.percentageGain; });\n     * @param {Function} [valueAccessor]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.valueAccessor = function (valueAccessor) {\n        if (!arguments.length) {\n            return _valueAccessor;\n        }\n        _valueAccessor = valueAccessor;\n        return _chart;\n    };\n\n    /**\n     * Set or get the label function. The chart class will use this function to render labels for each\n     * child element in the chart, e.g. slices in a pie chart or bubbles in a bubble chart. Not every\n     * chart supports the label function, for example line chart does not use this function\n     * at all. By default, enables labels; pass false for the second parameter if this is not desired.\n     * @method label\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default label function just return the key\n     * chart.label(function(d) { return d.key; });\n     * // label function has access to the standard d3 data binding and can get quite complicated\n     * chart.label(function(d) { return d.data.key + '(' + Math.floor(d.data.value / all.value() * 100) + '%)'; });\n     * @param {Function} [labelFunction]\n     * @param {Boolean} [enableLabels=true]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.label = function (labelFunction, enableLabels) {\n        if (!arguments.length) {\n            return _label;\n        }\n        _label = labelFunction;\n        if ((enableLabels === undefined) || enableLabels) {\n            _renderLabel = true;\n        }\n        return _chart;\n    };\n\n    /**\n     * Turn on/off label rendering\n     * @method renderLabel\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [renderLabel=false]\n     * @returns {Boolean|dc.baseMixin}\n     */\n    _chart.renderLabel = function (renderLabel) {\n        if (!arguments.length) {\n            return _renderLabel;\n        }\n        _renderLabel = renderLabel;\n        return _chart;\n    };\n\n    /**\n     * Set or get the title function. The chart class will use this function to render the SVGElement title\n     * (usually interpreted by browser as tooltips) for each child element in the chart, e.g. a slice\n     * in a pie chart or a bubble in a bubble chart. Almost every chart supports the title function;\n     * however in grid coordinate charts you need to turn off the brush in order to see titles, because\n     * otherwise the brush layer will block tooltip triggering.\n     * @method title\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default title function shows \"key: value\"\n     * chart.title(function(d) { return d.key + ': ' + d.value; });\n     * // title function has access to the standard d3 data binding and can get quite complicated\n     * chart.title(function(p) {\n     *    return p.key.getFullYear()\n     *        + '\\n'\n     *        + 'Index Gain: ' + numberFormat(p.value.absGain) + '\\n'\n     *        + 'Index Gain in Percentage: ' + numberFormat(p.value.percentageGain) + '%\\n'\n     *        + 'Fluctuation / Index Ratio: ' + numberFormat(p.value.fluctuationPercentage) + '%';\n     * });\n     * @param {Function} [titleFunction]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.title = function (titleFunction) {\n        if (!arguments.length) {\n            return _title;\n        }\n        _title = titleFunction;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off title rendering, or return the state of the render title flag if no arguments are\n     * given.\n     * @method renderTitle\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [renderTitle=true]\n     * @returns {Boolean|dc.baseMixin}\n     */\n    _chart.renderTitle = function (renderTitle) {\n        if (!arguments.length) {\n            return _renderTitle;\n        }\n        _renderTitle = renderTitle;\n        return _chart;\n    };\n\n    /**\n     * A renderlet is similar to an event listener on rendering event. Multiple renderlets can be added\n     * to an individual chart.  Each time a chart is rerendered or redrawn the renderlets are invoked\n     * right after the chart finishes its transitions, giving you a way to modify the SVGElements.\n     * Renderlet functions take the chart instance as the only input parameter and you can\n     * use the dc API or use raw d3 to achieve pretty much any effect.\n     *\n     * Use {@link dc.baseMixin#on on} with a 'renderlet' prefix.\n     * Generates a random key for the renderlet, which makes it hard to remove.\n     * @method renderlet\n     * @memberof dc.baseMixin\n     * @instance\n     * @deprecated\n     * @example\n     * // do this instead of .renderlet(function(chart) { ... })\n     * chart.on(\"renderlet\", function(chart){\n     *     // mix of dc API and d3 manipulation\n     *     chart.select('g.y').style('display', 'none');\n     *     // its a closure so you can also access other chart variable available in the closure scope\n     *     moveChart.filter(chart.filter());\n     * });\n     * @param {Function} renderletFunction\n     * @returns {dc.baseMixin}\n     */\n    _chart.renderlet = dc.logger.deprecate(function (renderletFunction) {\n        _chart.on('renderlet.' + dc.utils.uniqueId(), renderletFunction);\n        return _chart;\n    }, 'chart.renderlet has been deprecated.  Please use chart.on(\"renderlet.<renderletKey>\", renderletFunction)');\n\n    /**\n     * Get or set the chart group to which this chart belongs. Chart groups are rendered or redrawn\n     * together since it is expected they share the same underlying crossfilter data set.\n     * @method chartGroup\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {String} [chartGroup]\n     * @returns {String|dc.baseMixin}\n     */\n    _chart.chartGroup = function (chartGroup) {\n        if (!arguments.length) {\n            return _chartGroup;\n        }\n        if (!_isChild) {\n            dc.deregisterChart(_chart, _chartGroup);\n        }\n        _chartGroup = chartGroup;\n        if (!_isChild) {\n            dc.registerChart(_chart, _chartGroup);\n        }\n        return _chart;\n    };\n\n    /**\n     * Expire the internal chart cache. dc charts cache some data internally on a per chart basis to\n     * speed up rendering and avoid unnecessary calculation; however it might be useful to clear the\n     * cache if you have changed state which will affect rendering.  For example, if you invoke\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}\n     * function or reset group or dimension after rendering, it is a good idea to\n     * clear the cache to make sure charts are rendered properly.\n     * @method expireCache\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.expireCache = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    /**\n     * Attach a dc.legend widget to this chart. The legend widget will automatically draw legend labels\n     * based on the color setting and names associated with each group.\n     * @method legend\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))\n     * @param {dc.legend} [legend]\n     * @returns {dc.legend|dc.baseMixin}\n     */\n    _chart.legend = function (legend) {\n        if (!arguments.length) {\n            return _legend;\n        }\n        _legend = legend;\n        _legend.parent(_chart);\n        return _chart;\n    };\n\n    /**\n     * Returns the internal numeric ID of the chart.\n     * @method chartID\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {String}\n     */\n    _chart.chartID = function () {\n        return _chart.__dcFlag__;\n    };\n\n    /**\n     * Set chart options using a configuration object. Each key in the object will cause the method of\n     * the same name to be called with the value to set that attribute for the chart.\n     * @method options\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * chart.options({dimension: myDimension, group: myGroup});\n     * @param {{}} opts\n     * @returns {dc.baseMixin}\n     */\n    _chart.options = function (opts) {\n        var applyOptions = [\n            'anchor',\n            'group',\n            'xAxisLabel',\n            'yAxisLabel',\n            'stack',\n            'title',\n            'point',\n            'getColor',\n            'overlayGeoJson'\n        ];\n\n        for (var o in opts) {\n            if (typeof(_chart[o]) === 'function') {\n                if (opts[o] instanceof Array && applyOptions.indexOf(o) !== -1) {\n                    _chart[o].apply(_chart, opts[o]);\n                } else {\n                    _chart[o].call(_chart, opts[o]);\n                }\n            } else {\n                dc.logger.debug('Not a valid option setter name: ' + o);\n            }\n        }\n        return _chart;\n    };\n\n    /**\n     * All dc chart instance supports the following listeners.\n     * Supports the following events:\n     * * `renderlet` - This listener function will be invoked after transitions after redraw and render. Replaces the\n     * deprecated {@link dc.baseMixin#renderlet renderlet} method.\n     * * `pretransition` - Like `.on('renderlet', ...)` but the event is fired before transitions start.\n     * * `preRender` - This listener function will be invoked before chart rendering.\n     * * `postRender` - This listener function will be invoked after chart finish rendering including\n     * all renderlets' logic.\n     * * `preRedraw` - This listener function will be invoked before chart redrawing.\n     * * `postRedraw` - This listener function will be invoked after chart finish redrawing\n     * including all renderlets' logic.\n     * * `filtered` - This listener function will be invoked after a filter is applied, added or removed.\n     * * `zoomed` - This listener function will be invoked after a zoom is triggered.\n     * @method on\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Internals.md#dispatch_on d3.dispatch.on}\n     * @example\n     * .on('renderlet', function(chart, filter){...})\n     * .on('pretransition', function(chart, filter){...})\n     * .on('preRender', function(chart){...})\n     * .on('postRender', function(chart){...})\n     * .on('preRedraw', function(chart){...})\n     * .on('postRedraw', function(chart){...})\n     * .on('filtered', function(chart, filter){...})\n     * .on('zoomed', function(chart, filter){...})\n     * @param {String} event\n     * @param {Function} listener\n     * @returns {dc.baseMixin}\n     */\n    _chart.on = function (event, listener) {\n        _listeners.on(event, listener);\n        return _chart;\n    };\n\n    return _chart;\n};\n\n/**\n * Margin is a mixin that provides margin utility functions for both the Row Chart and Coordinate Grid\n * Charts.\n * @name marginMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.marginMixin}\n */\ndc.marginMixin = function (_chart) {\n    var _margin = {top: 10, right: 50, bottom: 30, left: 30};\n\n    /**\n     * Get or set the margins for a particular coordinate grid chart instance. The margins is stored as\n     * an associative Javascript array.\n     * @method margins\n     * @memberof dc.marginMixin\n     * @instance\n     * @example\n     * var leftMargin = chart.margins().left; // 30 by default\n     * chart.margins().left = 50;\n     * leftMargin = chart.margins().left; // now 50\n     * @param {{top: Number, right: Number, left: Number, bottom: Number}} [margins={top: 10, right: 50, bottom: 30, left: 30}]\n     * @returns {{top: Number, right: Number, left: Number, bottom: Number}|dc.marginMixin}\n     */\n    _chart.margins = function (margins) {\n        if (!arguments.length) {\n            return _margin;\n        }\n        _margin = margins;\n        return _chart;\n    };\n\n    _chart.effectiveWidth = function () {\n        return _chart.width() - _chart.margins().left - _chart.margins().right;\n    };\n\n    _chart.effectiveHeight = function () {\n        return _chart.height() - _chart.margins().top - _chart.margins().bottom;\n    };\n\n    return _chart;\n};\n\n/**\n * The Color Mixin is an abstract chart functional class providing universal coloring support\n * as a mix-in for any concrete chart implementation.\n * @name colorMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.colorMixin}\n */\ndc.colorMixin = function (_chart) {\n    var _colors = d3.scale.category20c();\n    var _defaultAccessor = true;\n\n    var _colorAccessor = function (d) { return _chart.keyAccessor()(d); };\n\n    /**\n     * Retrieve current color scale or set a new color scale. This methods accepts any function that\n     * operates like a d3 scale.\n     * @method colors\n     * @memberof dc.colorMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @example\n     * // alternate categorical scale\n     * chart.colors(d3.scale.category20b());\n     * // ordinal scale\n     * chart.colors(d3.scale.ordinal().range(['red','green','blue']));\n     * // convenience method, the same as above\n     * chart.ordinalColors(['red','green','blue']);\n     * // set a linear scale\n     * chart.linearColors([\"#4575b4\", \"#ffffbf\", \"#a50026\"]);\n     * @param {d3.scale} [colorScale=d3.scale.category20c()]\n     * @returns {d3.scale|dc.colorMixin}\n     */\n    _chart.colors = function (colorScale) {\n        if (!arguments.length) {\n            return _colors;\n        }\n        if (colorScale instanceof Array) {\n            _colors = d3.scale.quantize().range(colorScale); // deprecated legacy support, note: this fails for ordinal domains\n        } else {\n            _colors = d3.functor(colorScale);\n        }\n        return _chart;\n    };\n\n    /**\n     * Convenience method to set the color scale to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal d3.scale.ordinal} with\n     * range `r`.\n     * @method ordinalColors\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {Array<String>} r\n     * @returns {dc.colorMixin}\n     */\n    _chart.ordinalColors = function (r) {\n        return _chart.colors(d3.scale.ordinal().range(r));\n    };\n\n    /**\n     * Convenience method to set the color scale to an Hcl interpolated linear scale with range `r`.\n     * @method linearColors\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {Array<Number>} r\n     * @returns {dc.colorMixin}\n     */\n    _chart.linearColors = function (r) {\n        return _chart.colors(d3.scale.linear()\n                             .range(r)\n                             .interpolate(d3.interpolateHcl));\n    };\n\n    /**\n     * Set or the get color accessor function. This function will be used to map a data point in a\n     * crossfilter group to a color value on the color scale. The default function uses the key\n     * accessor.\n     * @method colorAccessor\n     * @memberof dc.colorMixin\n     * @instance\n     * @example\n     * // default index based color accessor\n     * .colorAccessor(function (d, i){return i;})\n     * // color accessor for a multi-value crossfilter reduction\n     * .colorAccessor(function (d){return d.value.absGain;})\n     * @param {Function} [colorAccessor]\n     * @returns {Function|dc.colorMixin}\n     */\n    _chart.colorAccessor = function (colorAccessor) {\n        if (!arguments.length) {\n            return _colorAccessor;\n        }\n        _colorAccessor = colorAccessor;\n        _defaultAccessor = false;\n        return _chart;\n    };\n\n    // what is this?\n    _chart.defaultColorAccessor = function () {\n        return _defaultAccessor;\n    };\n\n    /**\n     * Set or get the current domain for the color mapping function. The domain must be supplied as an\n     * array.\n     *\n     * Note: previously this method accepted a callback function. Instead you may use a custom scale\n     * set by {@link dc.colorMixin#colors .colors}.\n     * @method colorDomain\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {Array<String>} [domain]\n     * @returns {Array<String>|dc.colorMixin}\n     */\n    _chart.colorDomain = function (domain) {\n        if (!arguments.length) {\n            return _colors.domain();\n        }\n        _colors.domain(domain);\n        return _chart;\n    };\n\n    /**\n     * Set the domain by determining the min and max values as retrieved by\n     * {@link dc.colorMixin#colorAccessor .colorAccessor} over the chart's dataset.\n     * @method calculateColorDomain\n     * @memberof dc.colorMixin\n     * @instance\n     * @returns {dc.colorMixin}\n     */\n    _chart.calculateColorDomain = function () {\n        var newDomain = [d3.min(_chart.data(), _chart.colorAccessor()),\n                         d3.max(_chart.data(), _chart.colorAccessor())];\n        _colors.domain(newDomain);\n        return _chart;\n    };\n\n    /**\n     * Get the color for the datum d and counter i. This is used internally by charts to retrieve a color.\n     * @method getColor\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {*} d\n     * @param {Number} [i]\n     * @returns {String}\n     */\n    _chart.getColor = function (d, i) {\n        return _colors(_colorAccessor.call(this, d, i));\n    };\n\n    /**\n     * **Deprecated.** Get/set the color calculator. This actually replaces the\n     * {@link dc.colorMixin#getColor getColor} method!\n     *\n     * This is not recommended, since using a {@link dc.colorMixin#colorAccessor colorAccessor} and\n     * color scale ({@link dc.colorMixin#colors .colors}) is more powerful and idiomatic d3.\n     * @method colorCalculator\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {*} [colorCalculator]\n     * @returns {Function|dc.colorMixin}\n     */\n    _chart.colorCalculator = dc.logger.deprecate(function (colorCalculator) {\n        if (!arguments.length) {\n            return _chart.getColor;\n        }\n        _chart.getColor = colorCalculator;\n        return _chart;\n    }, 'colorMixin.colorCalculator has been deprecated. Please colorMixin.colors and colorMixin.colorAccessor instead');\n\n    return _chart;\n};\n\n/**\n * Coordinate Grid is an abstract base chart designed to support a number of coordinate grid based\n * concrete chart types, e.g. bar chart, line chart, and bubble chart.\n * @name coordinateGridMixin\n * @memberof dc\n * @mixin\n * @mixes dc.colorMixin\n * @mixes dc.marginMixin\n * @mixes dc.baseMixin\n * @param {Object} _chart\n * @returns {dc.coordinateGridMixin}\n */\ndc.coordinateGridMixin = function (_chart) {\n    var GRID_LINE_CLASS = 'grid-line';\n    var HORIZONTAL_CLASS = 'horizontal';\n    var VERTICAL_CLASS = 'vertical';\n    var Y_AXIS_LABEL_CLASS = 'y-axis-label';\n    var X_AXIS_LABEL_CLASS = 'x-axis-label';\n    var DEFAULT_AXIS_LABEL_PADDING = 12;\n\n    _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin(_chart)));\n\n    _chart.colors(d3.scale.category10());\n    _chart._mandatoryAttributes().push('x');\n    var _parent;\n    var _g;\n    var _chartBodyG;\n\n    var _x;\n    var _xOriginalDomain;\n    var _xAxis = d3.svg.axis().orient('bottom');\n    var _xUnits = dc.units.integers;\n    var _xAxisPadding = 0;\n    var _xAxisPaddingUnit = 'day';\n    var _xElasticity = false;\n    var _xAxisLabel;\n    var _xAxisLabelPadding = 0;\n    var _lastXDomain;\n\n    var _y;\n    var _yAxis = d3.svg.axis().orient('left');\n    var _yAxisPadding = 0;\n    var _yElasticity = false;\n    var _yAxisLabel;\n    var _yAxisLabelPadding = 0;\n\n    var _brush = d3.svg.brush();\n    var _brushOn = true;\n    var _round;\n\n    var _renderHorizontalGridLine = false;\n    var _renderVerticalGridLine = false;\n\n    var _refocused = false, _resizing = false;\n    var _unitCount;\n\n    var _zoomScale = [1, Infinity];\n    var _zoomOutRestrict = true;\n\n    var _zoom = d3.behavior.zoom().on('zoom', zoomHandler);\n    var _nullZoom = d3.behavior.zoom().on('zoom', null);\n    var _hasBeenMouseZoomable = false;\n\n    var _rangeChart;\n    var _focusChart;\n\n    var _mouseZoomable = false;\n    var _clipPadding = 0;\n\n    var _outerRangeBandPadding = 0.5;\n    var _rangeBandPadding = 0;\n\n    var _useRightYAxis = false;\n\n    /**\n     * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate\n     * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced\n     * with {@link dc.coordinateGridMixin+x .x()} or {@link dc.coordinateGridMixin#y .y()}, and has\n     * no effect on elastic scales.)\n     * @method rescale\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {dc.coordinateGridMixin}\n     */\n    _chart.rescale = function () {\n        _unitCount = undefined;\n        _resizing = true;\n        return _chart;\n    };\n\n    _chart.resizing = function () {\n        return _resizing;\n    };\n\n    /**\n     * Get or set the range selection chart associated with this instance. Setting the range selection\n     * chart using this function will automatically update its selection brush when the current chart\n     * zooms in. In return the given range chart will also automatically attach this chart as its focus\n     * chart hence zoom in when range brush updates.\n     *\n     * Usually the range and focus charts will share a dimension. The range chart will set the zoom\n     * boundaries for the focus chart, so its dimension values must be compatible with the domain of\n     * the focus chart.\n     *\n     * See the [Nasdaq 100 Index](http://dc-js.github.com/dc.js/) example for this effect in action.\n     * @method rangeChart\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {dc.coordinateGridMixin} [rangeChart]\n     * @returns {dc.coordinateGridMixin}\n     */\n    _chart.rangeChart = function (rangeChart) {\n        if (!arguments.length) {\n            return _rangeChart;\n        }\n        _rangeChart = rangeChart;\n        _rangeChart.focusChart(_chart);\n        return _chart;\n    };\n\n    /**\n     * Get or set the scale extent for mouse zooms.\n     * @method zoomScale\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Array<Number|Date>} [extent=[1, Infinity]]\n     * @returns {Array<Number|Date>|dc.coordinateGridMixin}\n     */\n    _chart.zoomScale = function (extent) {\n        if (!arguments.length) {\n            return _zoomScale;\n        }\n        _zoomScale = extent;\n        return _chart;\n    };\n\n    /**\n     * Get or set the zoom restriction for the chart. If true limits the zoom to origional domain of the chart.\n     * @method zoomOutRestrict\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [zoomOutRestrict=true]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.zoomOutRestrict = function (zoomOutRestrict) {\n        if (!arguments.length) {\n            return _zoomOutRestrict;\n        }\n        _zoomScale[0] = zoomOutRestrict ? 1 : 0;\n        _zoomOutRestrict = zoomOutRestrict;\n        return _chart;\n    };\n\n    _chart._generateG = function (parent) {\n        if (parent === undefined) {\n            _parent = _chart.svg();\n        } else {\n            _parent = parent;\n        }\n\n        var href = window.location.href.split('#')[0];\n\n        _g = _parent.append('g');\n\n        _chartBodyG = _g.append('g').attr('class', 'chart-body')\n            .attr('transform', 'translate(' + _chart.margins().left + ', ' + _chart.margins().top + ')')\n            .attr('clip-path', 'url(' + href + '#' + getClipPathId() + ')');\n\n        return _g;\n    };\n\n    /**\n     * Get or set the root g element. This method is usually used to retrieve the g element in order to\n     * overlay custom svg drawing programatically. **Caution**: The root g element is usually generated\n     * by dc.js internals, and resetting it might produce unpredictable result.\n     * @method g\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {SVGElement} [gElement]\n     * @returns {SVGElement|dc.coordinateGridMixin}\n     */\n    _chart.g = function (gElement) {\n        if (!arguments.length) {\n            return _g;\n        }\n        _g = gElement;\n        return _chart;\n    };\n\n    /**\n     * Set or get mouse zoom capability flag (default: false). When turned on the chart will be\n     * zoomable using the mouse wheel. If the range selector chart is attached zooming will also update\n     * the range selection brush on the associated range selector chart.\n     * @method mouseZoomable\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [mouseZoomable=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.mouseZoomable = function (mouseZoomable) {\n        if (!arguments.length) {\n            return _mouseZoomable;\n        }\n        _mouseZoomable = mouseZoomable;\n        return _chart;\n    };\n\n    /**\n     * Retrieve the svg group for the chart body.\n     * @method chartBodyG\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {SVGElement} [chartBodyG]\n     * @returns {SVGElement}\n     */\n    _chart.chartBodyG = function (chartBodyG) {\n        if (!arguments.length) {\n            return _chartBodyG;\n        }\n        _chartBodyG = chartBodyG;\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Get or set the x scale. The x scale can be any d3\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale} or\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md ordinal scale}.\n     * @method x\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @example\n     * // set x to a linear scale\n     * chart.x(d3.scale.linear().domain([-2500, 2500]))\n     * // set x to a time scale to generate histogram\n     * chart.x(d3.time.scale().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))\n     * @param {d3.scale} [xScale]\n     * @returns {d3.scale|dc.coordinateGridMixin}\n     */\n    _chart.x = function (xScale) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = xScale;\n        _xOriginalDomain = _x.domain();\n        _chart.rescale();\n        return _chart;\n    };\n\n    _chart.xOriginalDomain = function () {\n        return _xOriginalDomain;\n    };\n\n    /**\n     * Set or get the xUnits function. The coordinate grid chart uses the xUnits function to calculate\n     * the number of data projections on x axis such as the number of bars for a bar chart or the\n     * number of dots for a line chart. This function is expected to return a Javascript array of all\n     * data points on x axis, or the number of points on the axis. [d3 time range functions\n     * d3.time.days, d3.time.months, and\n     * d3.time.years](https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#aliases) are all valid xUnits\n     * function. dc.js also provides a few units function, see the {@link dc.units Units Namespace} for\n     * a list of built-in units functions.\n     * @method xUnits\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @todo Add docs for utilities\n     * @example\n     * // set x units to count days\n     * chart.xUnits(d3.time.days);\n     * // set x units to count months\n     * chart.xUnits(d3.time.months);\n     *\n     * // A custom xUnits function can be used as long as it follows the following interface:\n     * // units in integer\n     * function(start, end, xDomain) {\n     *      // simply calculates how many integers in the domain\n     *      return Math.abs(end - start);\n     * };\n     *\n     * // fixed units\n     * function(start, end, xDomain) {\n     *      // be aware using fixed units will disable the focus/zoom ability on the chart\n     *      return 1000;\n     * @param {Function} [xUnits=dc.units.integers]\n     * @returns {Function|dc.coordinateGridMixin}\n     */\n    _chart.xUnits = function (xUnits) {\n        if (!arguments.length) {\n            return _xUnits;\n        }\n        _xUnits = xUnits;\n        return _chart;\n    };\n\n    /**\n     * Set or get the x axis used by a particular coordinate grid chart instance. This function is most\n     * useful when x axis customization is required. The x axis in dc.js is an instance of a\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3 axis object};\n     * therefore it supports any valid d3 axis manipulation.\n     *\n     * **Caution**: The x axis is usually generated internally by dc; resetting it may cause\n     * unexpected results. Note also that when used as a getter, this function is not chainable:\n     * it returns the axis, not the chart,\n     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#why-does-everything-break-after-a-call-to-xaxis-or-yaxis\n     * so attempting to call chart functions after calling `.xAxis()` will fail}.\n     * @method xAxis\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize x axis tick format\n     * chart.xAxis().tickFormat(function(v) {return v + '%';});\n     * // customize x axis tick values\n     * chart.xAxis().tickValues([0, 100, 200, 300]);\n     * @param {d3.svg.axis} [xAxis=d3.svg.axis().orient('bottom')]\n     * @returns {d3.svg.axis|dc.coordinateGridMixin}\n     */\n    _chart.xAxis = function (xAxis) {\n        if (!arguments.length) {\n            return _xAxis;\n        }\n        _xAxis = xAxis;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off elastic x axis behavior. If x axis elasticity is turned on, then the grid chart will\n     * attempt to recalculate the x axis range whenever a redraw event is triggered.\n     * @method elasticX\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [elasticX=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.elasticX = function (elasticX) {\n        if (!arguments.length) {\n            return _xElasticity;\n        }\n        _xElasticity = elasticX;\n        return _chart;\n    };\n\n    /**\n     * Set or get x axis padding for the elastic x axis. The padding will be added to both end of the x\n     * axis if elasticX is turned on; otherwise it is ignored.\n     *\n     * Padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to\n     * number or date x axes.  When padding a date axis, an integer represents number of units being padded\n     * and a percentage string will be treated the same as an integer. The unit will be determined by the\n     * xAxisPaddingUnit variable.\n     * @method xAxisPadding\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Number|String} [padding=0]\n     * @returns {Number|String|dc.coordinateGridMixin}\n     */\n    _chart.xAxisPadding = function (padding) {\n        if (!arguments.length) {\n            return _xAxisPadding;\n        }\n        _xAxisPadding = padding;\n        return _chart;\n    };\n\n    /**\n     * Set or get x axis padding unit for the elastic x axis. The padding unit will determine which unit to\n     * use when applying xAxis padding if elasticX is turned on and if x-axis uses a time dimension;\n     * otherwise it is ignored.\n     *\n     * Padding unit is a string that will be used when the padding is calculated. Available parameters are\n     * the available d3 time intervals; see\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#interval d3.time.interval}.\n     * @method xAxisPaddingUnit\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {String} [unit='days']\n     * @returns {String|dc.coordinateGridMixin}\n     */\n    _chart.xAxisPaddingUnit = function (unit) {\n        if (!arguments.length) {\n            return _xAxisPaddingUnit;\n        }\n        _xAxisPaddingUnit = unit;\n        return _chart;\n    };\n\n    /**\n     * Returns the number of units displayed on the x axis using the unit measure configured by\n     * {@link dc.coordinateGridMixin#xUnits xUnits}.\n     * @method xUnitCount\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {Number}\n     */\n    _chart.xUnitCount = function () {\n        if (_unitCount === undefined) {\n            var units = _chart.xUnits()(_chart.x().domain()[0], _chart.x().domain()[1], _chart.x().domain());\n\n            if (units instanceof Array) {\n                _unitCount = units.length;\n            } else {\n                _unitCount = units;\n            }\n        }\n\n        return _unitCount;\n    };\n\n    /**\n     * Gets or sets whether the chart should be drawn with a right axis instead of a left axis. When\n     * used with a chart in a composite chart, allows both left and right Y axes to be shown on a\n     * chart.\n     * @method useRightYAxis\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [useRightYAxis=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.useRightYAxis = function (useRightYAxis) {\n        if (!arguments.length) {\n            return _useRightYAxis;\n        }\n        _useRightYAxis = useRightYAxis;\n        return _chart;\n    };\n\n    /**\n     * Returns true if the chart is using ordinal xUnits ({@link dc.units.ordinal dc.units.ordinal}, or false\n     * otherwise. Most charts behave differently with ordinal data and use the result of this method to\n     * trigger the appropriate logic.\n     * @method isOrdinal\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {Boolean}\n     */\n    _chart.isOrdinal = function () {\n        return _chart.xUnits() === dc.units.ordinal;\n    };\n\n    _chart._useOuterPadding = function () {\n        return true;\n    };\n\n    _chart._ordinalXDomain = function () {\n        var groups = _chart._computeOrderedGroups(_chart.data());\n        return groups.map(_chart.keyAccessor());\n    };\n\n    function compareDomains (d1, d2) {\n        return !d1 || !d2 || d1.length !== d2.length ||\n            d1.some(function (elem, i) { return (elem && d2[i]) ? elem.toString() !== d2[i].toString() : elem === d2[i]; });\n    }\n\n    function prepareXAxis (g, render) {\n        if (!_chart.isOrdinal()) {\n            if (_chart.elasticX()) {\n                _x.domain([_chart.xAxisMin(), _chart.xAxisMax()]);\n            }\n        } else { // _chart.isOrdinal()\n            if (_chart.elasticX() || _x.domain().length === 0) {\n                _x.domain(_chart._ordinalXDomain());\n            }\n        }\n\n        // has the domain changed?\n        var xdom = _x.domain();\n        if (render || compareDomains(_lastXDomain, xdom)) {\n            _chart.rescale();\n        }\n        _lastXDomain = xdom;\n\n        // please can't we always use rangeBands for bar charts?\n        if (_chart.isOrdinal()) {\n            _x.rangeBands([0, _chart.xAxisLength()], _rangeBandPadding,\n                          _chart._useOuterPadding() ? _outerRangeBandPadding : 0);\n        } else {\n            _x.range([0, _chart.xAxisLength()]);\n        }\n\n        _xAxis = _xAxis.scale(_chart.x());\n\n        renderVerticalGridLines(g);\n    }\n\n    _chart.renderXAxis = function (g) {\n        var axisXG = g.select('g.x');\n\n        if (axisXG.empty()) {\n            axisXG = g.append('g')\n                .attr('class', 'axis x')\n                .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart._xAxisY() + ')');\n        }\n\n        var axisXLab = g.select('text.' + X_AXIS_LABEL_CLASS);\n        if (axisXLab.empty() && _chart.xAxisLabel()) {\n            axisXLab = g.append('text')\n                .attr('class', X_AXIS_LABEL_CLASS)\n                .attr('transform', 'translate(' + (_chart.margins().left + _chart.xAxisLength() / 2) + ',' +\n                      (_chart.height() - _xAxisLabelPadding) + ')')\n                .attr('text-anchor', 'middle');\n        }\n        if (_chart.xAxisLabel() && axisXLab.text() !== _chart.xAxisLabel()) {\n            axisXLab.text(_chart.xAxisLabel());\n        }\n\n        dc.transition(axisXG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart._xAxisY() + ')')\n            .call(_xAxis);\n        dc.transition(axisXLab, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + (_chart.margins().left + _chart.xAxisLength() / 2) + ',' +\n                  (_chart.height() - _xAxisLabelPadding) + ')');\n    };\n\n    function renderVerticalGridLines (g) {\n        var gridLineG = g.select('g.' + VERTICAL_CLASS);\n\n        if (_renderVerticalGridLine) {\n            if (gridLineG.empty()) {\n                gridLineG = g.insert('g', ':first-child')\n                    .attr('class', GRID_LINE_CLASS + ' ' + VERTICAL_CLASS)\n                    .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n            }\n\n            var ticks = _xAxis.tickValues() ? _xAxis.tickValues() :\n                    (typeof _x.ticks === 'function' ? _x.ticks(_xAxis.ticks()[0]) : _x.domain());\n\n            var lines = gridLineG.selectAll('line')\n                .data(ticks);\n\n            // enter\n            var linesGEnter = lines.enter()\n                .append('line')\n                .attr('x1', function (d) {\n                    return _x(d);\n                })\n                .attr('y1', _chart._xAxisY() - _chart.margins().top)\n                .attr('x2', function (d) {\n                    return _x(d);\n                })\n                .attr('y2', 0)\n                .attr('opacity', 0);\n            dc.transition(linesGEnter, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', 1);\n\n            // update\n            dc.transition(lines, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('x1', function (d) {\n                    return _x(d);\n                })\n                .attr('y1', _chart._xAxisY() - _chart.margins().top)\n                .attr('x2', function (d) {\n                    return _x(d);\n                })\n                .attr('y2', 0);\n\n            // exit\n            lines.exit().remove();\n        } else {\n            gridLineG.selectAll('line').remove();\n        }\n    }\n\n    _chart._xAxisY = function () {\n        return (_chart.height() - _chart.margins().bottom);\n    };\n\n    _chart.xAxisLength = function () {\n        return _chart.effectiveWidth();\n    };\n\n    /**\n     * Set or get the x axis label. If setting the label, you may optionally include additional padding to\n     * the margin to make room for the label. By default the padded is set to 12 to accomodate the text height.\n     * @method xAxisLabel\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {String} [labelText]\n     * @param {Number} [padding=12]\n     * @returns {String}\n     */\n    _chart.xAxisLabel = function (labelText, padding) {\n        if (!arguments.length) {\n            return _xAxisLabel;\n        }\n        _xAxisLabel = labelText;\n        _chart.margins().bottom -= _xAxisLabelPadding;\n        _xAxisLabelPadding = (padding === undefined) ? DEFAULT_AXIS_LABEL_PADDING : padding;\n        _chart.margins().bottom += _xAxisLabelPadding;\n        return _chart;\n    };\n\n    _chart._prepareYAxis = function (g) {\n        if (_y === undefined || _chart.elasticY()) {\n            if (_y === undefined) {\n                _y = d3.scale.linear();\n            }\n            var min = _chart.yAxisMin() || 0,\n                max = _chart.yAxisMax() || 0;\n            _y.domain([min, max]).rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _y.range([_chart.yAxisHeight(), 0]);\n        _yAxis = _yAxis.scale(_y);\n\n        if (_useRightYAxis) {\n            _yAxis.orient('right');\n        }\n\n        _chart._renderHorizontalGridLinesForAxis(g, _y, _yAxis);\n    };\n\n    _chart.renderYAxisLabel = function (axisClass, text, rotation, labelXPosition) {\n        labelXPosition = labelXPosition || _yAxisLabelPadding;\n\n        var axisYLab = _chart.g().select('text.' + Y_AXIS_LABEL_CLASS + '.' + axisClass + '-label');\n        var labelYPosition = (_chart.margins().top + _chart.yAxisHeight() / 2);\n        if (axisYLab.empty() && text) {\n            axisYLab = _chart.g().append('text')\n                .attr('transform', 'translate(' + labelXPosition + ',' + labelYPosition + '),rotate(' + rotation + ')')\n                .attr('class', Y_AXIS_LABEL_CLASS + ' ' + axisClass + '-label')\n                .attr('text-anchor', 'middle')\n                .text(text);\n        }\n        if (text && axisYLab.text() !== text) {\n            axisYLab.text(text);\n        }\n        dc.transition(axisYLab, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + labelXPosition + ',' + labelYPosition + '),rotate(' + rotation + ')');\n    };\n\n    _chart.renderYAxisAt = function (axisClass, axis, position) {\n        var axisYG = _chart.g().select('g.' + axisClass);\n        if (axisYG.empty()) {\n            axisYG = _chart.g().append('g')\n                .attr('class', 'axis ' + axisClass)\n                .attr('transform', 'translate(' + position + ',' + _chart.margins().top + ')');\n        }\n\n        dc.transition(axisYG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + position + ',' + _chart.margins().top + ')')\n            .call(axis);\n    };\n\n    _chart.renderYAxis = function () {\n        var axisPosition = _useRightYAxis ? (_chart.width() - _chart.margins().right) : _chart._yAxisX();\n        _chart.renderYAxisAt('y', _yAxis, axisPosition);\n        var labelPosition = _useRightYAxis ? (_chart.width() - _yAxisLabelPadding) : _yAxisLabelPadding;\n        var rotation = _useRightYAxis ? 90 : -90;\n        _chart.renderYAxisLabel('y', _chart.yAxisLabel(), rotation, labelPosition);\n    };\n\n    _chart._renderHorizontalGridLinesForAxis = function (g, scale, axis) {\n        var gridLineG = g.select('g.' + HORIZONTAL_CLASS);\n\n        if (_renderHorizontalGridLine) {\n            var ticks = axis.tickValues() ? axis.tickValues() : scale.ticks(axis.ticks()[0]);\n\n            if (gridLineG.empty()) {\n                gridLineG = g.insert('g', ':first-child')\n                    .attr('class', GRID_LINE_CLASS + ' ' + HORIZONTAL_CLASS)\n                    .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n            }\n\n            var lines = gridLineG.selectAll('line')\n                .data(ticks);\n\n            // enter\n            var linesGEnter = lines.enter()\n                .append('line')\n                .attr('x1', 1)\n                .attr('y1', function (d) {\n                    return scale(d);\n                })\n                .attr('x2', _chart.xAxisLength())\n                .attr('y2', function (d) {\n                    return scale(d);\n                })\n                .attr('opacity', 0);\n            dc.transition(linesGEnter, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', 1);\n\n            // update\n            dc.transition(lines, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('x1', 1)\n                .attr('y1', function (d) {\n                    return scale(d);\n                })\n                .attr('x2', _chart.xAxisLength())\n                .attr('y2', function (d) {\n                    return scale(d);\n                });\n\n            // exit\n            lines.exit().remove();\n        } else {\n            gridLineG.selectAll('line').remove();\n        }\n    };\n\n    _chart._yAxisX = function () {\n        return _chart.useRightYAxis() ? _chart.width() - _chart.margins().right : _chart.margins().left;\n    };\n\n    /**\n     * Set or get the y axis label. If setting the label, you may optionally include additional padding\n     * to the margin to make room for the label. By default the padding is set to 12 to accommodate the\n     * text height.\n     * @method yAxisLabel\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {String} [labelText]\n     * @param {Number} [padding=12]\n     * @returns {String|dc.coordinateGridMixin}\n     */\n    _chart.yAxisLabel = function (labelText, padding) {\n        if (!arguments.length) {\n            return _yAxisLabel;\n        }\n        _yAxisLabel = labelText;\n        _chart.margins().left -= _yAxisLabelPadding;\n        _yAxisLabelPadding = (padding === undefined) ? DEFAULT_AXIS_LABEL_PADDING : padding;\n        _chart.margins().left += _yAxisLabelPadding;\n        return _chart;\n    };\n\n    /**\n     * Get or set the y scale. The y scale is typically automatically determined by the chart implementation.\n     * @method y\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @param {d3.scale} [yScale]\n     * @returns {d3.scale|dc.coordinateGridMixin}\n     */\n    _chart.y = function (yScale) {\n        if (!arguments.length) {\n            return _y;\n        }\n        _y = yScale;\n        _chart.rescale();\n        return _chart;\n    };\n\n    /**\n     * Set or get the y axis used by the coordinate grid chart instance. This function is most useful\n     * when y axis customization is required. The y axis in dc.js is simply an instance of a [d3 axis\n     * object](https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis); therefore it supports any\n     * valid d3 axis manipulation.\n     *\n     * **Caution**: The y axis is usually generated internally by dc; resetting it may cause\n     * unexpected results.  Note also that when used as a getter, this function is not chainable: it\n     * returns the axis, not the chart,\n     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#why-does-everything-break-after-a-call-to-xaxis-or-yaxis\n     * so attempting to call chart functions after calling `.yAxis()` will fail}.\n     * @method yAxis\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize y axis tick format\n     * chart.yAxis().tickFormat(function(v) {return v + '%';});\n     * // customize y axis tick values\n     * chart.yAxis().tickValues([0, 100, 200, 300]);\n     * @param {d3.svg.axis} [yAxis=d3.svg.axis().orient('left')]\n     * @returns {d3.svg.axis|dc.coordinateGridMixin}\n     */\n    _chart.yAxis = function (yAxis) {\n        if (!arguments.length) {\n            return _yAxis;\n        }\n        _yAxis = yAxis;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off elastic y axis behavior. If y axis elasticity is turned on, then the grid chart will\n     * attempt to recalculate the y axis range whenever a redraw event is triggered.\n     * @method elasticY\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [elasticY=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.elasticY = function (elasticY) {\n        if (!arguments.length) {\n            return _yElasticity;\n        }\n        _yElasticity = elasticY;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off horizontal grid lines.\n     * @method renderHorizontalGridLines\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [renderHorizontalGridLines=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.renderHorizontalGridLines = function (renderHorizontalGridLines) {\n        if (!arguments.length) {\n            return _renderHorizontalGridLine;\n        }\n        _renderHorizontalGridLine = renderHorizontalGridLines;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off vertical grid lines.\n     * @method renderVerticalGridLines\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [renderVerticalGridLines=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.renderVerticalGridLines = function (renderVerticalGridLines) {\n        if (!arguments.length) {\n            return _renderVerticalGridLine;\n        }\n        _renderVerticalGridLine = renderVerticalGridLines;\n        return _chart;\n    };\n\n    /**\n     * Calculates the minimum x value to display in the chart. Includes xAxisPadding if set.\n     * @method xAxisMin\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.xAxisMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return _chart.keyAccessor()(e);\n        });\n        return dc.utils.subtract(min, _xAxisPadding, _xAxisPaddingUnit);\n    };\n\n    /**\n     * Calculates the maximum x value to display in the chart. Includes xAxisPadding if set.\n     * @method xAxisMax\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.xAxisMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return _chart.keyAccessor()(e);\n        });\n        return dc.utils.add(max, _xAxisPadding, _xAxisPaddingUnit);\n    };\n\n    /**\n     * Calculates the minimum y value to display in the chart. Includes yAxisPadding if set.\n     * @method yAxisMin\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.yAxisMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return _chart.valueAccessor()(e);\n        });\n        return dc.utils.subtract(min, _yAxisPadding);\n    };\n\n    /**\n     * Calculates the maximum y value to display in the chart. Includes yAxisPadding if set.\n     * @method yAxisMax\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.yAxisMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return _chart.valueAccessor()(e);\n        });\n        return dc.utils.add(max, _yAxisPadding);\n    };\n\n    /**\n     * Set or get y axis padding for the elastic y axis. The padding will be added to the top and\n     * bottom of the y axis if elasticY is turned on; otherwise it is ignored.\n     *\n     * Padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to\n     * number or date axes. When padding a date axis, an integer represents number of days being padded\n     * and a percentage string will be treated the same as an integer.\n     * @method yAxisPadding\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Number|String} [padding=0]\n     * @returns {Number|dc.coordinateGridMixin}\n     */\n    _chart.yAxisPadding = function (padding) {\n        if (!arguments.length) {\n            return _yAxisPadding;\n        }\n        _yAxisPadding = padding;\n        return _chart;\n    };\n\n    _chart.yAxisHeight = function () {\n        return _chart.effectiveHeight();\n    };\n\n    /**\n     * Set or get the rounding function used to quantize the selection when brushing is enabled.\n     * @method round\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @example\n     * // set x unit round to by month, this will make sure range selection brush will\n     * // select whole months\n     * chart.round(d3.time.month.round);\n     * @param {Function} [round]\n     * @returns {Function|dc.coordinateGridMixin}\n     */\n    _chart.round = function (round) {\n        if (!arguments.length) {\n            return _round;\n        }\n        _round = round;\n        return _chart;\n    };\n\n    _chart._rangeBandPadding = function (_) {\n        if (!arguments.length) {\n            return _rangeBandPadding;\n        }\n        _rangeBandPadding = _;\n        return _chart;\n    };\n\n    _chart._outerRangeBandPadding = function (_) {\n        if (!arguments.length) {\n            return _outerRangeBandPadding;\n        }\n        _outerRangeBandPadding = _;\n        return _chart;\n    };\n\n    dc.override(_chart, 'filter', function (_) {\n        if (!arguments.length) {\n            return _chart._filter();\n        }\n\n        _chart._filter(_);\n\n        if (_) {\n            _chart.brush().extent(_);\n        } else {\n            _chart.brush().clear();\n        }\n\n        return _chart;\n    });\n\n    _chart.brush = function (_) {\n        if (!arguments.length) {\n            return _brush;\n        }\n        _brush = _;\n        return _chart;\n    };\n\n    function brushHeight () {\n        return _chart._xAxisY() - _chart.margins().top;\n    }\n\n    _chart.renderBrush = function (g) {\n        if (_brushOn) {\n            _brush.on('brush', _chart._brushing);\n            _brush.on('brushstart', _chart._disableMouseZoom);\n            _brush.on('brushend', configureMouseZoom);\n\n            var gBrush = g.append('g')\n                .attr('class', 'brush')\n                .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')')\n                .call(_brush.x(_chart.x()));\n            _chart.setBrushY(gBrush, false);\n            _chart.setHandlePaths(gBrush);\n\n            if (_chart.hasFilter()) {\n                _chart.redrawBrush(g, false);\n            }\n        }\n    };\n\n    _chart.setHandlePaths = function (gBrush) {\n        gBrush.selectAll('.resize').append('path').attr('d', _chart.resizeHandlePath);\n    };\n\n    _chart.setBrushY = function (gBrush) {\n        gBrush.selectAll('rect')\n            .attr('height', brushHeight());\n        gBrush.selectAll('.resize path')\n            .attr('d', _chart.resizeHandlePath);\n    };\n\n    _chart.extendBrush = function () {\n        var extent = _brush.extent();\n        if (_chart.round()) {\n            extent[0] = extent.map(_chart.round())[0];\n            extent[1] = extent.map(_chart.round())[1];\n\n            _g.select('.brush')\n                .call(_brush.extent(extent));\n        }\n        return extent;\n    };\n\n    _chart.brushIsEmpty = function (extent) {\n        return _brush.empty() || !extent || extent[1] <= extent[0];\n    };\n\n    _chart._brushing = function () {\n        var extent = _chart.extendBrush();\n\n        _chart.redrawBrush(_g, false);\n\n        if (_chart.brushIsEmpty(extent)) {\n            dc.events.trigger(function () {\n                _chart.filter(null);\n                _chart.redrawGroup();\n            }, dc.constants.EVENT_DELAY);\n        } else {\n            var rangedFilter = dc.filters.RangedFilter(extent[0], extent[1]);\n\n            dc.events.trigger(function () {\n                _chart.replaceFilter(rangedFilter);\n                _chart.redrawGroup();\n            }, dc.constants.EVENT_DELAY);\n        }\n    };\n\n    _chart.redrawBrush = function (g, doTransition) {\n        if (_brushOn) {\n            if (_chart.filter() && _chart.brush().empty()) {\n                _chart.brush().extent(_chart.filter());\n            }\n\n            var gBrush = dc.optionalTransition(doTransition, _chart.transitionDuration(), _chart.transitionDelay())(g.select('g.brush'));\n            _chart.setBrushY(gBrush);\n            gBrush.call(_chart.brush()\n                      .x(_chart.x())\n                      .extent(_chart.brush().extent()));\n        }\n\n        _chart.fadeDeselectedArea();\n    };\n\n    _chart.fadeDeselectedArea = function () {\n        // do nothing, sub-chart should override this function\n    };\n\n    // borrowed from Crossfilter example\n    _chart.resizeHandlePath = function (d) {\n        var e = +(d === 'e'), x = e ? 1 : -1, y = brushHeight() / 3;\n        return 'M' + (0.5 * x) + ',' + y +\n            'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6) +\n            'V' + (2 * y - 6) +\n            'A6,6 0 0 ' + e + ' ' + (0.5 * x) + ',' + (2 * y) +\n            'Z' +\n            'M' + (2.5 * x) + ',' + (y + 8) +\n            'V' + (2 * y - 8) +\n            'M' + (4.5 * x) + ',' + (y + 8) +\n            'V' + (2 * y - 8);\n    };\n\n    function getClipPathId () {\n        return _chart.anchorName().replace(/[ .#=\\[\\]\"]/g, '-') + '-clip';\n    }\n\n    /**\n     * Get or set the padding in pixels for the clip path. Once set padding will be applied evenly to\n     * the top, left, right, and bottom when the clip path is generated. If set to zero, the clip area\n     * will be exactly the chart body area minus the margins.\n     * @method clipPadding\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Number} [padding=5]\n     * @returns {Number|dc.coordinateGridMixin}\n     */\n    _chart.clipPadding = function (padding) {\n        if (!arguments.length) {\n            return _clipPadding;\n        }\n        _clipPadding = padding;\n        return _chart;\n    };\n\n    function generateClipPath () {\n        var defs = dc.utils.appendOrSelect(_parent, 'defs');\n        // cannot select <clippath> elements; bug in WebKit, must select by id\n        // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n        var id = getClipPathId();\n        var chartBodyClip = dc.utils.appendOrSelect(defs, '#' + id, 'clipPath').attr('id', id);\n\n        var padding = _clipPadding * 2;\n\n        dc.utils.appendOrSelect(chartBodyClip, 'rect')\n            .attr('width', _chart.xAxisLength() + padding)\n            .attr('height', _chart.yAxisHeight() + padding)\n            .attr('transform', 'translate(-' + _clipPadding + ', -' + _clipPadding + ')');\n    }\n\n    _chart._preprocessData = function () {};\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _chart._preprocessData();\n\n        _chart._generateG();\n        generateClipPath();\n\n        drawChart(true);\n\n        configureMouseZoom();\n\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        _chart._preprocessData();\n\n        drawChart(false);\n        generateClipPath();\n\n        return _chart;\n    };\n\n    function drawChart (render) {\n        if (_chart.isOrdinal()) {\n            _brushOn = false;\n        }\n\n        prepareXAxis(_chart.g(), render);\n        _chart._prepareYAxis(_chart.g());\n\n        _chart.plotData();\n\n        if (_chart.elasticX() || _resizing || render) {\n            _chart.renderXAxis(_chart.g());\n        }\n\n        if (_chart.elasticY() || _resizing || render) {\n            _chart.renderYAxis(_chart.g());\n        }\n\n        if (render) {\n            _chart.renderBrush(_chart.g(), false);\n        } else {\n            _chart.redrawBrush(_chart.g(), _resizing);\n        }\n        _chart.fadeDeselectedArea();\n        _resizing = false;\n    }\n\n    function configureMouseZoom () {\n        if (_mouseZoomable) {\n            _chart._enableMouseZoom();\n        } else if (_hasBeenMouseZoomable) {\n            _chart._disableMouseZoom();\n        }\n    }\n\n    _chart._enableMouseZoom = function () {\n        _hasBeenMouseZoomable = true;\n        _zoom.x(_chart.x())\n            .scaleExtent(_zoomScale)\n            .size([_chart.width(), _chart.height()])\n            .duration(_chart.transitionDuration());\n        _chart.root().call(_zoom);\n    };\n\n    _chart._disableMouseZoom = function () {\n        _chart.root().call(_nullZoom);\n    };\n\n    function zoomHandler () {\n        _refocused = true;\n        if (_zoomOutRestrict) {\n            var constraint = _xOriginalDomain;\n            if (_rangeChart) {\n                constraint = intersectExtents(constraint, _rangeChart.x().domain());\n            }\n            var constrained = constrainExtent(_chart.x().domain(), constraint);\n            if (constrained) {\n                _chart.x().domain(constrained);\n            }\n        }\n\n        var domain = _chart.x().domain();\n        var domFilter = dc.filters.RangedFilter(domain[0], domain[1]);\n\n        _chart.replaceFilter(domFilter);\n        _chart.rescale();\n        _chart.redraw();\n\n        if (_rangeChart && !rangesEqual(_chart.filter(), _rangeChart.filter())) {\n            dc.events.trigger(function () {\n                _rangeChart.replaceFilter(domFilter);\n                _rangeChart.redraw();\n            });\n        }\n\n        _chart._invokeZoomedListener();\n\n        dc.events.trigger(function () {\n            _chart.redrawGroup();\n        }, dc.constants.EVENT_DELAY);\n\n        _refocused = !rangesEqual(domain, _xOriginalDomain);\n    }\n\n    function intersectExtents (ext1, ext2) {\n        if (ext1[0] > ext2[1] || ext1[1] < ext2[0]) {\n            console.warn('could not intersect extents');\n        }\n        return [Math.max(ext1[0], ext2[0]), Math.min(ext1[1], ext2[1])];\n    }\n\n    function constrainExtent (extent, constraint) {\n        var size = extent[1] - extent[0];\n        if (extent[0] < constraint[0]) {\n            return [constraint[0], Math.min(constraint[1], dc.utils.add(constraint[0], size, 'millis'))];\n        } else if (extent[1] > constraint[1]) {\n            return [Math.max(constraint[0], dc.utils.subtract(constraint[1], size, 'millis')), constraint[1]];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Zoom this chart to focus on the given range. The given range should be an array containing only\n     * 2 elements (`[start, end]`) defining a range in the x domain. If the range is not given or set\n     * to null, then the zoom will be reset. _For focus to work elasticX has to be turned off;\n     * otherwise focus will be ignored.\n     * @method focus\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @example\n     * chart.on('renderlet', function(chart) {\n     *     // smooth the rendering through event throttling\n     *     dc.events.trigger(function(){\n     *          // focus some other chart to the range selected by user on this chart\n     *          someOtherChart.focus(chart.filter());\n     *     });\n     * })\n     * @param {Array<Number>} [range]\n     */\n    _chart.focus = function (range) {\n        if (hasRangeSelected(range)) {\n            _chart.x().domain(range);\n        } else {\n            _chart.x().domain(_xOriginalDomain);\n        }\n\n        _zoom.x(_chart.x());\n        zoomHandler();\n    };\n\n    _chart.refocused = function () {\n        return _refocused;\n    };\n\n    _chart.focusChart = function (c) {\n        if (!arguments.length) {\n            return _focusChart;\n        }\n        _focusChart = c;\n        _chart.on('filtered', function (chart) {\n            if (!chart.filter()) {\n                dc.events.trigger(function () {\n                    _focusChart.x().domain(_focusChart.xOriginalDomain());\n                });\n            } else if (!rangesEqual(chart.filter(), _focusChart.filter())) {\n                dc.events.trigger(function () {\n                    _focusChart.focus(chart.filter());\n                });\n            }\n        });\n        return _chart;\n    };\n\n    function rangesEqual (range1, range2) {\n        if (!range1 && !range2) {\n            return true;\n        } else if (!range1 || !range2) {\n            return false;\n        } else if (range1.length === 0 && range2.length === 0) {\n            return true;\n        } else if (range1[0].valueOf() === range2[0].valueOf() &&\n            range1[1].valueOf() === range2[1].valueOf()) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Turn on/off the brush-based range filter. When brushing is on then user can drag the mouse\n     * across a chart with a quantitative scale to perform range filtering based on the extent of the\n     * brush, or click on the bars of an ordinal bar chart or slices of a pie chart to filter and\n     * un-filter them. However turning on the brush filter will disable other interactive elements on\n     * the chart such as highlighting, tool tips, and reference lines. Zooming will still be possible\n     * if enabled, but only via scrolling (panning will be disabled.)\n     * @method brushOn\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [brushOn=true]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.brushOn = function (brushOn) {\n        if (!arguments.length) {\n            return _brushOn;\n        }\n        _brushOn = brushOn;\n        return _chart;\n    };\n\n    function hasRangeSelected (range) {\n        return range instanceof Array && range.length > 1;\n    }\n\n    return _chart;\n};\n\n/**\n * Stack Mixin is an mixin that provides cross-chart support of stackability using d3.layout.stack.\n * @name stackMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.stackMixin}\n */\ndc.stackMixin = function (_chart) {\n\n    function prepareValues (layer, layerIdx) {\n        var valAccessor = layer.accessor || _chart.valueAccessor();\n        layer.name = String(layer.name || layerIdx);\n        layer.values = layer.group.all().map(function (d, i) {\n            return {\n                x: _chart.keyAccessor()(d, i),\n                y: layer.hidden ? null : valAccessor(d, i),\n                data: d,\n                layer: layer.name,\n                hidden: layer.hidden\n            };\n        });\n\n        layer.values = layer.values.filter(domainFilter());\n        return layer.values;\n    }\n\n    var _stackLayout = d3.layout.stack()\n        .values(prepareValues);\n\n    var _stack = [];\n    var _titles = {};\n\n    var _hidableStacks = false;\n    var _evadeDomainFilter = false;\n\n    function domainFilter () {\n        if (!_chart.x() || _evadeDomainFilter) {\n            return d3.functor(true);\n        }\n        var xDomain = _chart.x().domain();\n        if (_chart.isOrdinal()) {\n            // TODO #416\n            //var domainSet = d3.set(xDomain);\n            return function () {\n                return true; //domainSet.has(p.x);\n            };\n        }\n        if (_chart.elasticX()) {\n            return function () { return true; };\n        }\n        return function (p) {\n            //return true;\n            return p.x >= xDomain[0] && p.x <= xDomain[xDomain.length - 1];\n        };\n    }\n\n    /**\n     * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks\n     * in the same chart will share the same key accessor and therefore the same set of keys.\n     *\n     * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set\n     * of keys on the x axis, while stacked vertically. If name is specified then it will be used to\n     * generate the legend label.\n     * @method stack\n     * @memberof dc.stackMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}\n     * @example\n     * // stack group using default accessor\n     * chart.stack(valueSumGroup)\n     * // stack group using custom accessor\n     * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});\n     * @param {crossfilter.group} group\n     * @param {String} [name]\n     * @param {Function} [accessor]\n     * @returns {Array<{group: crossfilter.group, name: String, accessor: Function}>|dc.stackMixin}\n     */\n    _chart.stack = function (group, name, accessor) {\n        if (!arguments.length) {\n            return _stack;\n        }\n\n        if (arguments.length <= 2) {\n            accessor = name;\n        }\n\n        var layer = {group: group};\n        if (typeof name === 'string') {\n            layer.name = name;\n        }\n        if (typeof accessor === 'function') {\n            layer.accessor = accessor;\n        }\n        _stack.push(layer);\n\n        return _chart;\n    };\n\n    dc.override(_chart, 'group', function (g, n, f) {\n        if (!arguments.length) {\n            return _chart._group();\n        }\n        _stack = [];\n        _titles = {};\n        _chart.stack(g, n);\n        if (f) {\n            _chart.valueAccessor(f);\n        }\n        return _chart._group(g, n);\n    });\n\n    /**\n     * Allow named stacks to be hidden or shown by clicking on legend items.\n     * This does not affect the behavior of hideStack or showStack.\n     * @method hidableStacks\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {Boolean} [hidableStacks=false]\n     * @returns {Boolean|dc.stackMixin}\n     */\n    _chart.hidableStacks = function (hidableStacks) {\n        if (!arguments.length) {\n            return _hidableStacks;\n        }\n        _hidableStacks = hidableStacks;\n        return _chart;\n    };\n\n    function findLayerByName (n) {\n        var i = _stack.map(dc.pluck('name')).indexOf(n);\n        return _stack[i];\n    }\n\n    /**\n     * Hide all stacks on the chart with the given name.\n     * The chart must be re-rendered for this change to appear.\n     * @method hideStack\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {String} stackName\n     * @returns {dc.stackMixin}\n     */\n    _chart.hideStack = function (stackName) {\n        var layer = findLayerByName(stackName);\n        if (layer) {\n            layer.hidden = true;\n        }\n        return _chart;\n    };\n\n    /**\n     * Show all stacks on the chart with the given name.\n     * The chart must be re-rendered for this change to appear.\n     * @method showStack\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {String} stackName\n     * @returns {dc.stackMixin}\n     */\n    _chart.showStack = function (stackName) {\n        var layer = findLayerByName(stackName);\n        if (layer) {\n            layer.hidden = false;\n        }\n        return _chart;\n    };\n\n    _chart.getValueAccessorByIndex = function (index) {\n        return _stack[index].accessor || _chart.valueAccessor();\n    };\n\n    _chart.yAxisMin = function () {\n        var min = d3.min(flattenStack(), function (p) {\n            return (p.y < 0) ? (p.y + p.y0) : p.y0;\n        });\n\n        return dc.utils.subtract(min, _chart.yAxisPadding());\n\n    };\n\n    _chart.yAxisMax = function () {\n        var max = d3.max(flattenStack(), function (p) {\n            return (p.y > 0) ? (p.y + p.y0) : p.y0;\n        });\n\n        return dc.utils.add(max, _chart.yAxisPadding());\n    };\n\n    function flattenStack () {\n        var valueses = _chart.data().map(function (layer) { return layer.values; });\n        return Array.prototype.concat.apply([], valueses);\n    }\n\n    _chart.xAxisMin = function () {\n        var min = d3.min(flattenStack(), dc.pluck('x'));\n        return dc.utils.subtract(min, _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    };\n\n    _chart.xAxisMax = function () {\n        var max = d3.max(flattenStack(), dc.pluck('x'));\n        return dc.utils.add(max, _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    };\n\n    /**\n     * Set or get the title function. Chart class will use this function to render svg title (usually interpreted by\n     * browser as tooltips) for each child element in the chart, i.e. a slice in a pie chart or a bubble in a bubble chart.\n     * Almost every chart supports title function however in grid coordinate chart you need to turn off brush in order to\n     * use title otherwise the brush layer will block tooltip trigger.\n     *\n     * If the first argument is a stack name, the title function will get or set the title for that stack. If stackName\n     * is not provided, the first stack is implied.\n     * @method title\n     * @memberof dc.stackMixin\n     * @instance\n     * @example\n     * // set a title function on 'first stack'\n     * chart.title('first stack', function(d) { return d.key + ': ' + d.value; });\n     * // get a title function from 'second stack'\n     * var secondTitleFunction = chart.title('second stack');\n     * @param {String} [stackName]\n     * @param {Function} [titleAccessor]\n     * @returns {String|dc.stackMixin}\n     */\n    dc.override(_chart, 'title', function (stackName, titleAccessor) {\n        if (!stackName) {\n            return _chart._title();\n        }\n\n        if (typeof stackName === 'function') {\n            return _chart._title(stackName);\n        }\n        if (stackName === _chart._groupName && typeof titleAccessor === 'function') {\n            return _chart._title(titleAccessor);\n        }\n\n        if (typeof titleAccessor !== 'function') {\n            return _titles[stackName] || _chart._title();\n        }\n\n        _titles[stackName] = titleAccessor;\n\n        return _chart;\n    });\n\n    /**\n     * Gets or sets the stack layout algorithm, which computes a baseline for each stack and\n     * propagates it to the next.\n     * @method stackLayout\n     * @memberof dc.stackMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Stack-Layout.md d3.layout.stack}\n     * @param {Function} [stack=d3.layout.stack]\n     * @returns {Function|dc.stackMixin}\n     */\n    _chart.stackLayout = function (stack) {\n        if (!arguments.length) {\n            return _stackLayout;\n        }\n        _stackLayout = stack;\n        if (_stackLayout.values() === d3.layout.stack().values()) {\n            _stackLayout.values(prepareValues);\n        }\n        return _chart;\n    };\n\n    /**\n     * Since dc.js 2.0, there has been {@link https://github.com/dc-js/dc.js/issues/949 an issue}\n     * where points are filtered to the current domain. While this is a useful optimization, it is\n     * incorrectly implemented: the next point outside the domain is required in order to draw lines\n     * that are clipped to the bounds, as well as bars that are partly clipped.\n     *\n     * A fix will be included in dc.js 2.1.x, but a workaround is needed for dc.js 2.0 and until\n     * that fix is published, so set this flag to skip any filtering of points.\n     *\n     * Once the bug is fixed, this flag will have no effect, and it will be deprecated.\n     * @method evadeDomainFilter\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {Boolean} [evadeDomainFilter=false]\n     * @returns {Boolean|dc.stackMixin}\n     */\n    _chart.evadeDomainFilter = function (evadeDomainFilter) {\n        if (!arguments.length) {\n            return _evadeDomainFilter;\n        }\n        _evadeDomainFilter = evadeDomainFilter;\n        return _chart;\n    };\n\n    function visability (l) {\n        return !l.hidden;\n    }\n\n    _chart.data(function () {\n        var layers = _stack.filter(visability);\n        return layers.length ? _chart.stackLayout()(layers) : [];\n    });\n\n    _chart._ordinalXDomain = function () {\n        var flat = flattenStack().map(dc.pluck('data'));\n        var ordered = _chart._computeOrderedGroups(flat);\n        return ordered.map(_chart.keyAccessor());\n    };\n\n    _chart.colorAccessor(function (d) {\n        var layer = this.layer || this.name || d.name || d.layer;\n        return layer;\n    });\n\n    _chart.legendables = function () {\n        return _stack.map(function (layer, i) {\n            return {\n                chart: _chart,\n                name: layer.name,\n                hidden: layer.hidden || false,\n                color: _chart.getColor.call(layer, layer.values, i)\n            };\n        });\n    };\n\n    _chart.isLegendableHidden = function (d) {\n        var layer = findLayerByName(d.name);\n        return layer ? layer.hidden : false;\n    };\n\n    _chart.legendToggle = function (d) {\n        if (_hidableStacks) {\n            if (_chart.isLegendableHidden(d)) {\n                _chart.showStack(d.name);\n            } else {\n                _chart.hideStack(d.name);\n            }\n            //_chart.redraw();\n            _chart.renderGroup();\n        }\n    };\n\n    return _chart;\n};\n\n/**\n * Cap is a mixin that groups small data elements below a _cap_ into an *others* grouping for both the\n * Row and Pie Charts.\n *\n * The top ordered elements in the group up to the cap amount will be kept in the chart, and the rest\n * will be replaced with an *others* element, with value equal to the sum of the replaced values. The\n * keys of the elements below the cap limit are recorded in order to filter by those keys when the\n * others* element is clicked.\n * @name capMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.capMixin}\n */\ndc.capMixin = function (_chart) {\n    var _cap = Infinity, _takeFront = true;\n    var _othersLabel = 'Others';\n\n    // emulate old group.top(N) ordering\n    _chart.ordering(function (kv) {\n        return -kv.value;\n    });\n\n    var _othersGrouper = function (topItems, restItems) {\n        var restItemsSum = d3.sum(restItems, _chart.valueAccessor()),\n            restKeys = restItems.map(_chart.keyAccessor());\n        if (restItemsSum > 0) {\n            return topItems.concat([{\n                others: restKeys,\n                key: _chart.othersLabel(),\n                value: restItemsSum\n            }]);\n        }\n        return topItems;\n    };\n\n    _chart.cappedKeyAccessor = function (d, i) {\n        if (d.others) {\n            return d.key;\n        }\n        return _chart.keyAccessor()(d, i);\n    };\n\n    _chart.cappedValueAccessor = function (d, i) {\n        if (d.others) {\n            return d.value;\n        }\n        return _chart.valueAccessor()(d, i);\n    };\n\n    // return N \"top\" groups, where N is the cap, sorted by baseMixin.ordering\n    // whether top means front or back depends on takeFront\n    _chart.data(function (group) {\n        if (_cap === Infinity) {\n            return _chart._computeOrderedGroups(group.all());\n        } else {\n            var items = group.all(), rest;\n            items = _chart._computeOrderedGroups(items); // sort by baseMixin.ordering\n\n            if (_cap) {\n                if (_takeFront) {\n                    rest = items.slice(_cap);\n                    items = items.slice(0, _cap);\n                } else {\n                    var start = Math.max(0, items.length - _cap);\n                    rest = items.slice(0, start);\n                    items = items.slice(start);\n                }\n            }\n\n            if (_othersGrouper) {\n                return _othersGrouper(items, rest);\n            }\n            return items;\n        }\n    });\n\n    /**\n     * Get or set the count of elements to that will be included in the cap. If there is an\n     * {@link dc.capMixin#othersGrouper othersGrouper}, any further elements will be combined in an\n     * extra element with its name determined by {@link dc.capMixin#othersLabel othersLabel}.\n     *\n     * As of dc.js 2.1 and onward, the capped charts use\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all()}\n     * and {@link dc.baseMixin#ordering baseMixin.ordering()} to determine the order of\n     * elements. Then `cap` and {@link dc.capMixin#takeFront takeFront} determine how many elements\n     * to keep, from which end of the resulting array.\n     *\n     * **Migration note:** Up through dc.js 2.0.*, capping used\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_top group.top(N)},\n     * which selects the largest items according to\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_order group.order()}.\n     * The chart then sorted the items according to {@link dc.baseMixin#ordering baseMixin.ordering()}.\n     * So the two values essentially had to agree, but if the `group.order()` was incorrect (it's\n     * easy to forget about), the wrong rows or slices would be displayed, in the correct order.\n     *\n     * If your chart previously relied on `group.order()`, use `chart.ordering()` instead. As of\n     * 2.1.5, the ordering defaults to sorting from greatest to least like `group.top(N)` did.\n     *\n     * If you want to cap by one ordering but sort by another, please\n     * [file an issue](https://github.com/dc-js/dc.js/issues/new) - it's still possible but we'll\n     * need to work up an example.\n     * @method cap\n     * @memberof dc.capMixin\n     * @instance\n     * @param {Number} [count=Infinity]\n     * @returns {Number|dc.capMixin}\n     */\n    _chart.cap = function (count) {\n        if (!arguments.length) {\n            return _cap;\n        }\n        _cap = count;\n        return _chart;\n    };\n\n    /**\n     * Get or set the direction of capping. If set, the chart takes the first\n     * {@link dc.capMixin#cap cap} elements from the sorted array of elements; otherwise\n     * it takes the last `cap` elements.\n     * @method takeFront\n     * @memberof dc.capMixin\n     * @instance\n     * @param {Boolean} [takeFront=true]\n     * @returns {Boolean|dc.capMixin}\n     */\n    _chart.takeFront = function (takeFront) {\n        if (!arguments.length) {\n            return _takeFront;\n        }\n        _takeFront = takeFront;\n        return _chart;\n    };\n\n    /**\n     * Get or set the label for *Others* slice when slices cap is specified.\n     * @method othersLabel\n     * @memberof dc.capMixin\n     * @instance\n     * @param {String} [label=\"Others\"]\n     * @returns {String|dc.capMixin}\n     */\n    _chart.othersLabel = function (label) {\n        if (!arguments.length) {\n            return _othersLabel;\n        }\n        _othersLabel = label;\n        return _chart;\n    };\n\n    /**\n     * Get or set the grouper function that will perform the insertion of data for the *Others* slice\n     * if the slices cap is specified. If set to a falsy value, no others will be added.\n     *\n     * The grouper function takes an array of included (\"top\") items, and an array of the rest of\n     * the items. By default the grouper function computes the sum of the rest.\n     * @method othersGrouper\n     * @memberof dc.capMixin\n     * @instance\n     * @example\n     * // Do not show others\n     * chart.othersGrouper(null);\n     * // Default others grouper\n     * chart.othersGrouper(function (topItems, restItems) {\n     *     var restItemsSum = d3.sum(restItems, _chart.valueAccessor()),\n     *         restKeys = restItems.map(_chart.keyAccessor());\n     *     if (restItemsSum > 0) {\n     *         return topItems.concat([{\n     *             others: restKeys,\n     *             key: _chart.othersLabel(),\n     *             value: restItemsSum\n     *         }]);\n     *     }\n     *     return topItems;\n     * });\n     * @param {Function} [grouperFunction]\n     * @returns {Function|dc.capMixin}\n     */\n    _chart.othersGrouper = function (grouperFunction) {\n        if (!arguments.length) {\n            return _othersGrouper;\n        }\n        _othersGrouper = grouperFunction;\n        return _chart;\n    };\n\n    dc.override(_chart, 'onClick', function (d) {\n        if (d.others) {\n            _chart.filter([d.others]);\n        }\n        _chart._onClick(d);\n    });\n\n    return _chart;\n};\n\n/**\n * This Mixin provides reusable functionalities for any chart that needs to visualize data using bubbles.\n * @name bubbleMixin\n * @memberof dc\n * @mixin\n * @mixes dc.colorMixin\n * @param {Object} _chart\n * @returns {dc.bubbleMixin}\n */\ndc.bubbleMixin = function (_chart) {\n    var _maxBubbleRelativeSize = 0.3;\n    var _minRadiusWithLabel = 10;\n    var _sortBubbleSize = false;\n    var _elasticRadius = false;\n\n    _chart.BUBBLE_NODE_CLASS = 'node';\n    _chart.BUBBLE_CLASS = 'bubble';\n    _chart.MIN_RADIUS = 10;\n\n    _chart = dc.colorMixin(_chart);\n\n    _chart.renderLabel(true);\n\n    _chart.data(function (group) {\n        var data = group.all();\n        if (_sortBubbleSize) {\n            // sort descending so smaller bubbles are on top\n            var radiusAccessor = _chart.radiusValueAccessor();\n            data.sort(function (a, b) { return d3.descending(radiusAccessor(a), radiusAccessor(b)); });\n        }\n        return data;\n    });\n\n    var _r = d3.scale.linear().domain([0, 100]);\n\n    var _rValueAccessor = function (d) {\n        return d.r;\n    };\n\n    /**\n     * Get or set the bubble radius scale. By default the bubble chart uses\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md#linear d3.scale.linear().domain([0, 100])}\n     * as its radius scale.\n     * @method r\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @param {d3.scale} [bubbleRadiusScale=d3.scale.linear().domain([0, 100])]\n     * @returns {d3.scale|dc.bubbleMixin}\n     */\n    _chart.r = function (bubbleRadiusScale) {\n        if (!arguments.length) {\n            return _r;\n        }\n        _r = bubbleRadiusScale;\n        return _chart;\n    };\n\n    /**\n     * Turn on or off the elastic bubble radius feature, or return the value of the flag. If this\n     * feature is turned on, then bubble radii will be automatically rescaled to fit the chart better.\n     * @method elasticRadius\n     * @memberof dc.bubbleChart\n     * @instance\n     * @param {Boolean} [elasticRadius=false]\n     * @returns {Boolean|dc.bubbleChart}\n     */\n    _chart.elasticRadius = function (elasticRadius) {\n        if (!arguments.length) {\n            return _elasticRadius;\n        }\n        _elasticRadius = elasticRadius;\n        return _chart;\n    };\n\n    _chart.calculateRadiusDomain = function () {\n        if (_elasticRadius) {\n            _chart.r().domain([_chart.rMin(), _chart.rMax()]);\n        }\n    };\n\n    /**\n     * Get or set the radius value accessor function. If set, the radius value accessor function will\n     * be used to retrieve a data value for each bubble. The data retrieved then will be mapped using\n     * the r scale to the actual bubble radius. This allows you to encode a data dimension using bubble\n     * size.\n     * @method radiusValueAccessor\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Function} [radiusValueAccessor]\n     * @returns {Function|dc.bubbleMixin}\n     */\n    _chart.radiusValueAccessor = function (radiusValueAccessor) {\n        if (!arguments.length) {\n            return _rValueAccessor;\n        }\n        _rValueAccessor = radiusValueAccessor;\n        return _chart;\n    };\n\n    _chart.rMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return _chart.radiusValueAccessor()(e);\n        });\n        return min;\n    };\n\n    _chart.rMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return _chart.radiusValueAccessor()(e);\n        });\n        return max;\n    };\n\n    _chart.bubbleR = function (d) {\n        var value = _chart.radiusValueAccessor()(d);\n        var r = _chart.r()(value);\n        if (isNaN(r) || value <= 0) {\n            r = 0;\n        }\n        return r;\n    };\n\n    var labelFunction = function (d) {\n        return _chart.label()(d);\n    };\n\n    var shouldLabel = function (d) {\n        return (_chart.bubbleR(d) > _minRadiusWithLabel);\n    };\n\n    var labelOpacity = function (d) {\n        return shouldLabel(d) ? 1 : 0;\n    };\n\n    var labelPointerEvent = function (d) {\n        return shouldLabel(d) ? 'all' : 'none';\n    };\n\n    _chart._doRenderLabel = function (bubbleGEnter) {\n        if (_chart.renderLabel()) {\n            var label = bubbleGEnter.select('text');\n\n            if (label.empty()) {\n                label = bubbleGEnter.append('text')\n                    .attr('text-anchor', 'middle')\n                    .attr('dy', '.3em')\n                    .on('click', _chart.onClick);\n            }\n\n            label\n                .attr('opacity', 0)\n                .attr('pointer-events', labelPointerEvent)\n                .text(labelFunction);\n            dc.transition(label, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', labelOpacity);\n        }\n    };\n\n    _chart.doUpdateLabels = function (bubbleGEnter) {\n        if (_chart.renderLabel()) {\n            var labels = bubbleGEnter.select('text')\n                .attr('pointer-events', labelPointerEvent)\n                .text(labelFunction);\n            dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', labelOpacity);\n        }\n    };\n\n    var titleFunction = function (d) {\n        return _chart.title()(d);\n    };\n\n    _chart._doRenderTitles = function (g) {\n        if (_chart.renderTitle()) {\n            var title = g.select('title');\n\n            if (title.empty()) {\n                g.append('title').text(titleFunction);\n            }\n        }\n    };\n\n    _chart.doUpdateTitles = function (g) {\n        if (_chart.renderTitle()) {\n            g.select('title').text(titleFunction);\n        }\n    };\n\n    /**\n     * Turn on or off the bubble sorting feature, or return the value of the flag. If enabled,\n     * bubbles will be sorted by their radius, with smaller bubbles in front.\n     * @method sortBubbleSize\n     * @memberof dc.bubbleChart\n     * @instance\n     * @param {Boolean} [sortBubbleSize=false]\n     * @returns {Boolean|dc.bubbleChart}\n     */\n    _chart.sortBubbleSize = function (sortBubbleSize) {\n        if (!arguments.length) {\n            return _sortBubbleSize;\n        }\n        _sortBubbleSize = sortBubbleSize;\n        return _chart;\n    };\n\n    /**\n     * Get or set the minimum radius. This will be used to initialize the radius scale's range.\n     * @method minRadius\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Number} [radius=10]\n     * @returns {Number|dc.bubbleMixin}\n     */\n    _chart.minRadius = function (radius) {\n        if (!arguments.length) {\n            return _chart.MIN_RADIUS;\n        }\n        _chart.MIN_RADIUS = radius;\n        return _chart;\n    };\n\n    /**\n     * Get or set the minimum radius for label rendering. If a bubble's radius is less than this value\n     * then no label will be rendered.\n     * @method minRadiusWithLabel\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Number} [radius=10]\n     * @returns {Number|dc.bubbleMixin}\n     */\n\n    _chart.minRadiusWithLabel = function (radius) {\n        if (!arguments.length) {\n            return _minRadiusWithLabel;\n        }\n        _minRadiusWithLabel = radius;\n        return _chart;\n    };\n\n    /**\n     * Get or set the maximum relative size of a bubble to the length of x axis. This value is useful\n     * when the difference in radius between bubbles is too great.\n     * @method maxBubbleRelativeSize\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Number} [relativeSize=0.3]\n     * @returns {Number|dc.bubbleMixin}\n     */\n    _chart.maxBubbleRelativeSize = function (relativeSize) {\n        if (!arguments.length) {\n            return _maxBubbleRelativeSize;\n        }\n        _maxBubbleRelativeSize = relativeSize;\n        return _chart;\n    };\n\n    _chart.fadeDeselectedArea = function () {\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.' + _chart.BUBBLE_NODE_CLASS).each(function (d) {\n                if (_chart.isSelectedNode(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.' + _chart.BUBBLE_NODE_CLASS).each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(d.key);\n    };\n\n    _chart.onClick = function (d) {\n        var filter = d.key;\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    return _chart;\n};\n\n/**\n * The pie chart implementation is usually used to visualize a small categorical distribution.  The pie\n * chart uses keyAccessor to determine the slices, and valueAccessor to calculate the size of each\n * slice relative to the sum of all values. Slices are ordered by {@link dc.baseMixin#ordering ordering}\n * which defaults to sorting by key.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * @class pieChart\n * @memberof dc\n * @mixes dc.capMixin\n * @mixes dc.colorMixin\n * @mixes dc.baseMixin\n * @example\n * // create a pie chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.pieChart('#chart-container1');\n * // create a pie chart under #chart-container2 element using chart group A\n * var chart2 = dc.pieChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.pieChart}\n */\ndc.pieChart = function (parent, chartGroup) {\n    var DEFAULT_MIN_ANGLE_FOR_LABEL = 0.5;\n\n    var _sliceCssClass = 'pie-slice';\n    var _labelCssClass = 'pie-label';\n    var _sliceGroupCssClass = 'pie-slice-group';\n    var _labelGroupCssClass = 'pie-label-group';\n    var _emptyCssClass = 'empty-chart';\n    var _emptyTitle = 'empty';\n\n    var _radius,\n        _givenRadius, // specified radius, if any\n        _innerRadius = 0,\n        _externalRadiusPadding = 0;\n\n    var _g;\n    var _cx;\n    var _cy;\n    var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;\n    var _externalLabelRadius;\n    var _drawPaths = false;\n    var _chart = dc.capMixin(dc.colorMixin(dc.baseMixin({})));\n\n    _chart.colorAccessor(_chart.cappedKeyAccessor);\n\n    _chart.title(function (d) {\n        return _chart.cappedKeyAccessor(d) + ': ' + _chart.cappedValueAccessor(d);\n    });\n\n    /**\n     * Get or set the maximum number of slices the pie chart will generate. The top slices are determined by\n     * value from high to low. Other slices exeeding the cap will be rolled up into one single *Others* slice.\n     * @method slicesCap\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [cap]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.slicesCap = _chart.cap;\n\n    _chart.label(_chart.cappedKeyAccessor);\n    _chart.renderLabel(true);\n\n    _chart.transitionDuration(350);\n    _chart.transitionDelay(0);\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _g = _chart.svg()\n            .append('g')\n            .attr('transform', 'translate(' + _chart.cx() + ',' + _chart.cy() + ')');\n\n        _g.append('g').attr('class', _sliceGroupCssClass);\n        _g.append('g').attr('class', _labelGroupCssClass);\n\n        drawChart();\n\n        return _chart;\n    };\n\n    function drawChart () {\n        // set radius from chart size if none given, or if given radius is too large\n        var maxRadius =  d3.min([_chart.width(), _chart.height()]) / 2;\n        _radius = _givenRadius && _givenRadius < maxRadius ? _givenRadius : maxRadius;\n\n        var arc = buildArcs();\n\n        var pie = pieLayout();\n        var pieData;\n        // if we have data...\n        if (d3.sum(_chart.data(), _chart.valueAccessor())) {\n            pieData = pie(_chart.data());\n            _g.classed(_emptyCssClass, false);\n        } else {\n            // otherwise we'd be getting NaNs, so override\n            // note: abuse others for its ignoring the value accessor\n            pieData = pie([{key: _emptyTitle, value: 1, others: [_emptyTitle]}]);\n            _g.classed(_emptyCssClass, true);\n        }\n\n        if (_g) {\n            var slices = _g.select('g.' + _sliceGroupCssClass)\n                .selectAll('g.' + _sliceCssClass)\n                .data(pieData);\n\n            var labels = _g.select('g.' + _labelGroupCssClass)\n                .selectAll('text.' + _labelCssClass)\n                .data(pieData);\n\n            createElements(slices, labels, arc, pieData);\n\n            updateElements(pieData, arc);\n\n            removeElements(slices, labels);\n\n            highlightFilter();\n\n            dc.transition(_g, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('transform', 'translate(' + _chart.cx() + ',' + _chart.cy() + ')');\n        }\n    }\n\n    function createElements (slices, labels, arc, pieData) {\n        var slicesEnter = createSliceNodes(slices);\n\n        createSlicePath(slicesEnter, arc);\n\n        createTitles(slicesEnter);\n\n        createLabels(labels, pieData, arc);\n    }\n\n    function createSliceNodes (slices) {\n        var slicesEnter = slices\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return _sliceCssClass + ' _' + i;\n            });\n        return slicesEnter;\n    }\n\n    function createSlicePath (slicesEnter, arc) {\n        var slicePath = slicesEnter.append('path')\n            .attr('fill', fill)\n            .on('click', onClick)\n            .attr('d', function (d, i) {\n                return safeArc(d, i, arc);\n            });\n\n        var transition = dc.transition(slicePath, _chart.transitionDuration(), _chart.transitionDelay());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenPie);\n        }\n    }\n\n    function createTitles (slicesEnter) {\n        if (_chart.renderTitle()) {\n            slicesEnter.append('title').text(function (d) {\n                return _chart.title()(d.data);\n            });\n        }\n    }\n\n    _chart._applyLabelText = function (labels) {\n        labels\n            .text(function (d) {\n                var data = d.data;\n                if ((sliceHasNoData(data) || sliceTooSmall(d)) && !isSelectedSlice(d)) {\n                    return '';\n                }\n                return _chart.label()(d.data);\n            });\n    };\n\n    function positionLabels (labels, arc) {\n        _chart._applyLabelText(labels);\n        dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', function (d) {\n                return labelPosition(d, arc);\n            })\n            .attr('text-anchor', 'middle');\n    }\n\n    function highlightSlice (i, whether) {\n        _chart.select('g.pie-slice._' + i)\n            .classed('highlight', whether);\n    }\n\n    function createLabels (labels, pieData, arc) {\n        if (_chart.renderLabel()) {\n            var labelsEnter = labels\n                .enter()\n                .append('text')\n                .attr('class', function (d, i) {\n                    var classes = _sliceCssClass + ' ' + _labelCssClass + ' _' + i;\n                    if (_externalLabelRadius) {\n                        classes += ' external';\n                    }\n                    return classes;\n                })\n                .on('click', onClick)\n                .on('mouseover', function (d, i) {\n                    highlightSlice(i, true);\n                })\n                .on('mouseout', function (d, i) {\n                    highlightSlice(i, false);\n                });\n            positionLabels(labelsEnter, arc);\n            if (_externalLabelRadius && _drawPaths) {\n                updateLabelPaths(pieData, arc);\n            }\n        }\n    }\n\n    function updateLabelPaths (pieData, arc) {\n        var polyline = _g.selectAll('polyline.' + _sliceCssClass)\n                .data(pieData);\n\n        polyline\n                .enter()\n                .append('polyline')\n                .attr('class', function (d, i) {\n                    return 'pie-path _' + i + ' ' + _sliceCssClass;\n                })\n                .on('click', onClick)\n                .on('mouseover', function (d, i) {\n                    highlightSlice(i, true);\n                })\n                .on('mouseout', function (d, i) {\n                    highlightSlice(i, false);\n                });\n\n        polyline.exit().remove();\n        var arc2 = d3.svg.arc()\n                .outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius)\n                .innerRadius(_radius - _externalRadiusPadding);\n        var transition = dc.transition(polyline, _chart.transitionDuration(), _chart.transitionDelay());\n        // this is one rare case where d3.selection differs from d3.transition\n        if (transition.attrTween) {\n            transition\n                .attrTween('points', function (d) {\n                    var current = this._current || d;\n                    current = {startAngle: current.startAngle, endAngle: current.endAngle};\n                    var interpolate = d3.interpolate(current, d);\n                    this._current = interpolate(0);\n                    return function (t) {\n                        var d2 = interpolate(t);\n                        return [arc.centroid(d2), arc2.centroid(d2)];\n                    };\n                });\n        } else {\n            transition.attr('points', function (d) {\n                return [arc.centroid(d), arc2.centroid(d)];\n            });\n        }\n        transition.style('visibility', function (d) {\n            return d.endAngle - d.startAngle < 0.0001 ? 'hidden' : 'visible';\n        });\n\n    }\n\n    function updateElements (pieData, arc) {\n        updateSlicePaths(pieData, arc);\n        updateLabels(pieData, arc);\n        updateTitles(pieData);\n    }\n\n    function updateSlicePaths (pieData, arc) {\n        var slicePaths = _g.selectAll('g.' + _sliceCssClass)\n            .data(pieData)\n            .select('path')\n            .attr('d', function (d, i) {\n                return safeArc(d, i, arc);\n            });\n        var transition = dc.transition(slicePaths, _chart.transitionDuration(), _chart.transitionDelay());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenPie);\n        }\n        transition.attr('fill', fill);\n    }\n\n    function updateLabels (pieData, arc) {\n        if (_chart.renderLabel()) {\n            var labels = _g.selectAll('text.' + _labelCssClass)\n                .data(pieData);\n            positionLabels(labels, arc);\n            if (_externalLabelRadius && _drawPaths) {\n                updateLabelPaths(pieData, arc);\n            }\n        }\n    }\n\n    function updateTitles (pieData) {\n        if (_chart.renderTitle()) {\n            _g.selectAll('g.' + _sliceCssClass)\n                .data(pieData)\n                .select('title')\n                .text(function (d) {\n                    return _chart.title()(d.data);\n                });\n        }\n    }\n\n    function removeElements (slices, labels) {\n        slices.exit().remove();\n        labels.exit().remove();\n    }\n\n    function highlightFilter () {\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.' + _sliceCssClass).each(function (d) {\n                if (isSelectedSlice(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.' + _sliceCssClass).each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    }\n\n    /**\n     * Get or set the external radius padding of the pie chart. This will force the radius of the\n     * pie chart to become smaller or larger depending on the value.\n     * @method externalRadiusPadding\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [externalRadiusPadding=0]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.externalRadiusPadding = function (externalRadiusPadding) {\n        if (!arguments.length) {\n            return _externalRadiusPadding;\n        }\n        _externalRadiusPadding = externalRadiusPadding;\n        return _chart;\n    };\n\n    /**\n     * Get or set the inner radius of the pie chart. If the inner radius is greater than 0px then the\n     * pie chart will be rendered as a doughnut chart.\n     * @method innerRadius\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [innerRadius=0]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.innerRadius = function (innerRadius) {\n        if (!arguments.length) {\n            return _innerRadius;\n        }\n        _innerRadius = innerRadius;\n        return _chart;\n    };\n\n    /**\n     * Get or set the outer radius. If the radius is not set, it will be half of the minimum of the\n     * chart width and height.\n     * @method radius\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [radius]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.radius = function (radius) {\n        if (!arguments.length) {\n            return _givenRadius;\n        }\n        _givenRadius = radius;\n        return _chart;\n    };\n\n    /**\n     * Get or set center x coordinate position. Default is center of svg.\n     * @method cx\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [cx]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.cx = function (cx) {\n        if (!arguments.length) {\n            return (_cx ||  _chart.width() / 2);\n        }\n        _cx = cx;\n        return _chart;\n    };\n\n    /**\n     * Get or set center y coordinate position. Default is center of svg.\n     * @method cy\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [cy]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.cy = function (cy) {\n        if (!arguments.length) {\n            return (_cy ||  _chart.height() / 2);\n        }\n        _cy = cy;\n        return _chart;\n    };\n\n    function buildArcs () {\n        return d3.svg.arc()\n            .outerRadius(_radius - _externalRadiusPadding)\n            .innerRadius(_innerRadius);\n    }\n\n    function isSelectedSlice (d) {\n        return _chart.hasFilter(_chart.cappedKeyAccessor(d.data));\n    }\n\n    _chart._doRedraw = function () {\n        drawChart();\n        return _chart;\n    };\n\n    /**\n     * Get or set the minimal slice angle for label rendering. Any slice with a smaller angle will not\n     * display a slice label.\n     * @method minAngleForLabel\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [minAngleForLabel=0.5]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.minAngleForLabel = function (minAngleForLabel) {\n        if (!arguments.length) {\n            return _minAngleForLabel;\n        }\n        _minAngleForLabel = minAngleForLabel;\n        return _chart;\n    };\n\n    function pieLayout () {\n        return d3.layout.pie().sort(null).value(_chart.cappedValueAccessor);\n    }\n\n    function sliceTooSmall (d) {\n        var angle = (d.endAngle - d.startAngle);\n        return isNaN(angle) || angle < _minAngleForLabel;\n    }\n\n    function sliceHasNoData (d) {\n        return _chart.cappedValueAccessor(d) === 0;\n    }\n\n    function tweenPie (b) {\n        b.innerRadius = _innerRadius;\n        var current = this._current;\n        if (isOffCanvas(current)) {\n            current = {startAngle: 0, endAngle: 0};\n        } else {\n            // only interpolate startAngle & endAngle, not the whole data object\n            current = {startAngle: current.startAngle, endAngle: current.endAngle};\n        }\n        var i = d3.interpolate(current, b);\n        this._current = i(0);\n        return function (t) {\n            return safeArc(i(t), 0, buildArcs());\n        };\n    }\n\n    function isOffCanvas (current) {\n        return !current || isNaN(current.startAngle) || isNaN(current.endAngle);\n    }\n\n    function fill (d, i) {\n        return _chart.getColor(d.data, i);\n    }\n\n    function onClick (d, i) {\n        if (_g.attr('class') !== _emptyCssClass) {\n            _chart.onClick(d.data, i);\n        }\n    }\n\n    function safeArc (d, i, arc) {\n        var path = arc(d, i);\n        if (path.indexOf('NaN') >= 0) {\n            path = 'M0,0';\n        }\n        return path;\n    }\n\n    /**\n     * Title to use for the only slice when there is no data.\n     * @method emptyTitle\n     * @memberof dc.pieChart\n     * @instance\n     * @param {String} [title]\n     * @returns {String|dc.pieChart}\n     */\n    _chart.emptyTitle = function (title) {\n        if (arguments.length === 0) {\n            return _emptyTitle;\n        }\n        _emptyTitle = title;\n        return _chart;\n    };\n\n    /**\n     * Position slice labels offset from the outer edge of the chart.\n     *\n     * The argument specifies the extra radius to be added for slice labels.\n     * @method externalLabels\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [externalLabelRadius]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.externalLabels = function (externalLabelRadius) {\n        if (arguments.length === 0) {\n            return _externalLabelRadius;\n        } else if (externalLabelRadius) {\n            _externalLabelRadius = externalLabelRadius;\n        } else {\n            _externalLabelRadius = undefined;\n        }\n\n        return _chart;\n    };\n\n    /**\n     * Get or set whether to draw lines from pie slices to their labels.\n     *\n     * @method drawPaths\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Boolean} [drawPaths]\n     * @returns {Boolean|dc.pieChart}\n     */\n    _chart.drawPaths = function (drawPaths) {\n        if (arguments.length === 0) {\n            return _drawPaths;\n        }\n        _drawPaths = drawPaths;\n        return _chart;\n    };\n\n    function labelPosition (d, arc) {\n        var centroid;\n        if (_externalLabelRadius) {\n            centroid = d3.svg.arc()\n                .outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius)\n                .innerRadius(_radius - _externalRadiusPadding + _externalLabelRadius)\n                .centroid(d);\n        } else {\n            centroid = arc.centroid(d);\n        }\n        if (isNaN(centroid[0]) || isNaN(centroid[1])) {\n            return 'translate(0,0)';\n        } else {\n            return 'translate(' + centroid + ')';\n        }\n    }\n\n    _chart.legendables = function () {\n        return _chart.data().map(function (d, i) {\n            var legendable = {name: d.key, data: d.value, others: d.others, chart: _chart};\n            legendable.color = _chart.getColor(d, i);\n            return legendable;\n        });\n    };\n\n    _chart.legendHighlight = function (d) {\n        highlightSliceFromLegendable(d, true);\n    };\n\n    _chart.legendReset = function (d) {\n        highlightSliceFromLegendable(d, false);\n    };\n\n    _chart.legendToggle = function (d) {\n        _chart.onClick({key: d.name, others: d.others});\n    };\n\n    function highlightSliceFromLegendable (legendable, highlighted) {\n        _chart.selectAll('g.pie-slice').each(function (d) {\n            if (legendable.name === d.data.key) {\n                d3.select(this).classed('highlight', highlighted);\n            }\n        });\n    }\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Concrete bar chart/histogram implementation.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class barChart\n * @memberof dc\n * @mixes dc.stackMixin\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a bar chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.barChart('#chart-container1');\n * // create a bar chart under #chart-container2 element using chart group A\n * var chart2 = dc.barChart('#chart-container2', 'chartGroupA');\n * // create a sub-chart under a composite parent chart\n * var chart3 = dc.barChart(compositeChart);\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}\n * specifying a dom block element such as a div; or a dom element or d3 selection.  If the bar\n * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent\n * composite chart instance instead.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.barChart}\n */\ndc.barChart = function (parent, chartGroup) {\n    var MIN_BAR_WIDTH = 1;\n    var DEFAULT_GAP_BETWEEN_BARS = 2;\n    var LABEL_PADDING = 3;\n\n    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));\n\n    var _gap = DEFAULT_GAP_BETWEEN_BARS;\n    var _centerBar = false;\n    var _alwaysUseRounding = false;\n\n    var _barWidth;\n\n    dc.override(_chart, 'rescale', function () {\n        _chart._rescale();\n        _barWidth = undefined;\n        return _chart;\n    });\n\n    dc.override(_chart, 'render', function () {\n        if (_chart.round() && _centerBar && !_alwaysUseRounding) {\n            dc.logger.warn('By default, brush rounding is disabled if bars are centered. ' +\n                         'See dc.js bar chart API documentation for details.');\n        }\n\n        return _chart._render();\n    });\n\n    _chart.label(function (d) {\n        return dc.utils.printSingleValue(d.y0 + d.y);\n    }, false);\n\n    _chart.plotData = function () {\n        var layers = _chart.chartBodyG().selectAll('g.stack')\n            .data(_chart.data());\n\n        calculateBarWidth();\n\n        layers\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return 'stack ' + '_' + i;\n            });\n\n        var last = layers.size() - 1;\n        layers.each(function (d, i) {\n            var layer = d3.select(this);\n\n            renderBars(layer, i, d);\n\n            if (_chart.renderLabel() && last === i) {\n                renderLabels(layer, i, d);\n            }\n        });\n    };\n\n    function barHeight (d) {\n        return dc.utils.safeNumber(Math.abs(_chart.y()(d.y + d.y0) - _chart.y()(d.y0)));\n    }\n\n    function renderLabels (layer, layerIndex, d) {\n        var labels = layer.selectAll('text.barLabel')\n            .data(d.values, dc.pluck('x'));\n\n        labels.enter()\n            .append('text')\n            .attr('class', 'barLabel')\n            .attr('text-anchor', 'middle');\n\n        if (_chart.isOrdinal()) {\n            labels.on('click', _chart.onClick);\n            labels.attr('cursor', 'pointer');\n        }\n\n        dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d) {\n                var x = _chart.x()(d.x);\n                if (!_centerBar) {\n                    x += _barWidth / 2;\n                }\n                return dc.utils.safeNumber(x);\n            })\n            .attr('y', function (d) {\n                var y = _chart.y()(d.y + d.y0);\n\n                if (d.y < 0) {\n                    y -= barHeight(d);\n                }\n\n                return dc.utils.safeNumber(y - LABEL_PADDING);\n            })\n            .text(function (d) {\n                return _chart.label()(d);\n            });\n\n        dc.transition(labels.exit(), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('height', 0)\n            .remove();\n    }\n\n    function renderBars (layer, layerIndex, d) {\n        var bars = layer.selectAll('rect.bar')\n            .data(d.values, dc.pluck('x'));\n\n        var enter = bars.enter()\n            .append('rect')\n            .attr('class', 'bar')\n            .attr('fill', dc.pluck('data', _chart.getColor))\n            .attr('y', _chart.yAxisHeight())\n            .attr('height', 0);\n\n        if (_chart.renderTitle()) {\n            enter.append('title').text(dc.pluck('data', _chart.title(d.name)));\n        }\n\n        if (_chart.isOrdinal()) {\n            bars.on('click', _chart.onClick);\n        }\n\n        dc.transition(bars, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d) {\n                var x = _chart.x()(d.x);\n                if (_centerBar) {\n                    x -= _barWidth / 2;\n                }\n                if (_chart.isOrdinal() && _gap !== undefined) {\n                    x += _gap / 2;\n                }\n                return dc.utils.safeNumber(x);\n            })\n            .attr('y', function (d) {\n                var y = _chart.y()(d.y + d.y0);\n\n                if (d.y < 0) {\n                    y -= barHeight(d);\n                }\n\n                return dc.utils.safeNumber(y);\n            })\n            .attr('width', _barWidth)\n            .attr('height', function (d) {\n                return barHeight(d);\n            })\n            .attr('fill', dc.pluck('data', _chart.getColor))\n            .select('title').text(dc.pluck('data', _chart.title(d.name)));\n\n        dc.transition(bars.exit(), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d) { return _chart.x()(d.x); })\n            .attr('width', _barWidth * 0.9)\n            .remove();\n    }\n\n    function calculateBarWidth () {\n        if (_barWidth === undefined) {\n            var numberOfBars = _chart.xUnitCount();\n\n            // please can't we always use rangeBands for bar charts?\n            if (_chart.isOrdinal() && _gap === undefined) {\n                _barWidth = Math.floor(_chart.x().rangeBand());\n            } else if (_gap) {\n                _barWidth = Math.floor((_chart.xAxisLength() - (numberOfBars - 1) * _gap) / numberOfBars);\n            } else {\n                _barWidth = Math.floor(_chart.xAxisLength() / (1 + _chart.barPadding()) / numberOfBars);\n            }\n\n            if (_barWidth === Infinity || isNaN(_barWidth) || _barWidth < MIN_BAR_WIDTH) {\n                _barWidth = MIN_BAR_WIDTH;\n            }\n        }\n    }\n\n    _chart.fadeDeselectedArea = function () {\n        var bars = _chart.chartBodyG().selectAll('rect.bar');\n        var extent = _chart.brush().extent();\n\n        if (_chart.isOrdinal()) {\n            if (_chart.hasFilter()) {\n                bars.classed(dc.constants.SELECTED_CLASS, function (d) {\n                    return _chart.hasFilter(d.x);\n                });\n                bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n                    return !_chart.hasFilter(d.x);\n                });\n            } else {\n                bars.classed(dc.constants.SELECTED_CLASS, false);\n                bars.classed(dc.constants.DESELECTED_CLASS, false);\n            }\n        } else {\n            if (!_chart.brushIsEmpty(extent)) {\n                var start = extent[0];\n                var end = extent[1];\n\n                bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n                    return d.x < start || d.x >= end;\n                });\n            } else {\n                bars.classed(dc.constants.DESELECTED_CLASS, false);\n            }\n        }\n    };\n\n    /**\n     * Whether the bar chart will render each bar centered around the data position on the x-axis.\n     * @method centerBar\n     * @memberof dc.barChart\n     * @instance\n     * @param {Boolean} [centerBar=false]\n     * @returns {Boolean|dc.barChart}\n     */\n    _chart.centerBar = function (centerBar) {\n        if (!arguments.length) {\n            return _centerBar;\n        }\n        _centerBar = centerBar;\n        return _chart;\n    };\n\n    dc.override(_chart, 'onClick', function (d) {\n        _chart._onClick(d.data);\n    });\n\n    /**\n     * Get or set the spacing between bars as a fraction of bar size. Valid values are between 0-1.\n     * Setting this value will also remove any previously set {@link dc.barChart#gap gap}. See the\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3 docs}\n     * for a visual description of how the padding is applied.\n     * @method barPadding\n     * @memberof dc.barChart\n     * @instance\n     * @param {Number} [barPadding=0]\n     * @returns {Number|dc.barChart}\n     */\n    _chart.barPadding = function (barPadding) {\n        if (!arguments.length) {\n            return _chart._rangeBandPadding();\n        }\n        _chart._rangeBandPadding(barPadding);\n        _gap = undefined;\n        return _chart;\n    };\n\n    _chart._useOuterPadding = function () {\n        return _gap === undefined;\n    };\n\n    /**\n     * Get or set the outer padding on an ordinal bar chart. This setting has no effect on non-ordinal charts.\n     * Will pad the width by `padding * barWidth` on each side of the chart.\n     * @method outerPadding\n     * @memberof dc.barChart\n     * @instance\n     * @param {Number} [padding=0.5]\n     * @returns {Number|dc.barChart}\n     */\n    _chart.outerPadding = _chart._outerRangeBandPadding;\n\n    /**\n     * Manually set fixed gap (in px) between bars instead of relying on the default auto-generated\n     * gap.  By default the bar chart implementation will calculate and set the gap automatically\n     * based on the number of data points and the length of the x axis.\n     * @method gap\n     * @memberof dc.barChart\n     * @instance\n     * @param {Number} [gap=2]\n     * @returns {Number|dc.barChart}\n     */\n    _chart.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _chart;\n    };\n\n    _chart.extendBrush = function () {\n        var extent = _chart.brush().extent();\n        if (_chart.round() && (!_centerBar || _alwaysUseRounding)) {\n            extent[0] = extent.map(_chart.round())[0];\n            extent[1] = extent.map(_chart.round())[1];\n\n            _chart.chartBodyG().select('.brush')\n                .call(_chart.brush().extent(extent));\n        }\n\n        return extent;\n    };\n\n    /**\n     * Set or get whether rounding is enabled when bars are centered. If false, using\n     * rounding with centered bars will result in a warning and rounding will be ignored.  This flag\n     * has no effect if bars are not {@link dc.barChart#centerBar centered}.\n     * When using standard d3.js rounding methods, the brush often doesn't align correctly with\n     * centered bars since the bars are offset.  The rounding function must add an offset to\n     * compensate, such as in the following example.\n     * @method alwaysUseRounding\n     * @memberof dc.barChart\n     * @instance\n     * @example\n     * chart.round(function(n) { return Math.floor(n) + 0.5; });\n     * @param {Boolean} [alwaysUseRounding=false]\n     * @returns {Boolean|dc.barChart}\n     */\n    _chart.alwaysUseRounding = function (alwaysUseRounding) {\n        if (!arguments.length) {\n            return _alwaysUseRounding;\n        }\n        _alwaysUseRounding = alwaysUseRounding;\n        return _chart;\n    };\n\n    function colorFilter (color, inv) {\n        return function () {\n            var item = d3.select(this);\n            var match = item.attr('fill') === color;\n            return inv ? !match : match;\n        };\n    }\n\n    _chart.legendHighlight = function (d) {\n        if (!_chart.isLegendableHidden(d)) {\n            _chart.g().selectAll('rect.bar')\n                .classed('highlight', colorFilter(d.color))\n                .classed('fadeout', colorFilter(d.color, true));\n        }\n    };\n\n    _chart.legendReset = function () {\n        _chart.g().selectAll('rect.bar')\n            .classed('highlight', false)\n            .classed('fadeout', false);\n    };\n\n    dc.override(_chart, 'xAxisMax', function () {\n        var max = this._xAxisMax();\n        if ('resolution' in _chart.xUnits()) {\n            var res = _chart.xUnits().resolution;\n            max += res;\n        }\n        return max;\n    });\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Concrete line/area chart implementation.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class lineChart\n * @memberof dc\n * @mixes dc.stackMixin\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a line chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.lineChart('#chart-container1');\n * // create a line chart under #chart-container2 element using chart group A\n * var chart2 = dc.lineChart('#chart-container2', 'chartGroupA');\n * // create a sub-chart under a composite parent chart\n * var chart3 = dc.lineChart(compositeChart);\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}\n * specifying a dom block element such as a div; or a dom element or d3 selection.  If the line\n * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent\n * composite chart instance instead.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.lineChart}\n */\ndc.lineChart = function (parent, chartGroup) {\n    var DEFAULT_DOT_RADIUS = 5;\n    var TOOLTIP_G_CLASS = 'dc-tooltip';\n    var DOT_CIRCLE_CLASS = 'dot';\n    var Y_AXIS_REF_LINE_CLASS = 'yRef';\n    var X_AXIS_REF_LINE_CLASS = 'xRef';\n    var DEFAULT_DOT_OPACITY = 1e-6;\n    var LABEL_PADDING = 3;\n\n    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));\n    var _renderArea = false;\n    var _dotRadius = DEFAULT_DOT_RADIUS;\n    var _dataPointRadius = null;\n    var _dataPointFillOpacity = DEFAULT_DOT_OPACITY;\n    var _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;\n    var _interpolate = 'linear';\n    var _tension = 0.7;\n    var _defined;\n    var _dashStyle;\n    var _xyTipsOn = true;\n\n    _chart.transitionDuration(500);\n    _chart.transitionDelay(0);\n    _chart._rangeBandPadding(1);\n\n    _chart.plotData = function () {\n        var chartBody = _chart.chartBodyG();\n        var layersList = chartBody.select('g.stack-list');\n\n        if (layersList.empty()) {\n            layersList = chartBody.append('g').attr('class', 'stack-list');\n        }\n\n        var layers = layersList.selectAll('g.stack').data(_chart.data());\n\n        var layersEnter = layers\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return 'stack ' + '_' + i;\n            });\n\n        drawLine(layersEnter, layers);\n\n        drawArea(layersEnter, layers);\n\n        drawDots(chartBody, layers);\n\n        if (_chart.renderLabel()) {\n            drawLabels(layers);\n        }\n    };\n\n    /**\n     * Gets or sets the interpolator to use for lines drawn, by string name, allowing e.g. step\n     * functions, splines, and cubic interpolation.  This is passed to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate} and\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate},\n     * where you can find a complete list of valid arguments.\n     * @method interpolate\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate}\n     * @param  {String} [interpolate='linear']\n     * @returns {String|dc.lineChart}\n     */\n    _chart.interpolate = function (interpolate) {\n        if (!arguments.length) {\n            return _interpolate;\n        }\n        _interpolate = interpolate;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the tension to use for lines drawn, in the range 0 to 1.\n     * This parameter further customizes the interpolation behavior.  It is passed to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_tension d3.svg.line.tension} and\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_tension d3.svg.area.tension}.\n     * @method tension\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate}\n     * @param  {Number} [tension=0.7]\n     * @returns {Number|dc.lineChart}\n     */\n    _chart.tension = function (tension) {\n        if (!arguments.length) {\n            return _tension;\n        }\n        _tension = tension;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets a function that will determine discontinuities in the line which should be\n     * skipped: the path will be broken into separate subpaths if some points are undefined.\n     * This function is passed to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_defined d3.svg.line.defined}\n     *\n     * Note: crossfilter will sometimes coerce nulls to 0, so you may need to carefully write\n     * custom reduce functions to get this to work, depending on your data. See\n     * {@link https://github.com/dc-js/dc.js/issues/615#issuecomment-49089248 this GitHub comment}\n     * for more details and an example.\n     * @method defined\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_defined d3.svg.line.defined}\n     * @param  {Function} [defined]\n     * @returns {Function|dc.lineChart}\n     */\n    _chart.defined = function (defined) {\n        if (!arguments.length) {\n            return _defined;\n        }\n        _defined = defined;\n        return _chart;\n    };\n\n    /**\n     * Set the line's d3 dashstyle. This value becomes the 'stroke-dasharray' of line. Defaults to empty\n     * array (solid line).\n     * @method dashStyle\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray stroke-dasharray}\n     * @example\n     * // create a Dash Dot Dot Dot\n     * chart.dashStyle([3,1,1,1]);\n     * @param  {Array<Number>} [dashStyle=[]]\n     * @returns {Array<Number>|dc.lineChart}\n     */\n    _chart.dashStyle = function (dashStyle) {\n        if (!arguments.length) {\n            return _dashStyle;\n        }\n        _dashStyle = dashStyle;\n        return _chart;\n    };\n\n    /**\n     * Get or set render area flag. If the flag is set to true then the chart will render the area\n     * beneath each line and the line chart effectively becomes an area chart.\n     * @method renderArea\n     * @memberof dc.lineChart\n     * @instance\n     * @param  {Boolean} [renderArea=false]\n     * @returns {Boolean|dc.lineChart}\n     */\n    _chart.renderArea = function (renderArea) {\n        if (!arguments.length) {\n            return _renderArea;\n        }\n        _renderArea = renderArea;\n        return _chart;\n    };\n\n    function colors (d, i) {\n        return _chart.getColor.call(d, d.values, i);\n    }\n\n    function drawLine (layersEnter, layers) {\n        var line = d3.svg.line()\n            .x(function (d) {\n                return _chart.x()(d.x);\n            })\n            .y(function (d) {\n                return _chart.y()(d.y + d.y0);\n            })\n            .interpolate(_interpolate)\n            .tension(_tension);\n        if (_defined) {\n            line.defined(_defined);\n        }\n\n        var path = layersEnter.append('path')\n            .attr('class', 'line')\n            .attr('stroke', colors);\n        if (_dashStyle) {\n            path.attr('stroke-dasharray', _dashStyle);\n        }\n\n        dc.transition(layers.select('path.line'), _chart.transitionDuration(), _chart.transitionDelay())\n            //.ease('linear')\n            .attr('stroke', colors)\n            .attr('d', function (d) {\n                return safeD(line(d.values));\n            });\n    }\n\n    function drawArea (layersEnter, layers) {\n        if (_renderArea) {\n            var area = d3.svg.area()\n                .x(function (d) {\n                    return _chart.x()(d.x);\n                })\n                .y(function (d) {\n                    return _chart.y()(d.y + d.y0);\n                })\n                .y0(function (d) {\n                    return _chart.y()(d.y0);\n                })\n                .interpolate(_interpolate)\n                .tension(_tension);\n            if (_defined) {\n                area.defined(_defined);\n            }\n\n            layersEnter.append('path')\n                .attr('class', 'area')\n                .attr('fill', colors)\n                .attr('d', function (d) {\n                    return safeD(area(d.values));\n                });\n\n            dc.transition(layers.select('path.area'), _chart.transitionDuration(), _chart.transitionDelay())\n                //.ease('linear')\n                .attr('fill', colors)\n                .attr('d', function (d) {\n                    return safeD(area(d.values));\n                });\n        }\n    }\n\n    function safeD (d) {\n        return (!d || d.indexOf('NaN') >= 0) ? 'M0,0' : d;\n    }\n\n    function drawDots (chartBody, layers) {\n        if (_chart.xyTipsOn() === 'always' || (!_chart.brushOn() && _chart.xyTipsOn())) {\n            var tooltipListClass = TOOLTIP_G_CLASS + '-list';\n            var tooltips = chartBody.select('g.' + tooltipListClass);\n\n            if (tooltips.empty()) {\n                tooltips = chartBody.append('g').attr('class', tooltipListClass);\n            }\n\n            layers.each(function (d, layerIndex) {\n                var points = d.values;\n                if (_defined) {\n                    points = points.filter(_defined);\n                }\n\n                var g = tooltips.select('g.' + TOOLTIP_G_CLASS + '._' + layerIndex);\n                if (g.empty()) {\n                    g = tooltips.append('g').attr('class', TOOLTIP_G_CLASS + ' _' + layerIndex);\n                }\n\n                createRefLines(g);\n\n                var dots = g.selectAll('circle.' + DOT_CIRCLE_CLASS)\n                    .data(points, dc.pluck('x'));\n\n                dots.enter()\n                    .append('circle')\n                    .attr('class', DOT_CIRCLE_CLASS)\n                    .attr('r', getDotRadius())\n                    .style('fill-opacity', _dataPointFillOpacity)\n                    .style('stroke-opacity', _dataPointStrokeOpacity)\n                    .attr('fill', _chart.getColor)\n                    .on('mousemove', function () {\n                        var dot = d3.select(this);\n                        showDot(dot);\n                        showRefLines(dot, g);\n                    })\n                    .on('mouseout', function () {\n                        var dot = d3.select(this);\n                        hideDot(dot);\n                        hideRefLines(g);\n                    });\n\n                dots.call(renderTitle, d);\n\n                dc.transition(dots, _chart.transitionDuration())\n                    .attr('cx', function (d) {\n                        return dc.utils.safeNumber(_chart.x()(d.x));\n                    })\n                    .attr('cy', function (d) {\n                        return dc.utils.safeNumber(_chart.y()(d.y + d.y0));\n                    })\n                    .attr('fill', _chart.getColor);\n\n                dots.exit().remove();\n            });\n        }\n    }\n\n    _chart.label(function (d) {\n        return dc.utils.printSingleValue(d.y0 + d.y);\n    }, false);\n\n    function drawLabels (layers) {\n        layers.each(function (d, layerIndex) {\n            var layer = d3.select(this);\n            var labels = layer.selectAll('text.lineLabel')\n                .data(d.values, dc.pluck('x'));\n\n            labels.enter()\n                .append('text')\n                .attr('class', 'lineLabel')\n                .attr('text-anchor', 'middle');\n\n            dc.transition(labels, _chart.transitionDuration())\n                .attr('x', function (d) {\n                    return dc.utils.safeNumber(_chart.x()(d.x));\n                })\n                .attr('y', function (d) {\n                    var y = _chart.y()(d.y + d.y0) - LABEL_PADDING;\n                    return dc.utils.safeNumber(y);\n                })\n                .text(function (d) {\n                    return _chart.label()(d);\n                });\n\n            dc.transition(labels.exit(), _chart.transitionDuration())\n                .attr('height', 0)\n                .remove();\n        });\n    }\n\n    function createRefLines (g) {\n        var yRefLine = g.select('path.' + Y_AXIS_REF_LINE_CLASS).empty() ?\n            g.append('path').attr('class', Y_AXIS_REF_LINE_CLASS) : g.select('path.' + Y_AXIS_REF_LINE_CLASS);\n        yRefLine.style('display', 'none').attr('stroke-dasharray', '5,5');\n\n        var xRefLine = g.select('path.' + X_AXIS_REF_LINE_CLASS).empty() ?\n            g.append('path').attr('class', X_AXIS_REF_LINE_CLASS) : g.select('path.' + X_AXIS_REF_LINE_CLASS);\n        xRefLine.style('display', 'none').attr('stroke-dasharray', '5,5');\n    }\n\n    function showDot (dot) {\n        dot.style('fill-opacity', 0.8);\n        dot.style('stroke-opacity', 0.8);\n        dot.attr('r', _dotRadius);\n        return dot;\n    }\n\n    function showRefLines (dot, g) {\n        var x = dot.attr('cx');\n        var y = dot.attr('cy');\n        var yAxisX = (_chart._yAxisX() - _chart.margins().left);\n        var yAxisRefPathD = 'M' + yAxisX + ' ' + y + 'L' + (x) + ' ' + (y);\n        var xAxisRefPathD = 'M' + x + ' ' + _chart.yAxisHeight() + 'L' + x + ' ' + y;\n        g.select('path.' + Y_AXIS_REF_LINE_CLASS).style('display', '').attr('d', yAxisRefPathD);\n        g.select('path.' + X_AXIS_REF_LINE_CLASS).style('display', '').attr('d', xAxisRefPathD);\n    }\n\n    function getDotRadius () {\n        return _dataPointRadius || _dotRadius;\n    }\n\n    function hideDot (dot) {\n        dot.style('fill-opacity', _dataPointFillOpacity)\n            .style('stroke-opacity', _dataPointStrokeOpacity)\n            .attr('r', getDotRadius());\n    }\n\n    function hideRefLines (g) {\n        g.select('path.' + Y_AXIS_REF_LINE_CLASS).style('display', 'none');\n        g.select('path.' + X_AXIS_REF_LINE_CLASS).style('display', 'none');\n    }\n\n    function renderTitle (dot, d) {\n        if (_chart.renderTitle()) {\n            dot.select('title').remove();\n            dot.append('title').text(dc.pluck('data', _chart.title(d.name)));\n        }\n    }\n\n    /**\n     * Turn on/off the mouseover behavior of an individual data point which renders a circle and x/y axis\n     * dashed lines back to each respective axis.  This is ignored if the chart\n     * {@link dc.coordinateGridMixin#brushOn brush} is on\n     * @method xyTipsOn\n     * @memberof dc.lineChart\n     * @instance\n     * @param  {Boolean} [xyTipsOn=false]\n     * @returns {Boolean|dc.lineChart}\n     */\n    _chart.xyTipsOn = function (xyTipsOn) {\n        if (!arguments.length) {\n            return _xyTipsOn;\n        }\n        _xyTipsOn = xyTipsOn;\n        return _chart;\n    };\n\n    /**\n     * Get or set the radius (in px) for dots displayed on the data points.\n     * @method dotRadius\n     * @memberof dc.lineChart\n     * @instance\n     * @param  {Number} [dotRadius=5]\n     * @returns {Number|dc.lineChart}\n     */\n    _chart.dotRadius = function (dotRadius) {\n        if (!arguments.length) {\n            return _dotRadius;\n        }\n        _dotRadius = dotRadius;\n        return _chart;\n    };\n\n    /**\n     * Always show individual dots for each datapoint.\n     *\n     * If `options` is falsy, it disables data point rendering. If no `options` are provided, the\n     * current `options` values are instead returned.\n     * @method renderDataPoints\n     * @memberof dc.lineChart\n     * @instance\n     * @example\n     * chart.renderDataPoints({radius: 2, fillOpacity: 0.8, strokeOpacity: 0.8})\n     * @param  {{fillOpacity: Number, strokeOpacity: Number, radius: Number}} [options={fillOpacity: 0.8, strokeOpacity: 0.8, radius: 2}]\n     * @returns {{fillOpacity: Number, strokeOpacity: Number, radius: Number}|dc.lineChart}\n     */\n    _chart.renderDataPoints = function (options) {\n        if (!arguments.length) {\n            return {\n                fillOpacity: _dataPointFillOpacity,\n                strokeOpacity: _dataPointStrokeOpacity,\n                radius: _dataPointRadius\n            };\n        } else if (!options) {\n            _dataPointFillOpacity = DEFAULT_DOT_OPACITY;\n            _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;\n            _dataPointRadius = null;\n        } else {\n            _dataPointFillOpacity = options.fillOpacity || 0.8;\n            _dataPointStrokeOpacity = options.strokeOpacity || 0.8;\n            _dataPointRadius = options.radius || 2;\n        }\n        return _chart;\n    };\n\n    function colorFilter (color, dashstyle, inv) {\n        return function () {\n            var item = d3.select(this);\n            var match = (item.attr('stroke') === color &&\n                item.attr('stroke-dasharray') === ((dashstyle instanceof Array) ?\n                    dashstyle.join(',') : null)) || item.attr('fill') === color;\n            return inv ? !match : match;\n        };\n    }\n\n    _chart.legendHighlight = function (d) {\n        if (!_chart.isLegendableHidden(d)) {\n            _chart.g().selectAll('path.line, path.area')\n                .classed('highlight', colorFilter(d.color, d.dashstyle))\n                .classed('fadeout', colorFilter(d.color, d.dashstyle, true));\n        }\n    };\n\n    _chart.legendReset = function () {\n        _chart.g().selectAll('path.line, path.area')\n            .classed('highlight', false)\n            .classed('fadeout', false);\n    };\n\n    dc.override(_chart, 'legendables', function () {\n        var legendables = _chart._legendables();\n        if (!_dashStyle) {\n            return legendables;\n        }\n        return legendables.map(function (l) {\n            l.dashstyle = _dashStyle;\n            return l;\n        });\n    });\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The data count widget is a simple widget designed to display the number of records selected by the\n * current filters out of the total number of records in the data set. Once created the data count widget\n * will automatically update the text content of child elements with the following classes:\n *\n * * `.total-count` - total number of records\n * * `.filter-count` - number of records matched by the current filters\n *\n * Note: this widget works best for the specific case of showing the number of records out of a\n * total. If you want a more general-purpose numeric display, please use the\n * {@link dc.numberDisplay} widget instead.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * @class dataCount\n * @memberof dc\n * @mixes dc.baseMixin\n * @example\n * var ndx = crossfilter(data);\n * var all = ndx.groupAll();\n *\n * dc.dataCount('.dc-data-count')\n *     .dimension(ndx)\n *     .group(all);\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.dataCount}\n */\ndc.dataCount = function (parent, chartGroup) {\n    var _formatNumber = d3.format(',d');\n    var _chart = dc.baseMixin({});\n    var _html = {some: '', all: ''};\n\n    /**\n     * Gets or sets an optional object specifying HTML templates to use depending how many items are\n     * selected. The text `%total-count` will replaced with the total number of records, and the text\n     * `%filter-count` will be replaced with the number of selected records.\n     * - all: HTML template to use if all items are selected\n     * - some: HTML template to use if not all items are selected\n     * @method html\n     * @memberof dc.dataCount\n     * @instance\n     * @example\n     * counter.html({\n     *      some: '%filter-count out of %total-count records selected',\n     *      all: 'All records selected. Click on charts to apply filters'\n     * })\n     * @param {{some:String, all: String}} [options]\n     * @returns {{some:String, all: String}|dc.dataCount}\n     */\n    _chart.html = function (options) {\n        if (!arguments.length) {\n            return _html;\n        }\n        if (options.all) {\n            _html.all = options.all;\n        }\n        if (options.some) {\n            _html.some = options.some;\n        }\n        return _chart;\n    };\n\n    /**\n     * Gets or sets an optional function to format the filter count and total count.\n     * @method formatNumber\n     * @memberof dc.dataCount\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Formatting.md d3.format}\n     * @example\n     * counter.formatNumber(d3.format('.2g'))\n     * @param {Function} [formatter=d3.format('.2g')]\n     * @returns {Function|dc.dataCount}\n     */\n    _chart.formatNumber = function (formatter) {\n        if (!arguments.length) {\n            return _formatNumber;\n        }\n        _formatNumber = formatter;\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        var tot = _chart.dimension().size(),\n            val = _chart.group().value();\n        var all = _formatNumber(tot);\n        var selected = _formatNumber(val);\n\n        if ((tot === val) && (_html.all !== '')) {\n            _chart.root().html(_html.all.replace('%total-count', all).replace('%filter-count', selected));\n        } else if (_html.some !== '') {\n            _chart.root().html(_html.some.replace('%total-count', all).replace('%filter-count', selected));\n        } else {\n            _chart.selectAll('.total-count').text(all);\n            _chart.selectAll('.filter-count').text(selected);\n        }\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The data table is a simple widget designed to list crossfilter focused data set (rows being\n * filtered) in a good old tabular fashion.\n *\n * Note: Unlike other charts, the data table (and data grid chart) use the {@link dc.dataTable#group group} attribute as a\n * keying function for {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#nest nesting} the data\n * together in groups.  Do not pass in a crossfilter group as this will not work.\n *\n * Another interesting feature of the data table is that you can pass a crossfilter group to the `dimension`, as\n * long as you specify the {@link dc.dataTable#order order} as `d3.descending`, since the data\n * table will use `dimension.top()` to fetch the data in that case, and the method is equally\n * supported on the crossfilter group as the crossfilter dimension.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.io/dc.js/examples/table-on-aggregated-data.html dataTable on a crossfilter group}\n * ({@link https://github.com/dc-js/dc.js/blob/develop/web/examples/table-on-aggregated-data.html source})\n * @class dataTable\n * @memberof dc\n * @mixes dc.baseMixin\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.dataTable}\n */\ndc.dataTable = function (parent, chartGroup) {\n    var LABEL_CSS_CLASS = 'dc-table-label';\n    var ROW_CSS_CLASS = 'dc-table-row';\n    var COLUMN_CSS_CLASS = 'dc-table-column';\n    var GROUP_CSS_CLASS = 'dc-table-group';\n    var HEAD_CSS_CLASS = 'dc-table-head';\n\n    var _chart = dc.baseMixin({});\n\n    var _size = 25;\n    var _columns = [];\n    var _sortBy = function (d) {\n        return d;\n    };\n    var _order = d3.ascending;\n    var _beginSlice = 0;\n    var _endSlice;\n    var _showGroups = true;\n\n    _chart._doRender = function () {\n        _chart.selectAll('tbody').remove();\n\n        renderRows(renderGroups());\n\n        return _chart;\n    };\n\n    _chart._doColumnValueFormat = function (v, d) {\n        return ((typeof v === 'function') ?\n                v(d) :                          // v as function\n                ((typeof v === 'string') ?\n                 d[v] :                         // v is field name string\n                 v.format(d)                        // v is Object, use fn (element 2)\n                )\n               );\n    };\n\n    _chart._doColumnHeaderFormat = function (d) {\n        // if 'function', convert to string representation\n        // show a string capitalized\n        // if an object then display its label string as-is.\n        return (typeof d === 'function') ?\n                _chart._doColumnHeaderFnToString(d) :\n                ((typeof d === 'string') ?\n                 _chart._doColumnHeaderCapitalize(d) : String(d.label));\n    };\n\n    _chart._doColumnHeaderCapitalize = function (s) {\n        // capitalize\n        return s.charAt(0).toUpperCase() + s.slice(1);\n    };\n\n    _chart._doColumnHeaderFnToString = function (f) {\n        // columnString(f) {\n        var s = String(f);\n        var i1 = s.indexOf('return ');\n        if (i1 >= 0) {\n            var i2 = s.lastIndexOf(';');\n            if (i2 >= 0) {\n                s = s.substring(i1 + 7, i2);\n                var i3 = s.indexOf('numberFormat');\n                if (i3 >= 0) {\n                    s = s.replace('numberFormat', '');\n                }\n            }\n        }\n        return s;\n    };\n\n    function renderGroups () {\n        // The 'original' example uses all 'functions'.\n        // If all 'functions' are used, then don't remove/add a header, and leave\n        // the html alone. This preserves the functionality of earlier releases.\n        // A 2nd option is a string representing a field in the data.\n        // A third option is to supply an Object such as an array of 'information', and\n        // supply your own _doColumnHeaderFormat and _doColumnValueFormat functions to\n        // create what you need.\n        var bAllFunctions = true;\n        _columns.forEach(function (f) {\n            bAllFunctions = bAllFunctions & (typeof f === 'function');\n        });\n\n        if (!bAllFunctions) {\n            // ensure one thead\n            var thead = _chart.selectAll('thead').data([0]);\n            thead.enter().append('thead');\n            thead.exit().remove();\n\n            // with one tr\n            var headrow = thead.selectAll('tr').data([0]);\n            headrow.enter().append('tr');\n            headrow.exit().remove();\n\n            // with a th for each column\n            var headcols = headrow.selectAll('th')\n                .data(_columns);\n            headcols.enter().append('th');\n            headcols.exit().remove();\n\n            headcols\n                .attr('class', HEAD_CSS_CLASS)\n                    .html(function (d) {\n                        return (_chart._doColumnHeaderFormat(d));\n\n                    });\n        }\n\n        var groups = _chart.root().selectAll('tbody')\n            .data(nestEntries(), function (d) {\n                return _chart.keyAccessor()(d);\n            });\n\n        var rowGroup = groups\n            .enter()\n            .append('tbody');\n\n        if (_showGroups === true) {\n            rowGroup\n                .append('tr')\n                .attr('class', GROUP_CSS_CLASS)\n                    .append('td')\n                    .attr('class', LABEL_CSS_CLASS)\n                    .attr('colspan', _columns.length)\n                    .html(function (d) {\n                        return _chart.keyAccessor()(d);\n                    });\n        }\n\n        groups.exit().remove();\n\n        return rowGroup;\n    }\n\n    function nestEntries () {\n        var entries;\n        if (_order === d3.ascending) {\n            entries = _chart.dimension().bottom(_size);\n        } else {\n            entries = _chart.dimension().top(_size);\n        }\n\n        return d3.nest()\n            .key(_chart.group())\n            .sortKeys(_order)\n            .entries(entries.sort(function (a, b) {\n                return _order(_sortBy(a), _sortBy(b));\n            }).slice(_beginSlice, _endSlice));\n    }\n\n    function renderRows (groups) {\n        var rows = groups.order()\n            .selectAll('tr.' + ROW_CSS_CLASS)\n            .data(function (d) {\n                return d.values;\n            });\n\n        var rowEnter = rows.enter()\n            .append('tr')\n            .attr('class', ROW_CSS_CLASS);\n\n        _columns.forEach(function (v, i) {\n            rowEnter.append('td')\n                .attr('class', COLUMN_CSS_CLASS + ' _' + i)\n                .html(function (d) {\n                    return _chart._doColumnValueFormat(v, d);\n                });\n        });\n\n        rows.exit().remove();\n\n        return rows;\n    }\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\n     * Get or set the group function for the data table. The group function takes a data row and\n     * returns the key to specify to {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_nest d3.nest}\n     * to split rows into groups.\n     *\n     * Do not pass in a crossfilter group as this will not work.\n     * @method group\n     * @memberof dc.dataTable\n     * @instance\n     * @example\n     * // group rows by the value of their field\n     * chart\n     *     .group(function(d) { return d.field; })\n     * @param {Function} groupFunction Function taking a row of data and returning the nest key.\n     * @returns {Function|dc.dataTable}\n     */\n\n    /**\n     * Get or set the table size which determines the number of rows displayed by the widget.\n     * @method size\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Number} [size=25]\n     * @returns {Number|dc.dataTable}\n     */\n    _chart.size = function (size) {\n        if (!arguments.length) {\n            return _size;\n        }\n        _size = size;\n        return _chart;\n    };\n\n    /**\n     * Get or set the index of the beginning slice which determines which entries get displayed\n     * by the widget. Useful when implementing pagination.\n     *\n     * Note: the sortBy function will determine how the rows are ordered for pagination purposes.\n\n     * See the {@link http://dc-js.github.io/dc.js/examples/table-pagination.html table pagination example}\n     * to see how to implement the pagination user interface using `beginSlice` and `endSlice`.\n     * @method beginSlice\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Number} [beginSlice=0]\n     * @returns {Number|dc.dataTable}\n     */\n    _chart.beginSlice = function (beginSlice) {\n        if (!arguments.length) {\n            return _beginSlice;\n        }\n        _beginSlice = beginSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set the index of the end slice which determines which entries get displayed by the\n     * widget. Useful when implementing pagination. See {@link dc.dataTable#beginSlice `beginSlice`} for more information.\n     * @method endSlice\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Number|undefined} [endSlice=undefined]\n     * @returns {Number|dc.dataTable}\n     */\n    _chart.endSlice = function (endSlice) {\n        if (!arguments.length) {\n            return _endSlice;\n        }\n        _endSlice = endSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set column functions. The data table widget supports several methods of specifying the\n     * columns to display.\n     *\n     * The original method uses an array of functions to generate dynamic columns. Column functions\n     * are simple javascript functions with only one input argument `d` which represents a row in\n     * the data set. The return value of these functions will be used to generate the content for\n     * each cell. However, this method requires the HTML for the table to have a fixed set of column\n     * headers.\n     *\n     * <pre><code>chart.columns([\n     *     function(d) { return d.date; },\n     *     function(d) { return d.open; },\n     *     function(d) { return d.close; },\n     *     function(d) { return numberFormat(d.close - d.open); },\n     *     function(d) { return d.volume; }\n     * ]);\n     * </code></pre>\n     *\n     * In the second method, you can list the columns to read from the data without specifying it as\n     * a function, except where necessary (ie, computed columns).  Note the data element name is\n     * capitalized when displayed in the table header. You can also mix in functions as necessary,\n     * using the third `{label, format}` form, as shown below.\n     *\n     * <pre><code>chart.columns([\n     *     \"date\",    // d[\"date\"], ie, a field accessor; capitalized automatically\n     *     \"open\",    // ...\n     *     \"close\",   // ...\n     *     {\n     *         label: \"Change\",\n     *         format: function (d) {\n     *             return numberFormat(d.close - d.open);\n     *         }\n     *     },\n     *     \"volume\"   // d[\"volume\"], ie, a field accessor; capitalized automatically\n     * ]);\n     * </code></pre>\n     *\n     * In the third example, we specify all fields using the `{label, format}` method:\n     * <pre><code>chart.columns([\n     *     {\n     *         label: \"Date\",\n     *         format: function (d) { return d.date; }\n     *     },\n     *     {\n     *         label: \"Open\",\n     *         format: function (d) { return numberFormat(d.open); }\n     *     },\n     *     {\n     *         label: \"Close\",\n     *         format: function (d) { return numberFormat(d.close); }\n     *     },\n     *     {\n     *         label: \"Change\",\n     *         format: function (d) { return numberFormat(d.close - d.open); }\n     *     },\n     *     {\n     *         label: \"Volume\",\n     *         format: function (d) { return d.volume; }\n     *     }\n     * ]);\n     * </code></pre>\n     *\n     * You may wish to override the dataTable functions `_doColumnHeaderCapitalize` and\n     * `_doColumnHeaderFnToString`, which are used internally to translate the column information or\n     * function into a displayed header. The first one is used on the \"string\" column specifier; the\n     * second is used to transform a stringified function into something displayable. For the Stock\n     * example, the function for Change becomes the table header **d.close - d.open**.\n     *\n     * Finally, you can even specify a completely different form of column definition. To do this,\n     * override `_chart._doColumnHeaderFormat` and `_chart._doColumnValueFormat` Be aware that\n     * fields without numberFormat specification will be displayed just as they are stored in the\n     * data, unformatted.\n     * @method columns\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Array<Function>} [columns=[]]\n     * @returns {Array<Function>}|dc.dataTable}\n     */\n    _chart.columns = function (columns) {\n        if (!arguments.length) {\n            return _columns;\n        }\n        _columns = columns;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort-by function. This function works as a value accessor at row level and returns a\n     * particular field to be sorted by.\n     * @method sortBy\n     * @memberof dc.dataTable\n     * @instance\n     * @example\n     * chart.sortBy(function(d) {\n     *     return d.date;\n     * });\n     * @param {Function} [sortBy=identity function]\n     * @returns {Function|dc.dataTable}\n     */\n    _chart.sortBy = function (sortBy) {\n        if (!arguments.length) {\n            return _sortBy;\n        }\n        _sortBy = sortBy;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort order. If the order is `d3.ascending`, the data table will use\n     * `dimension().bottom()` to fetch the data; otherwise it will use `dimension().top()`\n     * @method order\n     * @memberof dc.dataTable\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * chart.order(d3.descending);\n     * @param {Function} [order=d3.ascending]\n     * @returns {Function|dc.dataTable}\n     */\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    /**\n     * Get or set if group rows will be shown. The dataTable {@link dc.dataTable#group group}\n     * function must be specified even if groups are not shown.\n     * @method showGroups\n     * @memberof dc.dataTable\n     * @instance\n     * @example\n     * chart\n     *     .group([value], [name])\n     *     .showGroups(true|false);\n     * @param {Boolean} [showGroups=true]\n     * @returns {Boolean|dc.dataTable}\n     */\n    _chart.showGroups = function (showGroups) {\n        if (!arguments.length) {\n            return _showGroups;\n        }\n        _showGroups = showGroups;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Data grid is a simple widget designed to list the filtered records, providing\n * a simple way to define how the items are displayed.\n *\n * Note: Unlike other charts, the data grid chart (and data table) use the {@link dc.dataGrid#group group} attribute as a keying function\n * for {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#nest nesting} the data together in groups.\n * Do not pass in a crossfilter group as this will not work.\n *\n * Examples:\n * - {@link http://europarl.me/dc.js/web/ep/index.html List of members of the european parliament}\n * @class dataGrid\n * @memberof dc\n * @mixes dc.baseMixin\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.dataGrid}\n */\ndc.dataGrid = function (parent, chartGroup) {\n    var LABEL_CSS_CLASS = 'dc-grid-label';\n    var ITEM_CSS_CLASS = 'dc-grid-item';\n    var GROUP_CSS_CLASS = 'dc-grid-group';\n    var GRID_CSS_CLASS = 'dc-grid-top';\n\n    var _chart = dc.baseMixin({});\n\n    var _size = 999; // shouldn't be needed, but you might\n    var _html = function (d) { return 'you need to provide an html() handling param:  ' + JSON.stringify(d); };\n    var _sortBy = function (d) {\n        return d;\n    };\n    var _order = d3.ascending;\n    var _beginSlice = 0, _endSlice;\n\n    var _htmlGroup = function (d) {\n        return '<div class=\\'' + GROUP_CSS_CLASS + '\\'><h1 class=\\'' + LABEL_CSS_CLASS + '\\'>' +\n            _chart.keyAccessor()(d) + '</h1></div>';\n    };\n\n    _chart._doRender = function () {\n        _chart.selectAll('div.' + GRID_CSS_CLASS).remove();\n\n        renderItems(renderGroups());\n\n        return _chart;\n    };\n\n    function renderGroups () {\n        var groups = _chart.root().selectAll('div.' + GRID_CSS_CLASS)\n                .data(nestEntries(), function (d) {\n                    return _chart.keyAccessor()(d);\n                });\n\n        var itemGroup = groups\n                .enter()\n                .append('div')\n                .attr('class', GRID_CSS_CLASS);\n\n        if (_htmlGroup) {\n            itemGroup\n                .html(function (d) {\n                    return _htmlGroup(d);\n                });\n        }\n\n        groups.exit().remove();\n        return itemGroup;\n    }\n\n    function nestEntries () {\n        var entries = _chart.dimension().top(_size);\n\n        return d3.nest()\n            .key(_chart.group())\n            .sortKeys(_order)\n            .entries(entries.sort(function (a, b) {\n                return _order(_sortBy(a), _sortBy(b));\n            }).slice(_beginSlice, _endSlice));\n    }\n\n    function renderItems (groups) {\n        var items = groups.order()\n                .selectAll('div.' + ITEM_CSS_CLASS)\n                .data(function (d) {\n                    return d.values;\n                });\n\n        items.enter()\n            .append('div')\n            .attr('class', ITEM_CSS_CLASS)\n            .html(function (d) {\n                return _html(d);\n            });\n\n        items.exit().remove();\n\n        return items;\n    }\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\n     * Get or set the group function for the data grid. The group function takes a data row and\n     * returns the key to specify to {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_nest d3.nest}\n     * to split rows into groups.\n     *\n     * Do not pass in a crossfilter group as this will not work.\n     * @method group\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * // group rows by the value of their field\n     * chart\n     *     .group(function(d) { return d.field; })\n     * @param {Function} groupFunction Function taking a row of data and returning the nest key.\n     * @returns {Function|dc.dataTable}\n     */\n\n    /**\n     * Get or set the index of the beginning slice which determines which entries get displayed by the widget.\n     * Useful when implementing pagination.\n     * @method beginSlice\n     * @memberof dc.dataGrid\n     * @instance\n     * @param {Number} [beginSlice=0]\n     * @returns {Number|dc.dataGrid}\n     */\n    _chart.beginSlice = function (beginSlice) {\n        if (!arguments.length) {\n            return _beginSlice;\n        }\n        _beginSlice = beginSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set the index of the end slice which determines which entries get displayed by the widget.\n     * Useful when implementing pagination.\n     * @method endSlice\n     * @memberof dc.dataGrid\n     * @instance\n     * @param {Number} [endSlice]\n     * @returns {Number|dc.dataGrid}\n     */\n    _chart.endSlice = function (endSlice) {\n        if (!arguments.length) {\n            return _endSlice;\n        }\n        _endSlice = endSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set the grid size which determines the number of items displayed by the widget.\n     * @method size\n     * @memberof dc.dataGrid\n     * @instance\n     * @param {Number} [size=999]\n     * @returns {Number|dc.dataGrid}\n     */\n    _chart.size = function (size) {\n        if (!arguments.length) {\n            return _size;\n        }\n        _size = size;\n        return _chart;\n    };\n\n    /**\n     * Get or set the function that formats an item. The data grid widget uses a\n     * function to generate dynamic html. Use your favourite templating engine or\n     * generate the string directly.\n     * @method html\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * chart.html(function (d) { return '<div class='item '+data.exampleCategory+''>'+data.exampleString+'</div>';});\n     * @param {Function} [html]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.html = function (html) {\n        if (!arguments.length) {\n            return _html;\n        }\n        _html = html;\n        return _chart;\n    };\n\n    /**\n     * Get or set the function that formats a group label.\n     * @method htmlGroup\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * chart.htmlGroup (function (d) { return '<h2>'.d.key . 'with ' . d.values.length .' items</h2>'});\n     * @param {Function} [htmlGroup]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.htmlGroup = function (htmlGroup) {\n        if (!arguments.length) {\n            return _htmlGroup;\n        }\n        _htmlGroup = htmlGroup;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort-by function. This function works as a value accessor at the item\n     * level and returns a particular field to be sorted.\n     * @method sortBy\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * chart.sortBy(function(d) {\n     *     return d.date;\n     * });\n     * @param {Function} [sortByFunction]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.sortBy = function (sortByFunction) {\n        if (!arguments.length) {\n            return _sortBy;\n        }\n        _sortBy = sortByFunction;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort the order function.\n     * @method order\n     * @memberof dc.dataGrid\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * chart.order(d3.descending);\n     * @param {Function} [order=d3.ascending]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A concrete implementation of a general purpose bubble chart that allows data visualization using the\n * following dimensions:\n * - x axis position\n * - y axis position\n * - bubble radius\n * - color\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}\n * @class bubbleChart\n * @memberof dc\n * @mixes dc.bubbleMixin\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a bubble chart under #chart-container1 element using the default global chart group\n * var bubbleChart1 = dc.bubbleChart('#chart-container1');\n * // create a bubble chart under #chart-container2 element using chart group A\n * var bubbleChart2 = dc.bubbleChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.bubbleChart}\n */\ndc.bubbleChart = function (parent, chartGroup) {\n    var _chart = dc.bubbleMixin(dc.coordinateGridMixin({}));\n\n    _chart.transitionDuration(750);\n\n    _chart.transitionDelay(0);\n\n    var bubbleLocator = function (d) {\n        return 'translate(' + (bubbleX(d)) + ',' + (bubbleY(d)) + ')';\n    };\n\n    _chart.plotData = function () {\n        _chart.calculateRadiusDomain();\n        _chart.r().range([_chart.MIN_RADIUS, _chart.xAxisLength() * _chart.maxBubbleRelativeSize()]);\n\n        var data = _chart.data();\n        var bubbleG = _chart.chartBodyG().selectAll('g.' + _chart.BUBBLE_NODE_CLASS)\n                .data(data, function (d) { return d.key; });\n        if (_chart.sortBubbleSize()) {\n            // update dom order based on sort\n            bubbleG.order();\n        }\n\n        renderNodes(bubbleG);\n\n        updateNodes(bubbleG);\n\n        removeNodes(bubbleG);\n\n        _chart.fadeDeselectedArea();\n    };\n\n    function renderNodes (bubbleG) {\n        var bubbleGEnter = bubbleG.enter().append('g');\n\n        bubbleGEnter\n            .attr('class', _chart.BUBBLE_NODE_CLASS)\n            .attr('transform', bubbleLocator)\n            .append('circle').attr('class', function (d, i) {\n                return _chart.BUBBLE_CLASS + ' _' + i;\n            })\n            .on('click', _chart.onClick)\n            .attr('fill', _chart.getColor)\n            .attr('r', 0);\n        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay())\n            .select('circle.' + _chart.BUBBLE_CLASS)\n            .attr('r', function (d) {\n                return _chart.bubbleR(d);\n            })\n            .attr('opacity', function (d) {\n                return (_chart.bubbleR(d) > 0) ? 1 : 0;\n            });\n\n        _chart._doRenderLabel(bubbleGEnter);\n\n        _chart._doRenderTitles(bubbleGEnter);\n    }\n\n    function updateNodes (bubbleG) {\n        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', bubbleLocator)\n            .select('circle.' + _chart.BUBBLE_CLASS)\n            .attr('fill', _chart.getColor)\n            .attr('r', function (d) {\n                return _chart.bubbleR(d);\n            })\n            .attr('opacity', function (d) {\n                return (_chart.bubbleR(d) > 0) ? 1 : 0;\n            });\n\n        _chart.doUpdateLabels(bubbleG);\n        _chart.doUpdateTitles(bubbleG);\n    }\n\n    function removeNodes (bubbleG) {\n        bubbleG.exit().remove();\n    }\n\n    function bubbleX (d) {\n        var x = _chart.x()(_chart.keyAccessor()(d));\n        if (isNaN(x)) {\n            x = 0;\n        }\n        return x;\n    }\n\n    function bubbleY (d) {\n        var y = _chart.y()(_chart.valueAccessor()(d));\n        if (isNaN(y)) {\n            y = 0;\n        }\n        return y;\n    }\n\n    _chart.renderBrush = function () {\n        // override default x axis brush from parent chart\n    };\n\n    _chart.redrawBrush = function () {\n        // override default x axis brush from parent chart\n        _chart.fadeDeselectedArea();\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Composite charts are a special kind of chart that render multiple charts on the same Coordinate\n * Grid. You can overlay (compose) different bar/line/area charts in a single composite chart to\n * achieve some quite flexible charting effects.\n * @class compositeChart\n * @memberof dc\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a composite chart under #chart-container1 element using the default global chart group\n * var compositeChart1 = dc.compositeChart('#chart-container1');\n * // create a composite chart under #chart-container2 element using chart group A\n * var compositeChart2 = dc.compositeChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.compositeChart}\n */\ndc.compositeChart = function (parent, chartGroup) {\n\n    var SUB_CHART_CLASS = 'sub';\n    var DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING = 12;\n\n    var _chart = dc.coordinateGridMixin({});\n    var _children = [];\n\n    var _childOptions = {};\n\n    var _shareColors = false,\n        _shareTitle = true,\n        _alignYAxes = false;\n\n    var _rightYAxis = d3.svg.axis(),\n        _rightYAxisLabel = 0,\n        _rightYAxisLabelPadding = DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING,\n        _rightY,\n        _rightAxisGridLines = false;\n\n    _chart._mandatoryAttributes([]);\n    _chart.transitionDuration(500);\n    _chart.transitionDelay(0);\n\n    dc.override(_chart, '_generateG', function () {\n        var g = this.__generateG();\n\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n\n            generateChildG(child, i);\n\n            if (!child.dimension()) {\n                child.dimension(_chart.dimension());\n            }\n            if (!child.group()) {\n                child.group(_chart.group());\n            }\n\n            child.chartGroup(_chart.chartGroup());\n            child.svg(_chart.svg());\n            child.xUnits(_chart.xUnits());\n            child.transitionDuration(_chart.transitionDuration(), _chart.transitionDelay());\n            child.brushOn(_chart.brushOn());\n            child.renderTitle(_chart.renderTitle());\n            child.elasticX(_chart.elasticX());\n        }\n\n        return g;\n    });\n\n    _chart._brushing = function () {\n        var extent = _chart.extendBrush();\n        var brushIsEmpty = _chart.brushIsEmpty(extent);\n\n        for (var i = 0; i < _children.length; ++i) {\n            _children[i].replaceFilter(brushIsEmpty ? null : extent);\n        }\n    };\n\n    _chart._prepareYAxis = function () {\n        var left = (leftYAxisChildren().length !== 0);\n        var right = (rightYAxisChildren().length !== 0);\n        var ranges = calculateYAxisRanges(left, right);\n\n        if (left) { prepareLeftYAxis(ranges); }\n        if (right) { prepareRightYAxis(ranges); }\n\n        if (leftYAxisChildren().length > 0 && !_rightAxisGridLines) {\n            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _chart.y(), _chart.yAxis());\n        } else if (rightYAxisChildren().length > 0) {\n            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _rightY, _rightYAxis);\n        }\n    };\n\n    _chart.renderYAxis = function () {\n        if (leftYAxisChildren().length !== 0) {\n            _chart.renderYAxisAt('y', _chart.yAxis(), _chart.margins().left);\n            _chart.renderYAxisLabel('y', _chart.yAxisLabel(), -90);\n        }\n\n        if (rightYAxisChildren().length !== 0) {\n            _chart.renderYAxisAt('yr', _chart.rightYAxis(), _chart.width() - _chart.margins().right);\n            _chart.renderYAxisLabel('yr', _chart.rightYAxisLabel(), 90, _chart.width() - _rightYAxisLabelPadding);\n        }\n    };\n\n    function calculateYAxisRanges (left, right) {\n        var lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax;\n        var ranges;\n\n        if (left) {\n            lyAxisMin = yAxisMin();\n            lyAxisMax = yAxisMax();\n        }\n\n        if (right) {\n            ryAxisMin = rightYAxisMin();\n            ryAxisMax = rightYAxisMax();\n        }\n\n        if (_chart.alignYAxes() && left && right) {\n            ranges = alignYAxisRanges(lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax);\n        }\n\n        return ranges || {\n            lyAxisMin: lyAxisMin,\n            lyAxisMax: lyAxisMax,\n            ryAxisMin: ryAxisMin,\n            ryAxisMax: ryAxisMax\n        };\n    }\n\n    function alignYAxisRanges (lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax) {\n        // since the two series will share a zero, each Y is just a multiple\n        // of the other. and the ratio should be the ratio of the ranges of the\n        // input data, so that they come out the same height. so we just min/max\n\n        // note: both ranges already include zero due to the stack mixin (#667)\n        // if #667 changes, we can reconsider whether we want data height or\n        // height from zero to be equal. and it will be possible for the axes\n        // to be aligned but not visible.\n        var extentRatio = (ryAxisMax - ryAxisMin) / (lyAxisMax - lyAxisMin);\n\n        return {\n            lyAxisMin: Math.min(lyAxisMin, ryAxisMin / extentRatio),\n            lyAxisMax: Math.max(lyAxisMax, ryAxisMax / extentRatio),\n            ryAxisMin: Math.min(ryAxisMin, lyAxisMin * extentRatio),\n            ryAxisMax: Math.max(ryAxisMax, lyAxisMax * extentRatio)\n        };\n    }\n\n    function prepareRightYAxis (ranges) {\n        var needDomain = _chart.rightY() === undefined || _chart.elasticY(),\n            needRange = needDomain || _chart.resizing();\n        if (_chart.rightY() === undefined) {\n            _chart.rightY(d3.scale.linear());\n        }\n        if (needDomain) {\n            _chart.rightY().domain([ranges.ryAxisMin, ranges.ryAxisMax]);\n        }\n        if (needRange) {\n            _chart.rightY().rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _chart.rightY().range([_chart.yAxisHeight(), 0]);\n        _chart.rightYAxis(_chart.rightYAxis().scale(_chart.rightY()));\n\n        _chart.rightYAxis().orient('right');\n    }\n\n    function prepareLeftYAxis (ranges) {\n        var needDomain = _chart.y() === undefined || _chart.elasticY(),\n            needRange = needDomain || _chart.resizing();\n        if (_chart.y() === undefined) {\n            _chart.y(d3.scale.linear());\n        }\n        if (needDomain) {\n            _chart.y().domain([ranges.lyAxisMin, ranges.lyAxisMax]);\n        }\n        if (needRange) {\n            _chart.y().rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _chart.y().range([_chart.yAxisHeight(), 0]);\n        _chart.yAxis(_chart.yAxis().scale(_chart.y()));\n\n        _chart.yAxis().orient('left');\n    }\n\n    function generateChildG (child, i) {\n        child._generateG(_chart.g());\n        child.g().attr('class', SUB_CHART_CLASS + ' _' + i);\n    }\n\n    _chart.plotData = function () {\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n\n            if (!child.g()) {\n                generateChildG(child, i);\n            }\n\n            if (_shareColors) {\n                child.colors(_chart.colors());\n            }\n\n            child.x(_chart.x());\n\n            child.xAxis(_chart.xAxis());\n\n            if (child.useRightYAxis()) {\n                child.y(_chart.rightY());\n                child.yAxis(_chart.rightYAxis());\n            } else {\n                child.y(_chart.y());\n                child.yAxis(_chart.yAxis());\n            }\n\n            child.plotData();\n\n            child._activateRenderlets();\n        }\n    };\n\n    /**\n     * Get or set whether to draw gridlines from the right y axis.  Drawing from the left y axis is the\n     * default behavior. This option is only respected when subcharts with both left and right y-axes\n     * are present.\n     * @method useRightAxisGridLines\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [useRightAxisGridLines=false]\n     * @returns {Boolean|dc.compositeChart}\n     */\n    _chart.useRightAxisGridLines = function (useRightAxisGridLines) {\n        if (!arguments) {\n            return _rightAxisGridLines;\n        }\n\n        _rightAxisGridLines = useRightAxisGridLines;\n        return _chart;\n    };\n\n    /**\n     * Get or set chart-specific options for all child charts. This is equivalent to calling\n     * {@link dc.baseMixin#options .options} on each child chart.\n     * @method childOptions\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Object} [childOptions]\n     * @returns {Object|dc.compositeChart}\n     */\n    _chart.childOptions = function (childOptions) {\n        if (!arguments.length) {\n            return _childOptions;\n        }\n        _childOptions = childOptions;\n        _children.forEach(function (child) {\n            child.options(_childOptions);\n        });\n        return _chart;\n    };\n\n    _chart.fadeDeselectedArea = function () {\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n            child.brush(_chart.brush());\n            child.fadeDeselectedArea();\n        }\n    };\n\n    /**\n     * Set or get the right y axis label.\n     * @method rightYAxisLabel\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {String} [rightYAxisLabel]\n     * @param {Number} [padding]\n     * @returns {String|dc.compositeChart}\n     */\n    _chart.rightYAxisLabel = function (rightYAxisLabel, padding) {\n        if (!arguments.length) {\n            return _rightYAxisLabel;\n        }\n        _rightYAxisLabel = rightYAxisLabel;\n        _chart.margins().right -= _rightYAxisLabelPadding;\n        _rightYAxisLabelPadding = (padding === undefined) ? DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING : padding;\n        _chart.margins().right += _rightYAxisLabelPadding;\n        return _chart;\n    };\n\n    /**\n     * Combine the given charts into one single composite coordinate grid chart.\n     * @method compose\n     * @memberof dc.compositeChart\n     * @instance\n     * @example\n     * moveChart.compose([\n     *     // when creating sub-chart you need to pass in the parent chart\n     *     dc.lineChart(moveChart)\n     *         .group(indexAvgByMonthGroup) // if group is missing then parent's group will be used\n     *         .valueAccessor(function (d){return d.value.avg;})\n     *         // most of the normal functions will continue to work in a composed chart\n     *         .renderArea(true)\n     *         .stack(monthlyMoveGroup, function (d){return d.value;})\n     *         .title(function (d){\n     *             var value = d.value.avg?d.value.avg:d.value;\n     *             if(isNaN(value)) value = 0;\n     *             return dateFormat(d.key) + '\\n' + numberFormat(value);\n     *         }),\n     *     dc.barChart(moveChart)\n     *         .group(volumeByMonthGroup)\n     *         .centerBar(true)\n     * ]);\n     * @param {Array<Chart>} [subChartArray]\n     * @returns {dc.compositeChart}\n     */\n    _chart.compose = function (subChartArray) {\n        _children = subChartArray;\n        _children.forEach(function (child) {\n            child.height(_chart.height());\n            child.width(_chart.width());\n            child.margins(_chart.margins());\n\n            if (_shareTitle) {\n                child.title(_chart.title());\n            }\n\n            child.options(_childOptions);\n        });\n        return _chart;\n    };\n\n    /**\n     * Returns the child charts which are composed into the composite chart.\n     * @method children\n     * @memberof dc.compositeChart\n     * @instance\n     * @returns {Array<dc.baseMixin>}\n     */\n    _chart.children = function () {\n        return _children;\n    };\n\n    /**\n     * Get or set color sharing for the chart. If set, the {@link dc.colorMixin#colors .colors()} value from this chart\n     * will be shared with composed children. Additionally if the child chart implements\n     * Stackable and has not set a custom .colorAccessor, then it will generate a color\n     * specific to its order in the composition.\n     * @method shareColors\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [shareColors=false]\n     * @returns {Boolean|dc.compositeChart}\n     */\n    _chart.shareColors = function (shareColors) {\n        if (!arguments.length) {\n            return _shareColors;\n        }\n        _shareColors = shareColors;\n        return _chart;\n    };\n\n    /**\n     * Get or set title sharing for the chart. If set, the {@link dc.baseMixin#title .title()} value from\n     * this chart will be shared with composed children.\n     * @method shareTitle\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [shareTitle=true]\n     * @returns {Boolean|dc.compositeChart}\n     */\n    _chart.shareTitle = function (shareTitle) {\n        if (!arguments.length) {\n            return _shareTitle;\n        }\n        _shareTitle = shareTitle;\n        return _chart;\n    };\n\n    /**\n     * Get or set the y scale for the right axis. The right y scale is typically automatically\n     * generated by the chart implementation.\n     * @method rightY\n     * @memberof dc.compositeChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @param {d3.scale} [yScale]\n     * @returns {d3.scale|dc.compositeChart}\n     */\n    _chart.rightY = function (yScale) {\n        if (!arguments.length) {\n            return _rightY;\n        }\n        _rightY = yScale;\n        _chart.rescale();\n        return _chart;\n    };\n\n    /**\n     * Get or set alignment between left and right y axes. A line connecting '0' on both y axis\n     * will be parallel to x axis. This only has effect when {@link #dc.coordinateGridMixin+elasticY elasticY} is true.\n     * @method alignYAxes\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [alignYAxes=false]\n     * @returns {Chart}\n     */\n    _chart.alignYAxes = function (alignYAxes) {\n        if (!arguments.length) {\n            return _alignYAxes;\n        }\n        _alignYAxes = alignYAxes;\n        _chart.rescale();\n        return _chart;\n    };\n\n    function leftYAxisChildren () {\n        return _children.filter(function (child) {\n            return !child.useRightYAxis();\n        });\n    }\n\n    function rightYAxisChildren () {\n        return _children.filter(function (child) {\n            return child.useRightYAxis();\n        });\n    }\n\n    function getYAxisMin (charts) {\n        return charts.map(function (c) {\n            return c.yAxisMin();\n        });\n    }\n\n    delete _chart.yAxisMin;\n    function yAxisMin () {\n        return d3.min(getYAxisMin(leftYAxisChildren()));\n    }\n\n    function rightYAxisMin () {\n        return d3.min(getYAxisMin(rightYAxisChildren()));\n    }\n\n    function getYAxisMax (charts) {\n        return charts.map(function (c) {\n            return c.yAxisMax();\n        });\n    }\n\n    delete _chart.yAxisMax;\n    function yAxisMax () {\n        return dc.utils.add(d3.max(getYAxisMax(leftYAxisChildren())), _chart.yAxisPadding());\n    }\n\n    function rightYAxisMax () {\n        return dc.utils.add(d3.max(getYAxisMax(rightYAxisChildren())), _chart.yAxisPadding());\n    }\n\n    function getAllXAxisMinFromChildCharts () {\n        return _children.map(function (c) {\n            return c.xAxisMin();\n        });\n    }\n\n    dc.override(_chart, 'xAxisMin', function () {\n        return dc.utils.subtract(d3.min(getAllXAxisMinFromChildCharts()), _chart.xAxisPadding());\n    });\n\n    function getAllXAxisMaxFromChildCharts () {\n        return _children.map(function (c) {\n            return c.xAxisMax();\n        });\n    }\n\n    dc.override(_chart, 'xAxisMax', function () {\n        return dc.utils.add(d3.max(getAllXAxisMaxFromChildCharts()), _chart.xAxisPadding());\n    });\n\n    _chart.legendables = function () {\n        return _children.reduce(function (items, child) {\n            if (_shareColors) {\n                child.colors(_chart.colors());\n            }\n            items.push.apply(items, child.legendables());\n            return items;\n        }, []);\n    };\n\n    _chart.legendHighlight = function (d) {\n        for (var j = 0; j < _children.length; ++j) {\n            var child = _children[j];\n            child.legendHighlight(d);\n        }\n    };\n\n    _chart.legendReset = function (d) {\n        for (var j = 0; j < _children.length; ++j) {\n            var child = _children[j];\n            child.legendReset(d);\n        }\n    };\n\n    _chart.legendToggle = function () {\n        console.log('composite should not be getting legendToggle itself');\n    };\n\n    /**\n     * Set or get the right y axis used by the composite chart. This function is most useful when y\n     * axis customization is required. The y axis in dc.js is an instance of a [d3 axis\n     * object](https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis) therefore it supports any valid\n     * d3 axis manipulation.\n     *\n     * **Caution**: The y axis is usually generated internally by dc; resetting it may cause\n     * unexpected results.\n     * @method rightYAxis\n     * @memberof dc.compositeChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize y axis tick format\n     * chart.rightYAxis().tickFormat(function (v) {return v + '%';});\n     * // customize y axis tick values\n     * chart.rightYAxis().tickValues([0, 100, 200, 300]);\n     * @param {d3.svg.axis} [rightYAxis]\n     * @returns {d3.svg.axis|dc.compositeChart}\n     */\n    _chart.rightYAxis = function (rightYAxis) {\n        if (!arguments.length) {\n            return _rightYAxis;\n        }\n        _rightYAxis = rightYAxis;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A series chart is a chart that shows multiple series of data overlaid on one chart, where the\n * series is specified in the data. It is a specialization of Composite Chart and inherits all\n * composite features other than recomposing the chart.\n *\n * Examples:\n * - {@link http://dc-js.github.io/dc.js/examples/series.html Series Chart}\n * @class seriesChart\n * @memberof dc\n * @mixes dc.compositeChart\n * @example\n * // create a series chart under #chart-container1 element using the default global chart group\n * var seriesChart1 = dc.seriesChart(\"#chart-container1\");\n * // create a series chart under #chart-container2 element using chart group A\n * var seriesChart2 = dc.seriesChart(\"#chart-container2\", \"chartGroupA\");\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.seriesChart}\n */\ndc.seriesChart = function (parent, chartGroup) {\n    var _chart = dc.compositeChart(parent, chartGroup);\n\n    function keySort (a, b) {\n        return d3.ascending(_chart.keyAccessor()(a), _chart.keyAccessor()(b));\n    }\n\n    var _charts = {};\n    var _chartFunction = dc.lineChart;\n    var _seriesAccessor;\n    var _seriesSort = d3.ascending;\n    var _valueSort = keySort;\n\n    _chart._mandatoryAttributes().push('seriesAccessor', 'chart');\n    _chart.shareColors(true);\n\n    _chart._preprocessData = function () {\n        var keep = [];\n        var childrenChanged;\n        var nester = d3.nest().key(_seriesAccessor);\n        if (_seriesSort) {\n            nester.sortKeys(_seriesSort);\n        }\n        if (_valueSort) {\n            nester.sortValues(_valueSort);\n        }\n        var nesting = nester.entries(_chart.data());\n        var children =\n            nesting.map(function (sub, i) {\n                var subChart = _charts[sub.key] || _chartFunction.call(_chart, _chart, chartGroup, sub.key, i);\n                if (!_charts[sub.key]) {\n                    childrenChanged = true;\n                }\n                _charts[sub.key] = subChart;\n                keep.push(sub.key);\n                return subChart\n                    .dimension(_chart.dimension())\n                    .group({all: d3.functor(sub.values)}, sub.key)\n                    .keyAccessor(_chart.keyAccessor())\n                    .valueAccessor(_chart.valueAccessor())\n                    .brushOn(_chart.brushOn());\n            });\n        // this works around the fact compositeChart doesn't really\n        // have a removal interface\n        Object.keys(_charts)\n            .filter(function (c) {return keep.indexOf(c) === -1;})\n            .forEach(function (c) {\n                clearChart(c);\n                childrenChanged = true;\n            });\n        _chart._compose(children);\n        if (childrenChanged && _chart.legend()) {\n            _chart.legend().render();\n        }\n    };\n\n    function clearChart (c) {\n        if (_charts[c].g()) {\n            _charts[c].g().remove();\n        }\n        delete _charts[c];\n    }\n\n    function resetChildren () {\n        Object.keys(_charts).map(clearChart);\n        _charts = {};\n    }\n\n    /**\n     * Get or set the chart function, which generates the child charts.\n     * @method chart\n     * @memberof dc.seriesChart\n     * @instance\n     * @example\n     * // put interpolation on the line charts used for the series\n     * chart.chart(function(c) { return dc.lineChart(c).interpolate('basis'); })\n     * // do a scatter series chart\n     * chart.chart(dc.scatterPlot)\n     * @param {Function} [chartFunction=dc.lineChart]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.chart = function (chartFunction) {\n        if (!arguments.length) {\n            return _chartFunction;\n        }\n        _chartFunction = chartFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Get or set accessor function for the displayed series. Given a datum, this function\n     * should return the series that datum belongs to.\n     * @method seriesAccessor\n     * @memberof dc.seriesChart\n     * @instance\n     * @example\n     * // simple series accessor\n     * chart.seriesAccessor(function(d) { return \"Expt: \" + d.key[0]; })\n     * @param {Function} [accessor]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.seriesAccessor = function (accessor) {\n        if (!arguments.length) {\n            return _seriesAccessor;\n        }\n        _seriesAccessor = accessor;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\n     * Get or set a function to sort the list of series by, given series values.\n     * @method seriesSort\n     * @memberof dc.seriesChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * chart.seriesSort(d3.descending);\n     * @param {Function} [sortFunction=d3.ascending]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.seriesSort = function (sortFunction) {\n        if (!arguments.length) {\n            return _seriesSort;\n        }\n        _seriesSort = sortFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\n     * Get or set a function to sort each series values by. By default this is the key accessor which,\n     * for example, will ensure a lineChart series connects its points in increasing key/x order,\n     * rather than haphazardly.\n     * @method valueSort\n     * @memberof dc.seriesChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * // Default value sort\n     * _chart.valueSort(function keySort (a, b) {\n     *     return d3.ascending(_chart.keyAccessor()(a), _chart.keyAccessor()(b));\n     * });\n     * @param {Function} [sortFunction]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.valueSort = function (sortFunction) {\n        if (!arguments.length) {\n            return _valueSort;\n        }\n        _valueSort = sortFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    // make compose private\n    _chart._compose = _chart.compose;\n    delete _chart.compose;\n\n    return _chart;\n};\n\n/**\n * The geo choropleth chart is designed as an easy way to create a crossfilter driven choropleth map\n * from GeoJson data. This chart implementation was inspired by\n * {@link http://bl.ocks.org/4060606 the great d3 choropleth example}.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}\n * @class geoChoroplethChart\n * @memberof dc\n * @mixes dc.colorMixin\n * @mixes dc.baseMixin\n * @example\n * // create a choropleth chart under '#us-chart' element using the default global chart group\n * var chart1 = dc.geoChoroplethChart('#us-chart');\n * // create a choropleth chart under '#us-chart2' element using chart group A\n * var chart2 = dc.compositeChart('#us-chart2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.geoChoroplethChart}\n */\ndc.geoChoroplethChart = function (parent, chartGroup) {\n    var _chart = dc.colorMixin(dc.baseMixin({}));\n\n    _chart.colorAccessor(function (d) {\n        return d || 0;\n    });\n\n    var _geoPath = d3.geo.path();\n    var _projectionFlag;\n\n    var _geoJsons = [];\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n        for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {\n            var states = _chart.svg().append('g')\n                .attr('class', 'layer' + layerIndex);\n\n            var regionG = states.selectAll('g.' + geoJson(layerIndex).name)\n                .data(geoJson(layerIndex).data)\n                .enter()\n                .append('g')\n                .attr('class', geoJson(layerIndex).name);\n\n            regionG\n                .append('path')\n                .attr('fill', 'white')\n                .attr('d', _geoPath);\n\n            regionG.append('title');\n\n            plotData(layerIndex);\n        }\n        _projectionFlag = false;\n    };\n\n    function plotData (layerIndex) {\n        var data = generateLayeredData();\n\n        if (isDataLayer(layerIndex)) {\n            var regionG = renderRegionG(layerIndex);\n\n            renderPaths(regionG, layerIndex, data);\n\n            renderTitle(regionG, layerIndex, data);\n        }\n    }\n\n    function generateLayeredData () {\n        var data = {};\n        var groupAll = _chart.data();\n        for (var i = 0; i < groupAll.length; ++i) {\n            data[_chart.keyAccessor()(groupAll[i])] = _chart.valueAccessor()(groupAll[i]);\n        }\n        return data;\n    }\n\n    function isDataLayer (layerIndex) {\n        return geoJson(layerIndex).keyAccessor;\n    }\n\n    function renderRegionG (layerIndex) {\n        var regionG = _chart.svg()\n            .selectAll(layerSelector(layerIndex))\n            .classed('selected', function (d) {\n                return isSelected(layerIndex, d);\n            })\n            .classed('deselected', function (d) {\n                return isDeselected(layerIndex, d);\n            })\n            .attr('class', function (d) {\n                var layerNameClass = geoJson(layerIndex).name;\n                var regionClass = dc.utils.nameToId(geoJson(layerIndex).keyAccessor(d));\n                var baseClasses = layerNameClass + ' ' + regionClass;\n                if (isSelected(layerIndex, d)) {\n                    baseClasses += ' selected';\n                }\n                if (isDeselected(layerIndex, d)) {\n                    baseClasses += ' deselected';\n                }\n                return baseClasses;\n            });\n        return regionG;\n    }\n\n    function layerSelector (layerIndex) {\n        return 'g.layer' + layerIndex + ' g.' + geoJson(layerIndex).name;\n    }\n\n    function isSelected (layerIndex, d) {\n        return _chart.hasFilter() && _chart.hasFilter(getKey(layerIndex, d));\n    }\n\n    function isDeselected (layerIndex, d) {\n        return _chart.hasFilter() && !_chart.hasFilter(getKey(layerIndex, d));\n    }\n\n    function getKey (layerIndex, d) {\n        return geoJson(layerIndex).keyAccessor(d);\n    }\n\n    function geoJson (index) {\n        return _geoJsons[index];\n    }\n\n    function renderPaths (regionG, layerIndex, data) {\n        var paths = regionG\n            .select('path')\n            .attr('fill', function () {\n                var currentFill = d3.select(this).attr('fill');\n                if (currentFill) {\n                    return currentFill;\n                }\n                return 'none';\n            })\n            .on('click', function (d) {\n                return _chart.onClick(d, layerIndex);\n            });\n\n        dc.transition(paths, _chart.transitionDuration(), _chart.transitionDelay()).attr('fill', function (d, i) {\n            return _chart.getColor(data[geoJson(layerIndex).keyAccessor(d)], i);\n        });\n    }\n\n    _chart.onClick = function (d, layerIndex) {\n        var selectedRegion = geoJson(layerIndex).keyAccessor(d);\n        dc.events.trigger(function () {\n            _chart.filter(selectedRegion);\n            _chart.redrawGroup();\n        });\n    };\n\n    function renderTitle (regionG, layerIndex, data) {\n        if (_chart.renderTitle()) {\n            regionG.selectAll('title').text(function (d) {\n                var key = getKey(layerIndex, d);\n                var value = data[key];\n                return _chart.title()({key: key, value: value});\n            });\n        }\n    }\n\n    _chart._doRedraw = function () {\n        for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {\n            plotData(layerIndex);\n            if (_projectionFlag) {\n                _chart.svg().selectAll('g.' + geoJson(layerIndex).name + ' path').attr('d', _geoPath);\n            }\n        }\n        _projectionFlag = false;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Use this function to insert a new GeoJson map layer. This function can be invoked multiple times\n     * if you have multiple GeoJson data layers to render on top of each other. If you overlay multiple\n     * layers with the same name the new overlay will override the existing one.\n     * @method overlayGeoJson\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @see {@link http://geojson.org/ GeoJSON}\n     * @see {@link https://github.com/topojson/topojson/wiki TopoJSON}\n     * @see {@link https://github.com/topojson/topojson-1.x-api-reference/blob/master/API-Reference.md#wiki-feature topojson.feature}\n     * @example\n     * // insert a layer for rendering US states\n     * chart.overlayGeoJson(statesJson.features, 'state', function(d) {\n     *      return d.properties.name;\n     * });\n     * @param {geoJson} json - a geojson feed\n     * @param {String} name - name of the layer\n     * @param {Function} keyAccessor - accessor function used to extract 'key' from the GeoJson data. The key extracted by\n     * this function should match the keys returned by the crossfilter groups.\n     * @returns {dc.geoChoroplethChart}\n     */\n    _chart.overlayGeoJson = function (json, name, keyAccessor) {\n        for (var i = 0; i < _geoJsons.length; ++i) {\n            if (_geoJsons[i].name === name) {\n                _geoJsons[i].data = json;\n                _geoJsons[i].keyAccessor = keyAccessor;\n                return _chart;\n            }\n        }\n        _geoJsons.push({name: name, data: json, keyAccessor: keyAccessor});\n        return _chart;\n    };\n\n    /**\n     * Set custom geo projection function. See the available\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Projections.md d3 geo projection functions}.\n     * @method projection\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Projections.md d3.geo.projection}\n     * @see {@link https://github.com/d3/d3-geo-projection Extended d3.geo.projection}\n     * @param {d3.projection} [projection=d3.geo.albersUsa()]\n     * @returns {dc.geoChoroplethChart}\n     */\n    _chart.projection = function (projection) {\n        _geoPath.projection(projection);\n        _projectionFlag = true;\n        return _chart;\n    };\n\n    /**\n     * Returns all GeoJson layers currently registered with this chart. The returned array is a\n     * reference to this chart's internal data structure, so any modification to this array will also\n     * modify this chart's internal registration.\n     * @method geoJsons\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @returns {Array<{name:String, data: Object, accessor: Function}>}\n     */\n    _chart.geoJsons = function () {\n        return _geoJsons;\n    };\n\n    /**\n     * Returns the {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Paths.md#path d3.geo.path} object used to\n     * render the projection and features.  Can be useful for figuring out the bounding box of the\n     * feature set and thus a way to calculate scale and translation for the projection.\n     * @method geoPath\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Paths.md#path d3.geo.path}\n     * @returns {d3.geo.path}\n     */\n    _chart.geoPath = function () {\n        return _geoPath;\n    };\n\n    /**\n     * Remove a GeoJson layer from this chart by name\n     * @method removeGeoJson\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @param {String} name\n     * @returns {dc.geoChoroplethChart}\n     */\n    _chart.removeGeoJson = function (name) {\n        var geoJsons = [];\n\n        for (var i = 0; i < _geoJsons.length; ++i) {\n            var layer = _geoJsons[i];\n            if (layer.name !== name) {\n                geoJsons.push(layer);\n            }\n        }\n\n        _geoJsons = geoJsons;\n\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The bubble overlay chart is quite different from the typical bubble chart. With the bubble overlay\n * chart you can arbitrarily place bubbles on an existing svg or bitmap image, thus changing the\n * typical x and y positioning while retaining the capability to visualize data using bubble radius\n * and coloring.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class bubbleOverlay\n * @memberof dc\n * @mixes dc.bubbleMixin\n * @mixes dc.baseMixin\n * @example\n * // create a bubble overlay chart on top of the '#chart-container1 svg' element using the default global chart group\n * var bubbleChart1 = dc.bubbleOverlayChart('#chart-container1').svg(d3.select('#chart-container1 svg'));\n * // create a bubble overlay chart on top of the '#chart-container2 svg' element using chart group A\n * var bubbleChart2 = dc.compositeChart('#chart-container2', 'chartGroupA').svg(d3.select('#chart-container2 svg'));\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.bubbleOverlay}\n */\ndc.bubbleOverlay = function (parent, chartGroup) {\n    var BUBBLE_OVERLAY_CLASS = 'bubble-overlay';\n    var BUBBLE_NODE_CLASS = 'node';\n    var BUBBLE_CLASS = 'bubble';\n\n    /**\n     * **mandatory**\n     *\n     * Set the underlying svg image element. Unlike other dc charts this chart will not generate a svg\n     * element; therefore the bubble overlay chart will not work if this function is not invoked. If the\n     * underlying image is a bitmap, then an empty svg will need to be created on top of the image.\n     * @method svg\n     * @memberof dc.bubbleOverlay\n     * @instance\n     * @example\n     * // set up underlying svg element\n     * chart.svg(d3.select('#chart svg'));\n     * @param {SVGElement|d3.selection} [imageElement]\n     * @returns {dc.bubbleOverlay}\n     */\n    var _chart = dc.bubbleMixin(dc.baseMixin({}));\n    var _g;\n    var _points = [];\n\n    _chart.transitionDuration(750);\n\n    _chart.transitionDelay(0);\n\n    _chart.radiusValueAccessor(function (d) {\n        return d.value;\n    });\n\n    /**\n     * **mandatory**\n     *\n     * Set up a data point on the overlay. The name of a data point should match a specific 'key' among\n     * data groups generated using keyAccessor.  If a match is found (point name <-> data group key)\n     * then a bubble will be generated at the position specified by the function. x and y\n     * value specified here are relative to the underlying svg.\n     * @method point\n     * @memberof dc.bubbleOverlay\n     * @instance\n     * @param {String} name\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {dc.bubbleOverlay}\n     */\n    _chart.point = function (name, x, y) {\n        _points.push({name: name, x: x, y: y});\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        _g = initOverlayG();\n\n        _chart.r().range([_chart.MIN_RADIUS, _chart.width() * _chart.maxBubbleRelativeSize()]);\n\n        initializeBubbles();\n\n        _chart.fadeDeselectedArea();\n\n        return _chart;\n    };\n\n    function initOverlayG () {\n        _g = _chart.select('g.' + BUBBLE_OVERLAY_CLASS);\n        if (_g.empty()) {\n            _g = _chart.svg().append('g').attr('class', BUBBLE_OVERLAY_CLASS);\n        }\n        return _g;\n    }\n\n    function initializeBubbles () {\n        var data = mapData();\n        _chart.calculateRadiusDomain();\n\n        _points.forEach(function (point) {\n            var nodeG = getNodeG(point, data);\n\n            var circle = nodeG.select('circle.' + BUBBLE_CLASS);\n\n            if (circle.empty()) {\n                circle = nodeG.append('circle')\n                    .attr('class', BUBBLE_CLASS)\n                    .attr('r', 0)\n                    .attr('fill', _chart.getColor)\n                    .on('click', _chart.onClick);\n            }\n\n            dc.transition(circle, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('r', function (d) {\n                    return _chart.bubbleR(d);\n                });\n\n            _chart._doRenderLabel(nodeG);\n\n            _chart._doRenderTitles(nodeG);\n        });\n    }\n\n    function mapData () {\n        var data = {};\n        _chart.data().forEach(function (datum) {\n            data[_chart.keyAccessor()(datum)] = datum;\n        });\n        return data;\n    }\n\n    function getNodeG (point, data) {\n        var bubbleNodeClass = BUBBLE_NODE_CLASS + ' ' + dc.utils.nameToId(point.name);\n\n        var nodeG = _g.select('g.' + dc.utils.nameToId(point.name));\n\n        if (nodeG.empty()) {\n            nodeG = _g.append('g')\n                .attr('class', bubbleNodeClass)\n                .attr('transform', 'translate(' + point.x + ',' + point.y + ')');\n        }\n\n        nodeG.datum(data[point.name]);\n\n        return nodeG;\n    }\n\n    _chart._doRedraw = function () {\n        updateBubbles();\n\n        _chart.fadeDeselectedArea();\n\n        return _chart;\n    };\n\n    function updateBubbles () {\n        var data = mapData();\n        _chart.calculateRadiusDomain();\n\n        _points.forEach(function (point) {\n            var nodeG = getNodeG(point, data);\n\n            var circle = nodeG.select('circle.' + BUBBLE_CLASS);\n\n            dc.transition(circle, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('r', function (d) {\n                    return _chart.bubbleR(d);\n                })\n                .attr('fill', _chart.getColor);\n\n            _chart.doUpdateLabels(nodeG);\n\n            _chart.doUpdateTitles(nodeG);\n        });\n    }\n\n    _chart.debug = function (flag) {\n        if (flag) {\n            var debugG = _chart.select('g.' + dc.constants.DEBUG_GROUP_CLASS);\n\n            if (debugG.empty()) {\n                debugG = _chart.svg()\n                    .append('g')\n                    .attr('class', dc.constants.DEBUG_GROUP_CLASS);\n            }\n\n            var debugText = debugG.append('text')\n                .attr('x', 10)\n                .attr('y', 20);\n\n            debugG\n                .append('rect')\n                .attr('width', _chart.width())\n                .attr('height', _chart.height())\n                .on('mousemove', function () {\n                    var position = d3.mouse(debugG.node());\n                    var msg = position[0] + ', ' + position[1];\n                    debugText.text(msg);\n                });\n        } else {\n            _chart.selectAll('.debug').remove();\n        }\n\n        return _chart;\n    };\n\n    _chart.anchor(parent, chartGroup);\n\n    return _chart;\n};\n\n/**\n * Concrete row chart implementation.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * @class rowChart\n * @memberof dc\n * @mixes dc.capMixin\n * @mixes dc.marginMixin\n * @mixes dc.colorMixin\n * @mixes dc.baseMixin\n * @example\n * // create a row chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.rowChart('#chart-container1');\n * // create a row chart under #chart-container2 element using chart group A\n * var chart2 = dc.rowChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.rowChart}\n */\ndc.rowChart = function (parent, chartGroup) {\n\n    var _g;\n\n    var _labelOffsetX = 10;\n    var _labelOffsetY = 15;\n    var _hasLabelOffsetY = false;\n    var _dyOffset = '0.35em';  // this helps center labels https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#svg_text\n    var _titleLabelOffsetX = 2;\n\n    var _gap = 5;\n\n    var _fixedBarHeight = false;\n    var _rowCssClass = 'row';\n    var _titleRowCssClass = 'titlerow';\n    var _renderTitleLabel = false;\n\n    var _chart = dc.capMixin(dc.marginMixin(dc.colorMixin(dc.baseMixin({}))));\n\n    var _x;\n\n    var _elasticX;\n\n    var _xAxis = d3.svg.axis().orient('bottom');\n\n    var _rowData;\n\n    _chart.rowsCap = _chart.cap;\n\n    function calculateAxisScale () {\n        if (!_x || _elasticX) {\n            var extent = d3.extent(_rowData, _chart.cappedValueAccessor);\n            if (extent[0] > 0) {\n                extent[0] = 0;\n            }\n            if (extent[1] < 0) {\n                extent[1] = 0;\n            }\n            _x = d3.scale.linear().domain(extent)\n                .range([0, _chart.effectiveWidth()]);\n        }\n        _xAxis.scale(_x);\n    }\n\n    function drawAxis () {\n        var axisG = _g.select('g.axis');\n\n        calculateAxisScale();\n\n        if (axisG.empty()) {\n            axisG = _g.append('g').attr('class', 'axis');\n        }\n        axisG.attr('transform', 'translate(0, ' + _chart.effectiveHeight() + ')');\n\n        dc.transition(axisG, _chart.transitionDuration(), _chart.transitionDelay())\n            .call(_xAxis);\n    }\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _g = _chart.svg()\n            .append('g')\n            .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n\n        drawChart();\n\n        return _chart;\n    };\n\n    _chart.title(function (d) {\n        return _chart.cappedKeyAccessor(d) + ': ' + _chart.cappedValueAccessor(d);\n    });\n\n    _chart.label(_chart.cappedKeyAccessor);\n\n    /**\n     * Gets or sets the x scale. The x scale can be any d3\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale}.\n     * @method x\n     * @memberof dc.rowChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale}\n     * @param {d3.scale} [scale]\n     * @returns {d3.scale|dc.rowChart}\n     */\n    _chart.x = function (scale) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = scale;\n        return _chart;\n    };\n\n    function drawGridLines () {\n        _g.selectAll('g.tick')\n            .select('line.grid-line')\n            .remove();\n\n        _g.selectAll('g.tick')\n            .append('line')\n            .attr('class', 'grid-line')\n            .attr('x1', 0)\n            .attr('y1', 0)\n            .attr('x2', 0)\n            .attr('y2', function () {\n                return -_chart.effectiveHeight();\n            });\n    }\n\n    function drawChart () {\n        _rowData = _chart.data();\n\n        drawAxis();\n        drawGridLines();\n\n        var rows = _g.selectAll('g.' + _rowCssClass)\n            .data(_rowData);\n\n        createElements(rows);\n        removeElements(rows);\n        updateElements(rows);\n    }\n\n    function createElements (rows) {\n        var rowEnter = rows.enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return _rowCssClass + ' _' + i;\n            });\n\n        rowEnter.append('rect').attr('width', 0);\n\n        createLabels(rowEnter);\n    }\n\n    function removeElements (rows) {\n        rows.exit().remove();\n    }\n\n    function rootValue () {\n        var root = _x(0);\n        return (root === -Infinity || root !== root) ? _x(1) : root;\n    }\n\n    function updateElements (rows) {\n        var n = _rowData.length;\n\n        var height;\n        if (!_fixedBarHeight) {\n            height = (_chart.effectiveHeight() - (n + 1) * _gap) / n;\n        } else {\n            height = _fixedBarHeight;\n        }\n\n        // vertically align label in center unless they override the value via property setter\n        if (!_hasLabelOffsetY) {\n            _labelOffsetY = height / 2;\n        }\n\n        var rect = rows.attr('transform', function (d, i) {\n                return 'translate(0,' + ((i + 1) * _gap + i * height) + ')';\n            }).select('rect')\n            .attr('height', height)\n            .attr('fill', _chart.getColor)\n            .on('click', onClick)\n            .classed('deselected', function (d) {\n                return (_chart.hasFilter()) ? !isSelectedRow(d) : false;\n            })\n            .classed('selected', function (d) {\n                return (_chart.hasFilter()) ? isSelectedRow(d) : false;\n            });\n\n        dc.transition(rect, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('width', function (d) {\n                return Math.abs(rootValue() - _x(_chart.valueAccessor()(d)));\n            })\n            .attr('transform', translateX);\n\n        createTitles(rows);\n        updateLabels(rows);\n    }\n\n    function createTitles (rows) {\n        if (_chart.renderTitle()) {\n            rows.select('title').remove();\n            rows.append('title').text(_chart.title());\n        }\n    }\n\n    function createLabels (rowEnter) {\n        if (_chart.renderLabel()) {\n            rowEnter.append('text')\n                .on('click', onClick);\n        }\n        if (_chart.renderTitleLabel()) {\n            rowEnter.append('text')\n                .attr('class', _titleRowCssClass)\n                .on('click', onClick);\n        }\n    }\n\n    function updateLabels (rows) {\n        if (_chart.renderLabel()) {\n            var lab = rows.select('text')\n                .attr('x', _labelOffsetX)\n                .attr('y', _labelOffsetY)\n                .attr('dy', _dyOffset)\n                .on('click', onClick)\n                .attr('class', function (d, i) {\n                    return _rowCssClass + ' _' + i;\n                })\n                .text(function (d) {\n                    return _chart.label()(d);\n                });\n            dc.transition(lab, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('transform', translateX);\n        }\n        if (_chart.renderTitleLabel()) {\n            var titlelab = rows.select('.' + _titleRowCssClass)\n                    .attr('x', _chart.effectiveWidth() - _titleLabelOffsetX)\n                    .attr('y', _labelOffsetY)\n                    .attr('dy', _dyOffset)\n                    .attr('text-anchor', 'end')\n                    .on('click', onClick)\n                    .attr('class', function (d, i) {\n                        return _titleRowCssClass + ' _' + i ;\n                    })\n                    .text(function (d) {\n                        return _chart.title()(d);\n                    });\n            dc.transition(titlelab, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('transform', translateX);\n        }\n    }\n\n    /**\n     * Turn on/off Title label rendering (values) using SVG style of text-anchor 'end'.\n     * @method renderTitleLabel\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Boolean} [renderTitleLabel=false]\n     * @returns {Boolean|dc.rowChart}\n     */\n    _chart.renderTitleLabel = function (renderTitleLabel) {\n        if (!arguments.length) {\n            return _renderTitleLabel;\n        }\n        _renderTitleLabel = renderTitleLabel;\n        return _chart;\n    };\n\n    function onClick (d) {\n        _chart.onClick(d);\n    }\n\n    function translateX (d) {\n        var x = _x(_chart.cappedValueAccessor(d)),\n            x0 = rootValue(),\n            s = x > x0 ? x0 : x;\n        return 'translate(' + s + ',0)';\n    }\n\n    _chart._doRedraw = function () {\n        drawChart();\n        return _chart;\n    };\n\n    /**\n     * Get the x axis for the row chart instance.  Note: not settable for row charts.\n     * See the {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3 axis object}\n     * documention for more information.\n     * @method xAxis\n     * @memberof dc.rowChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize x axis tick format\n     * chart.xAxis().tickFormat(function (v) {return v + '%';});\n     * // customize x axis tick values\n     * chart.xAxis().tickValues([0, 100, 200, 300]);\n     * @returns {d3.svg.axis}\n     */\n    _chart.xAxis = function () {\n        return _xAxis;\n    };\n\n    /**\n     * Get or set the fixed bar height. Default is [false] which will auto-scale bars.\n     * For example, if you want to fix the height for a specific number of bars (useful in TopN charts)\n     * you could fix height as follows (where count = total number of bars in your TopN and gap is\n     * your vertical gap space).\n     * @method fixedBarHeight\n     * @memberof dc.rowChart\n     * @instance\n     * @example\n     * chart.fixedBarHeight( chartheight - (count + 1) * gap / count);\n     * @param {Boolean|Number} [fixedBarHeight=false]\n     * @returns {Boolean|Number|dc.rowChart}\n     */\n    _chart.fixedBarHeight = function (fixedBarHeight) {\n        if (!arguments.length) {\n            return _fixedBarHeight;\n        }\n        _fixedBarHeight = fixedBarHeight;\n        return _chart;\n    };\n\n    /**\n     * Get or set the vertical gap space between rows on a particular row chart instance.\n     * @method gap\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [gap=5]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _chart;\n    };\n\n    /**\n     * Get or set the elasticity on x axis. If this attribute is set to true, then the x axis will rescle to auto-fit the\n     * data range when filtered.\n     * @method elasticX\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Boolean} [elasticX]\n     * @returns {Boolean|dc.rowChart}\n     */\n    _chart.elasticX = function (elasticX) {\n        if (!arguments.length) {\n            return _elasticX;\n        }\n        _elasticX = elasticX;\n        return _chart;\n    };\n\n    /**\n     * Get or set the x offset (horizontal space to the top left corner of a row) for labels on a particular row chart.\n     * @method labelOffsetX\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [labelOffsetX=10]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.labelOffsetX = function (labelOffsetX) {\n        if (!arguments.length) {\n            return _labelOffsetX;\n        }\n        _labelOffsetX = labelOffsetX;\n        return _chart;\n    };\n\n    /**\n     * Get or set the y offset (vertical space to the top left corner of a row) for labels on a particular row chart.\n     * @method labelOffsetY\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [labelOffsety=15]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.labelOffsetY = function (labelOffsety) {\n        if (!arguments.length) {\n            return _labelOffsetY;\n        }\n        _labelOffsetY = labelOffsety;\n        _hasLabelOffsetY = true;\n        return _chart;\n    };\n\n    /**\n     * Get of set the x offset (horizontal space between right edge of row and right edge or text.\n     * @method titleLabelOffsetX\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [titleLabelOffsetX=2]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.titleLabelOffsetX = function (titleLabelOffsetX) {\n        if (!arguments.length) {\n            return _titleLabelOffsetX;\n        }\n        _titleLabelOffsetX = titleLabelOffsetX;\n        return _chart;\n    };\n\n    function isSelectedRow (d) {\n        return _chart.hasFilter(_chart.cappedKeyAccessor(d));\n    }\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Legend is a attachable widget that can be added to other dc charts to render horizontal legend\n * labels.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class legend\n * @memberof dc\n * @example\n * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))\n * @returns {dc.legend}\n */\ndc.legend = function () {\n    var LABEL_GAP = 2;\n\n    var _legend = {},\n        _parent,\n        _x = 0,\n        _y = 0,\n        _itemHeight = 12,\n        _gap = 5,\n        _horizontal = false,\n        _legendWidth = 560,\n        _itemWidth = 70,\n        _autoItemWidth = false,\n        _legendText = dc.pluck('name'),\n        _maxItems;\n\n    var _g;\n\n    _legend.parent = function (p) {\n        if (!arguments.length) {\n            return _parent;\n        }\n        _parent = p;\n        return _legend;\n    };\n\n    _legend.render = function () {\n        _parent.svg().select('g.dc-legend').remove();\n        _g = _parent.svg().append('g')\n            .attr('class', 'dc-legend')\n            .attr('transform', 'translate(' + _x + ',' + _y + ')');\n        var legendables = _parent.legendables();\n\n        if (_maxItems !== undefined) {\n            legendables = legendables.slice(0, _maxItems);\n        }\n\n        var itemEnter = _g.selectAll('g.dc-legend-item')\n            .data(legendables)\n            .enter()\n            .append('g')\n            .attr('class', 'dc-legend-item')\n            .on('mouseover', function (d) {\n                _parent.legendHighlight(d);\n            })\n            .on('mouseout', function (d) {\n                _parent.legendReset(d);\n            })\n            .on('click', function (d) {\n                d.chart.legendToggle(d);\n            });\n\n        _g.selectAll('g.dc-legend-item')\n            .classed('fadeout', function (d) {\n                return d.chart.isLegendableHidden(d);\n            });\n\n        if (legendables.some(dc.pluck('dashstyle'))) {\n            itemEnter\n                .append('line')\n                .attr('x1', 0)\n                .attr('y1', _itemHeight / 2)\n                .attr('x2', _itemHeight)\n                .attr('y2', _itemHeight / 2)\n                .attr('stroke-width', 2)\n                .attr('stroke-dasharray', dc.pluck('dashstyle'))\n                .attr('stroke', dc.pluck('color'));\n        } else {\n            itemEnter\n                .append('rect')\n                .attr('width', _itemHeight)\n                .attr('height', _itemHeight)\n                .attr('fill', function (d) {return d ? d.color : 'blue';});\n        }\n\n        itemEnter.append('text')\n                .text(_legendText)\n                .attr('x', _itemHeight + LABEL_GAP)\n                .attr('y', function () {\n                    return _itemHeight / 2 + (this.clientHeight ? this.clientHeight : 13) / 2 - 2;\n                });\n\n        var _cumulativeLegendTextWidth = 0;\n        var row = 0;\n        itemEnter.attr('transform', function (d, i) {\n            if (_horizontal) {\n                var itemWidth   = _autoItemWidth === true ? this.getBBox().width + _gap : _itemWidth;\n                if ((_cumulativeLegendTextWidth + itemWidth) > _legendWidth && _cumulativeLegendTextWidth > 0) {\n                    ++row;\n                    _cumulativeLegendTextWidth = 0;\n                }\n                var translateBy = 'translate(' + _cumulativeLegendTextWidth + ',' + row * legendItemHeight() + ')';\n                _cumulativeLegendTextWidth += itemWidth;\n                return translateBy;\n            } else {\n                return 'translate(0,' + i * legendItemHeight() + ')';\n            }\n        });\n    };\n\n    function legendItemHeight () {\n        return _gap + _itemHeight;\n    }\n\n    /**\n     * Set or get x coordinate for legend widget.\n     * @method x\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [x=0]\n     * @returns {Number|dc.legend}\n     */\n    _legend.x = function (x) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = x;\n        return _legend;\n    };\n\n    /**\n     * Set or get y coordinate for legend widget.\n     * @method y\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [y=0]\n     * @returns {Number|dc.legend}\n     */\n    _legend.y = function (y) {\n        if (!arguments.length) {\n            return _y;\n        }\n        _y = y;\n        return _legend;\n    };\n\n    /**\n     * Set or get gap between legend items.\n     * @method gap\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [gap=5]\n     * @returns {Number|dc.legend}\n     */\n    _legend.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _legend;\n    };\n\n    /**\n     * Set or get legend item height.\n     * @method itemHeight\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [itemHeight=12]\n     * @returns {Number|dc.legend}\n     */\n    _legend.itemHeight = function (itemHeight) {\n        if (!arguments.length) {\n            return _itemHeight;\n        }\n        _itemHeight = itemHeight;\n        return _legend;\n    };\n\n    /**\n     * Position legend horizontally instead of vertically.\n     * @method horizontal\n     * @memberof dc.legend\n     * @instance\n     * @param  {Boolean} [horizontal=false]\n     * @returns {Boolean|dc.legend}\n     */\n    _legend.horizontal = function (horizontal) {\n        if (!arguments.length) {\n            return _horizontal;\n        }\n        _horizontal = horizontal;\n        return _legend;\n    };\n\n    /**\n     * Maximum width for horizontal legend.\n     * @method legendWidth\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [legendWidth=500]\n     * @returns {Number|dc.legend}\n     */\n    _legend.legendWidth = function (legendWidth) {\n        if (!arguments.length) {\n            return _legendWidth;\n        }\n        _legendWidth = legendWidth;\n        return _legend;\n    };\n\n    /**\n     * Legend item width for horizontal legend.\n     * @method itemWidth\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [itemWidth=70]\n     * @returns {Number|dc.legend}\n     */\n    _legend.itemWidth = function (itemWidth) {\n        if (!arguments.length) {\n            return _itemWidth;\n        }\n        _itemWidth = itemWidth;\n        return _legend;\n    };\n\n    /**\n     * Turn automatic width for legend items on or off. If true, {@link dc.legend#itemWidth itemWidth} is ignored.\n     * This setting takes into account the {@link dc.legend#gap gap}.\n     * @method autoItemWidth\n     * @memberof dc.legend\n     * @instance\n     * @param  {Boolean} [autoItemWidth=false]\n     * @returns {Boolean|dc.legend}\n     */\n    _legend.autoItemWidth = function (autoItemWidth) {\n        if (!arguments.length) {\n            return _autoItemWidth;\n        }\n        _autoItemWidth = autoItemWidth;\n        return _legend;\n    };\n\n    /**\n     * Set or get the legend text function. The legend widget uses this function to render the legend\n     * text for each item. If no function is specified the legend widget will display the names\n     * associated with each group.\n     * @method legendText\n     * @memberof dc.legend\n     * @instance\n     * @param  {Function} [legendText]\n     * @returns {Function|dc.legend}\n     * @example\n     * // default legendText\n     * legend.legendText(dc.pluck('name'))\n     *\n     * // create numbered legend items\n     * chart.legend(dc.legend().legendText(function(d, i) { return i + '. ' + d.name; }))\n     *\n     * // create legend displaying group counts\n     * chart.legend(dc.legend().legendText(function(d) { return d.name + ': ' d.data; }))\n     **/\n    _legend.legendText = function (legendText) {\n        if (!arguments.length) {\n            return _legendText;\n        }\n        _legendText = legendText;\n        return _legend;\n    };\n\n    /**\n     * Maximum number of legend items to display\n     * @method maxItems\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [maxItems]\n     * @return {dc.legend}\n     */\n    _legend.maxItems = function (maxItems) {\n        if (!arguments.length) {\n            return _maxItems;\n        }\n        _maxItems = dc.utils.isNumber(maxItems) ? maxItems : undefined;\n        return _legend;\n    };\n\n    return _legend;\n};\n\n/**\n * A scatter plot chart\n *\n * Examples:\n * - {@link http://dc-js.github.io/dc.js/examples/scatter.html Scatter Chart}\n * - {@link http://dc-js.github.io/dc.js/examples/multi-scatter.html Multi-Scatter Chart}\n * @class scatterPlot\n * @memberof dc\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a scatter plot under #chart-container1 element using the default global chart group\n * var chart1 = dc.scatterPlot('#chart-container1');\n * // create a scatter plot under #chart-container2 element using chart group A\n * var chart2 = dc.scatterPlot('#chart-container2', 'chartGroupA');\n * // create a sub-chart under a composite parent chart\n * var chart3 = dc.scatterPlot(compositeChart);\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.scatterPlot}\n */\ndc.scatterPlot = function (parent, chartGroup) {\n    var _chart = dc.coordinateGridMixin({});\n    var _symbol = d3.svg.symbol();\n\n    var _existenceAccessor = function (d) { return d.value; };\n\n    var originalKeyAccessor = _chart.keyAccessor();\n    _chart.keyAccessor(function (d) { return originalKeyAccessor(d)[0]; });\n    _chart.valueAccessor(function (d) { return originalKeyAccessor(d)[1]; });\n    _chart.colorAccessor(function () { return _chart._groupName; });\n\n    _chart.title(function (d) {\n        // this basically just counteracts the setting of its own key/value accessors\n        // see https://github.com/dc-js/dc.js/issues/702\n        return _chart.keyAccessor()(d) + ',' + _chart.valueAccessor()(d) + ': ' +\n            _chart.existenceAccessor()(d);\n    });\n\n    var _locator = function (d) {\n        return 'translate(' + _chart.x()(_chart.keyAccessor()(d)) + ',' +\n                              _chart.y()(_chart.valueAccessor()(d)) + ')';\n    };\n\n    var _highlightedSize = 7;\n    var _symbolSize = 5;\n    var _excludedSize = 3;\n    var _excludedColor = null;\n    var _excludedOpacity = 1.0;\n    var _emptySize = 0;\n    var _emptyOpacity = 0;\n    var _nonemptyOpacity = 1;\n    var _emptyColor = null;\n    var _filtered = [];\n\n    function elementSize (d, i) {\n        if (!_existenceAccessor(d)) {\n            return Math.pow(_emptySize, 2);\n        } else if (_filtered[i]) {\n            return Math.pow(_symbolSize, 2);\n        } else {\n            return Math.pow(_excludedSize, 2);\n        }\n    }\n    _symbol.size(elementSize);\n\n    dc.override(_chart, '_filter', function (filter) {\n        if (!arguments.length) {\n            return _chart.__filter();\n        }\n\n        return _chart.__filter(dc.filters.RangedTwoDimensionalFilter(filter));\n    });\n\n    _chart.plotData = function () {\n        var symbols = _chart.chartBodyG().selectAll('path.symbol')\n            .data(_chart.data());\n\n        symbols\n            .enter()\n        .append('path')\n            .attr('class', 'symbol')\n            .attr('opacity', 0)\n            .attr('fill', _chart.getColor)\n            .attr('transform', _locator);\n\n        symbols.call(renderTitles, _chart.data());\n\n        symbols.each(function (d, i) {\n            _filtered[i] = !_chart.filter() || _chart.filter().isFiltered([d.key[0], d.key[1]]);\n        });\n\n        dc.transition(symbols, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('opacity', function (d, i) {\n                if (!_existenceAccessor(d)) {\n                    return _emptyOpacity;\n                } else if (_filtered[i]) {\n                    return _nonemptyOpacity;\n                } else {\n                    return _chart.excludedOpacity();\n                }\n            })\n            .attr('fill', function (d, i) {\n                if (_emptyColor && !_existenceAccessor(d)) {\n                    return _emptyColor;\n                } else if (_chart.excludedColor() && !_filtered[i]) {\n                    return _chart.excludedColor();\n                } else {\n                    return _chart.getColor(d);\n                }\n            })\n            .attr('transform', _locator)\n            .attr('d', _symbol);\n\n        dc.transition(symbols.exit(), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('opacity', 0).remove();\n    };\n\n    function renderTitles (symbol, d) {\n        if (_chart.renderTitle()) {\n            symbol.selectAll('title').remove();\n            symbol.append('title').text(function (d) {\n                return _chart.title()(d);\n            });\n        }\n    }\n\n    /**\n     * Get or set the existence accessor.  If a point exists, it is drawn with\n     * {@link dc.scatterPlot#symbolSize symbolSize} radius and\n     * opacity 1; if it does not exist, it is drawn with\n     * {@link dc.scatterPlot#emptySize emptySize} radius and opacity 0. By default,\n     * the existence accessor checks if the reduced value is truthy.\n     * @method existenceAccessor\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link dc.scatterPlot#symbolSize symbolSize}\n     * @see {@link dc.scatterPlot#emptySize emptySize}\n     * @example\n     * // default accessor\n     * chart.existenceAccessor(function (d) { return d.value; });\n     * @param {Function} [accessor]\n     * @returns {Function|dc.scatterPlot}\n     */\n    _chart.existenceAccessor = function (accessor) {\n        if (!arguments.length) {\n            return _existenceAccessor;\n        }\n        _existenceAccessor = accessor;\n        return this;\n    };\n\n    /**\n     * Get or set the symbol type used for each point. By default the symbol is a circle.\n     * Type can be a constant or an accessor.\n     * @method symbol\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_type d3.svg.symbol.type}\n     * @example\n     * // Circle type\n     * chart.symbol('circle');\n     * // Square type\n     * chart.symbol('square');\n     * @param {String|Function} [type='circle']\n     * @returns {String|Function|dc.scatterPlot}\n     */\n    _chart.symbol = function (type) {\n        if (!arguments.length) {\n            return _symbol.type();\n        }\n        _symbol.type(type);\n        return _chart;\n    };\n\n    /**\n     * Get or set the symbol generator. By default `dc.scatterPlot` will use\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol d3.svg.symbol()}\n     * to generate symbols. `dc.scatterPlot` will set the\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size size accessor}\n     * on the symbol generator.\n     * @method customSymbol\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol d3.svg.symbol}\n     * @see {@link https://stackoverflow.com/questions/25332120/create-additional-d3-js-symbols Create additional D3.js symbols}\n     * @param {String|Function} [customSymbol=d3.svg.symbol()]\n     * @returns {String|Function|dc.scatterPlot}\n     */\n    _chart.customSymbol = function (customSymbol) {\n        if (!arguments.length) {\n            return _symbol;\n        }\n        _symbol = customSymbol;\n        _symbol.size(elementSize);\n        return _chart;\n    };\n\n    /**\n     * Set or get radius for symbols.\n     * @method symbolSize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [symbolSize=3]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.symbolSize = function (symbolSize) {\n        if (!arguments.length) {\n            return _symbolSize;\n        }\n        _symbolSize = symbolSize;\n        return _chart;\n    };\n\n    /**\n     * Set or get radius for highlighted symbols.\n     * @method highlightedSize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [highlightedSize=5]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.highlightedSize = function (highlightedSize) {\n        if (!arguments.length) {\n            return _highlightedSize;\n        }\n        _highlightedSize = highlightedSize;\n        return _chart;\n    };\n\n    /**\n     * Set or get size for symbols excluded from this chart's filter. If null, no\n     * special size is applied for symbols based on their filter status.\n     * @method excludedSize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [excludedSize=null]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.excludedSize = function (excludedSize) {\n        if (!arguments.length) {\n            return _excludedSize;\n        }\n        _excludedSize = excludedSize;\n        return _chart;\n    };\n\n    /**\n     * Set or get color for symbols excluded from this chart's filter. If null, no\n     * special color is applied for symbols based on their filter status.\n     * @method excludedColor\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [excludedColor=null]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.excludedColor = function (excludedColor) {\n        if (!arguments.length) {\n            return _excludedColor;\n        }\n        _excludedColor = excludedColor;\n        return _chart;\n    };\n\n    /**\n     * Set or get opacity for symbols excluded from this chart's filter.\n     * @method excludedOpacity\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [excludedOpacity=1.0]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.excludedOpacity = function (excludedOpacity) {\n        if (!arguments.length) {\n            return _excludedOpacity;\n        }\n        _excludedOpacity = excludedOpacity;\n        return _chart;\n    };\n\n    /**\n     * Set or get radius for symbols when the group is empty.\n     * @method emptySize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [emptySize=0]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.hiddenSize = _chart.emptySize = function (emptySize) {\n        if (!arguments.length) {\n            return _emptySize;\n        }\n        _emptySize = emptySize;\n        return _chart;\n    };\n\n    /**\n     * Set or get color for symbols when the group is empty. If null, just use the\n     * {@link dc.colorMixin#colors colorMixin.colors} color scale zero value.\n     * @name emptyColor\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {String} [emptyColor=null]\n     * @return {String}\n     * @return {dc.scatterPlot}/\n     */\n    _chart.emptyColor = function (emptyColor) {\n        if (!arguments.length) {\n            return _emptyColor;\n        }\n        _emptyColor = emptyColor;\n        return _chart;\n    };\n\n    /**\n     * Set or get opacity for symbols when the group is empty.\n     * @name emptyOpacity\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [emptyOpacity=0]\n     * @return {Number}\n     * @return {dc.scatterPlot}\n     */\n    _chart.emptyOpacity = function (emptyOpacity) {\n        if (!arguments.length) {\n            return _emptyOpacity;\n        }\n        _emptyOpacity = emptyOpacity;\n        return _chart;\n    };\n\n    /**\n     * Set or get opacity for symbols when the group is not empty.\n     * @name nonemptyOpacity\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [nonemptyOpacity=1]\n     * @return {Number}\n     * @return {dc.scatterPlot}\n     */\n    _chart.nonemptyOpacity = function (nonemptyOpacity) {\n        if (!arguments.length) {\n            return _emptyOpacity;\n        }\n        _nonemptyOpacity = nonemptyOpacity;\n        return _chart;\n    };\n\n    _chart.legendables = function () {\n        return [{chart: _chart, name: _chart._groupName, color: _chart.getColor()}];\n    };\n\n    _chart.legendHighlight = function (d) {\n        resizeSymbolsWhere(function (symbol) {\n            return symbol.attr('fill') === d.color;\n        }, _highlightedSize);\n        _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return d3.select(this).attr('fill') !== d.color;\n        }).classed('fadeout', true);\n    };\n\n    _chart.legendReset = function (d) {\n        resizeSymbolsWhere(function (symbol) {\n            return symbol.attr('fill') === d.color;\n        }, _symbolSize);\n        _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return d3.select(this).attr('fill') !== d.color;\n        }).classed('fadeout', false);\n    };\n\n    function resizeSymbolsWhere (condition, size) {\n        var symbols = _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return condition(d3.select(this));\n        });\n        var oldSize = _symbol.size();\n        _symbol.size(Math.pow(size, 2));\n        dc.transition(symbols, _chart.transitionDuration(), _chart.transitionDelay()).attr('d', _symbol);\n        _symbol.size(oldSize);\n    }\n\n    _chart.setHandlePaths = function () {\n        // no handle paths for poly-brushes\n    };\n\n    _chart.extendBrush = function () {\n        var extent = _chart.brush().extent();\n        if (_chart.round()) {\n            extent[0] = extent[0].map(_chart.round());\n            extent[1] = extent[1].map(_chart.round());\n\n            _chart.g().select('.brush')\n                .call(_chart.brush().extent(extent));\n        }\n        return extent;\n    };\n\n    _chart.brushIsEmpty = function (extent) {\n        return _chart.brush().empty() || !extent || extent[0][0] >= extent[1][0] || extent[0][1] >= extent[1][1];\n    };\n\n    _chart._brushing = function () {\n        var extent = _chart.extendBrush();\n\n        _chart.redrawBrush(_chart.g());\n\n        if (_chart.brushIsEmpty(extent)) {\n            dc.events.trigger(function () {\n                _chart.filter(null);\n                _chart.redrawGroup();\n            });\n\n        } else {\n            var ranged2DFilter = dc.filters.RangedTwoDimensionalFilter(extent);\n            dc.events.trigger(function () {\n                _chart.filter(null);\n                _chart.filter(ranged2DFilter);\n                _chart.redrawGroup();\n            }, dc.constants.EVENT_DELAY);\n\n        }\n    };\n\n    _chart.setBrushY = function (gBrush) {\n        gBrush.call(_chart.brush().y(_chart.y()));\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A display of a single numeric value.\n * Unlike other charts, you do not need to set a dimension. Instead a group object must be provided and\n * a valueAccessor that returns a single value.\n * @class numberDisplay\n * @memberof dc\n * @mixes dc.baseMixin\n * @example\n * // create a number display under #chart-container1 element using the default global chart group\n * var display1 = dc.numberDisplay('#chart-container1');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.numberDisplay}\n */\ndc.numberDisplay = function (parent, chartGroup) {\n    var SPAN_CLASS = 'number-display';\n    var _formatNumber = d3.format('.2s');\n    var _chart = dc.baseMixin({});\n    var _html = {one: '', some: '', none: ''};\n    var _lastValue;\n\n    // dimension not required\n    _chart._mandatoryAttributes(['group']);\n\n    // default to ordering by value, to emulate old group.top(1) behavior when multiple groups\n    _chart.ordering(function (kv) { return kv.value; });\n\n    /**\n     * Gets or sets an optional object specifying HTML templates to use depending on the number\n     * displayed.  The text `%number` will be replaced with the current value.\n     * - one: HTML template to use if the number is 1\n     * - zero: HTML template to use if the number is 0\n     * - some: HTML template to use otherwise\n     * @method html\n     * @memberof dc.numberDisplay\n     * @instance\n     * @example\n     * numberWidget.html({\n     *      one:'%number record',\n     *      some:'%number records',\n     *      none:'no records'})\n     * @param {{one:String, some:String, none:String}} [html={one: '', some: '', none: ''}]\n     * @returns {{one:String, some:String, none:String}|dc.numberDisplay}\n     */\n    _chart.html = function (html) {\n        if (!arguments.length) {\n            return _html;\n        }\n        if (html.none) {\n            _html.none = html.none;//if none available\n        } else if (html.one) {\n            _html.none = html.one;//if none not available use one\n        } else if (html.some) {\n            _html.none = html.some;//if none and one not available use some\n        }\n        if (html.one) {\n            _html.one = html.one;//if one available\n        } else if (html.some) {\n            _html.one = html.some;//if one not available use some\n        }\n        if (html.some) {\n            _html.some = html.some;//if some available\n        } else if (html.one) {\n            _html.some = html.one;//if some not available use one\n        }\n        return _chart;\n    };\n\n    /**\n     * Calculate and return the underlying value of the display.\n     * @method value\n     * @memberof dc.numberDisplay\n     * @instance\n     * @returns {Number}\n     */\n    _chart.value = function () {\n        return _chart.data();\n    };\n\n    function maxBin (all) {\n        if (!all.length) {\n            return null;\n        }\n        var sorted = _chart._computeOrderedGroups(all);\n        return sorted[sorted.length - 1];\n    }\n    _chart.data(function (group) {\n        var valObj = group.value ? group.value() : maxBin(group.all());\n        return _chart.valueAccessor()(valObj);\n    });\n\n    _chart.transitionDuration(250); // good default\n    _chart.transitionDelay(0);\n\n    _chart._doRender = function () {\n        var newValue = _chart.value(),\n            span = _chart.selectAll('.' + SPAN_CLASS);\n\n        if (span.empty()) {\n            span = span.data([0])\n                .enter()\n                .append('span')\n                .attr('class', SPAN_CLASS);\n        }\n\n        span.transition()\n            .duration(_chart.transitionDuration())\n            .delay(_chart.transitionDelay())\n            .ease('quad-out-in')\n            .tween('text', function () {\n                // [XA] don't try and interpolate from Infinity, else this breaks.\n                var interpStart = isFinite(_lastValue) ? _lastValue : 0;\n                var interp = d3.interpolateNumber(interpStart || 0, newValue);\n                _lastValue = newValue;\n                return function (t) {\n                    var html = null, num = _chart.formatNumber()(interp(t));\n                    if (newValue === 0 && (_html.none !== '')) {\n                        html = _html.none;\n                    } else if (newValue === 1 && (_html.one !== '')) {\n                        html = _html.one;\n                    } else if (_html.some !== '') {\n                        html = _html.some;\n                    }\n                    this.innerHTML = html ? html.replace('%number', num) : num;\n                };\n            });\n    };\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\n     * Get or set a function to format the value for the display.\n     * @method formatNumber\n     * @memberof dc.numberDisplay\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Formatting.md d3.format}\n     * @param {Function} [formatter=d3.format('.2s')]\n     * @returns {Function|dc.numberDisplay}\n     */\n    _chart.formatNumber = function (formatter) {\n        if (!arguments.length) {\n            return _formatNumber;\n        }\n        _formatNumber = formatter;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A heat map is matrix that represents the values of two dimensions of data using colors.\n * @class heatMap\n * @memberof dc\n * @mixes dc.colorMixin\n * @mixes dc.marginMixin\n * @mixes dc.baseMixin\n * @example\n * // create a heat map under #chart-container1 element using the default global chart group\n * var heatMap1 = dc.heatMap('#chart-container1');\n * // create a heat map under #chart-container2 element using chart group A\n * var heatMap2 = dc.heatMap('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.heatMap}\n */\ndc.heatMap = function (parent, chartGroup) {\n\n    var DEFAULT_BORDER_RADIUS = 6.75;\n\n    var _chartBody;\n\n    var _cols;\n    var _rows;\n    var _colOrdering = d3.ascending;\n    var _rowOrdering = d3.ascending;\n    var _colScale = d3.scale.ordinal();\n    var _rowScale = d3.scale.ordinal();\n\n    var _xBorderRadius = DEFAULT_BORDER_RADIUS;\n    var _yBorderRadius = DEFAULT_BORDER_RADIUS;\n\n    var _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin({})));\n    _chart._mandatoryAttributes(['group']);\n    _chart.title(_chart.colorAccessor());\n\n    var _colsLabel = function (d) {\n        return d;\n    };\n    var _rowsLabel = function (d) {\n        return d;\n    };\n\n    /**\n     * Set or get the column label function. The chart class uses this function to render\n     * column labels on the X axis. It is passed the column name.\n     * @method colsLabel\n     * @memberof dc.heatMap\n     * @instance\n     * @example\n     * // the default label function just returns the name\n     * chart.colsLabel(function(d) { return d; });\n     * @param  {Function} [labelFunction=function(d) { return d; }]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.colsLabel = function (labelFunction) {\n        if (!arguments.length) {\n            return _colsLabel;\n        }\n        _colsLabel = labelFunction;\n        return _chart;\n    };\n\n    /**\n     * Set or get the row label function. The chart class uses this function to render\n     * row labels on the Y axis. It is passed the row name.\n     * @method rowsLabel\n     * @memberof dc.heatMap\n     * @instance\n     * @example\n     * // the default label function just returns the name\n     * chart.rowsLabel(function(d) { return d; });\n     * @param  {Function} [labelFunction=function(d) { return d; }]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.rowsLabel = function (labelFunction) {\n        if (!arguments.length) {\n            return _rowsLabel;\n        }\n        _rowsLabel = labelFunction;\n        return _chart;\n    };\n\n    var _xAxisOnClick = function (d) { filterAxis(0, d); };\n    var _yAxisOnClick = function (d) { filterAxis(1, d); };\n    var _boxOnClick = function (d) {\n        var filter = d.key;\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    function filterAxis (axis, value) {\n        var cellsOnAxis = _chart.selectAll('.box-group').filter(function (d) {\n            return d.key[axis] === value;\n        });\n        var unfilteredCellsOnAxis = cellsOnAxis.filter(function (d) {\n            return !_chart.hasFilter(d.key);\n        });\n        dc.events.trigger(function () {\n            var selection = unfilteredCellsOnAxis.empty() ? cellsOnAxis : unfilteredCellsOnAxis;\n            var filters = selection.data().map(function (kv) {\n                return dc.filters.TwoDimensionalFilter(kv.key);\n            });\n            _chart._filter([filters]);\n            _chart.redrawGroup();\n        });\n    }\n\n    dc.override(_chart, 'filter', function (filter) {\n        if (!arguments.length) {\n            return _chart._filter();\n        }\n\n        return _chart._filter(dc.filters.TwoDimensionalFilter(filter));\n    });\n\n    /**\n     * Gets or sets the values used to create the rows of the heatmap, as an array. By default, all\n     * the values will be fetched from the data using the value accessor.\n     * @method rows\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Array<String|Number>} [rows]\n     * @returns {Array<String|Number>|dc.heatMap}\n     */\n\n    _chart.rows = function (rows) {\n        if (!arguments.length) {\n            return _rows;\n        }\n        _rows = rows;\n        return _chart;\n    };\n\n    /**\n     #### .rowOrdering([orderFunction])\n     Get or set an accessor to order the rows.  Default is d3.ascending.\n     */\n    _chart.rowOrdering = function (_) {\n        if (!arguments.length) {\n            return _rowOrdering;\n        }\n        _rowOrdering = _;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the keys used to create the columns of the heatmap, as an array. By default, all\n     * the values will be fetched from the data using the key accessor.\n     * @method cols\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Array<String|Number>} [cols]\n     * @returns {Array<String|Number>|dc.heatMap}\n     */\n    _chart.cols = function (cols) {\n        if (!arguments.length) {\n            return _cols;\n        }\n        _cols = cols;\n        return _chart;\n    };\n\n    /**\n     #### .colOrdering([orderFunction])\n     Get or set an accessor to order the cols.  Default is ascending.\n     */\n    _chart.colOrdering = function (_) {\n        if (!arguments.length) {\n            return _colOrdering;\n        }\n        _colOrdering = _;\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _chartBody = _chart.svg()\n            .append('g')\n            .attr('class', 'heatmap')\n            .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n\n        return _chart._doRedraw();\n    };\n\n    _chart._doRedraw = function () {\n        var data = _chart.data(),\n            rows = _chart.rows() || data.map(_chart.valueAccessor()),\n            cols = _chart.cols() || data.map(_chart.keyAccessor());\n        if (_rowOrdering) {\n            rows = rows.sort(_rowOrdering);\n        }\n        if (_colOrdering) {\n            cols = cols.sort(_colOrdering);\n        }\n        rows = _rowScale.domain(rows);\n        cols = _colScale.domain(cols);\n\n        var rowCount = rows.domain().length,\n            colCount = cols.domain().length,\n            boxWidth = Math.floor(_chart.effectiveWidth() / colCount),\n            boxHeight = Math.floor(_chart.effectiveHeight() / rowCount);\n\n        cols.rangeRoundBands([0, _chart.effectiveWidth()]);\n        rows.rangeRoundBands([_chart.effectiveHeight(), 0]);\n\n        var boxes = _chartBody.selectAll('g.box-group').data(_chart.data(), function (d, i) {\n            return _chart.keyAccessor()(d, i) + '\\0' + _chart.valueAccessor()(d, i);\n        });\n        var gEnter = boxes.enter().append('g')\n            .attr('class', 'box-group');\n\n        gEnter.append('rect')\n            .attr('class', 'heat-box')\n            .attr('fill', 'white')\n            .on('click', _chart.boxOnClick());\n\n        if (_chart.renderTitle()) {\n            gEnter.append('title');\n            boxes.select('title').text(_chart.title());\n        }\n\n        dc.transition(boxes.select('rect'), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d, i) { return cols(_chart.keyAccessor()(d, i)); })\n            .attr('y', function (d, i) { return rows(_chart.valueAccessor()(d, i)); })\n            .attr('rx', _xBorderRadius)\n            .attr('ry', _yBorderRadius)\n            .attr('fill', _chart.getColor)\n            .attr('width', boxWidth)\n            .attr('height', boxHeight);\n\n        boxes.exit().remove();\n\n        var gCols = _chartBody.select('g.cols');\n        if (gCols.empty()) {\n            gCols = _chartBody.append('g').attr('class', 'cols axis');\n        }\n        var gColsText = gCols.selectAll('text').data(cols.domain());\n        gColsText.enter().append('text')\n              .attr('x', function (d) { return cols(d) + boxWidth / 2; })\n              .style('text-anchor', 'middle')\n              .attr('y', _chart.effectiveHeight())\n              .attr('dy', 12)\n              .on('click', _chart.xAxisOnClick())\n              .text(_chart.colsLabel());\n        dc.transition(gColsText, _chart.transitionDuration(), _chart.transitionDelay())\n               .text(_chart.colsLabel())\n               .attr('x', function (d) { return cols(d) + boxWidth / 2; })\n               .attr('y', _chart.effectiveHeight());\n        gColsText.exit().remove();\n        var gRows = _chartBody.select('g.rows');\n        if (gRows.empty()) {\n            gRows = _chartBody.append('g').attr('class', 'rows axis');\n        }\n        var gRowsText = gRows.selectAll('text').data(rows.domain());\n        gRowsText.enter().append('text')\n              .attr('dy', 6)\n              .style('text-anchor', 'end')\n              .attr('x', 0)\n              .attr('dx', -2)\n              .on('click', _chart.yAxisOnClick())\n              .text(_chart.rowsLabel());\n        dc.transition(gRowsText, _chart.transitionDuration(), _chart.transitionDelay())\n              .text(_chart.rowsLabel())\n              .attr('y', function (d) { return rows(d) + boxHeight / 2; });\n        gRowsText.exit().remove();\n\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.box-group').each(function (d) {\n                if (_chart.isSelectedNode(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.box-group').each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the handler that fires when an individual cell is clicked in the heatmap.\n     * By default, filtering of the cell will be toggled.\n     * @method boxOnClick\n     * @memberof dc.heatMap\n     * @instance\n     * @example\n     * // default box on click handler\n     * chart.boxOnClick(function (d) {\n     *     var filter = d.key;\n     *     dc.events.trigger(function () {\n     *         _chart.filter(filter);\n     *         _chart.redrawGroup();\n     *     });\n     * });\n     * @param  {Function} [handler]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.boxOnClick = function (handler) {\n        if (!arguments.length) {\n            return _boxOnClick;\n        }\n        _boxOnClick = handler;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the handler that fires when a column tick is clicked in the x axis.\n     * By default, if any cells in the column are unselected, the whole column will be selected,\n     * otherwise the whole column will be unselected.\n     * @method xAxisOnClick\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Function} [handler]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.xAxisOnClick = function (handler) {\n        if (!arguments.length) {\n            return _xAxisOnClick;\n        }\n        _xAxisOnClick = handler;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the handler that fires when a row tick is clicked in the y axis.\n     * By default, if any cells in the row are unselected, the whole row will be selected,\n     * otherwise the whole row will be unselected.\n     * @method yAxisOnClick\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Function} [handler]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.yAxisOnClick = function (handler) {\n        if (!arguments.length) {\n            return _yAxisOnClick;\n        }\n        _yAxisOnClick = handler;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the X border radius.  Set to 0 to get full rectangles.\n     * @method xBorderRadius\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Number} [xBorderRadius=6.75]\n     * @returns {Number|dc.heatMap}\n     */\n    _chart.xBorderRadius = function (xBorderRadius) {\n        if (!arguments.length) {\n            return _xBorderRadius;\n        }\n        _xBorderRadius = xBorderRadius;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the Y border radius.  Set to 0 to get full rectangles.\n     * @method yBorderRadius\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Number} [yBorderRadius=6.75]\n     * @returns {Number|dc.heatMap}\n     */\n    _chart.yBorderRadius = function (yBorderRadius) {\n        if (!arguments.length) {\n            return _yBorderRadius;\n        }\n        _yBorderRadius = yBorderRadius;\n        return _chart;\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(d.key);\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n// https://github.com/d3/d3-plugins/blob/master/box/box.js\n(function () {\n\n    // Inspired by http://informationandvisualization.de/blog/box-plot\n    d3.box = function () {\n        var width = 1,\n            height = 1,\n            duration = 0,\n            delay = 0,\n            domain = null,\n            value = Number,\n            whiskers = boxWhiskers,\n            quartiles = boxQuartiles,\n            tickFormat = null;\n\n        // For each small multiple…\n        function box (g) {\n            g.each(function (d, i) {\n                d = d.map(value).sort(d3.ascending);\n                var g = d3.select(this),\n                    n = d.length,\n                    min = d[0],\n                    max = d[n - 1];\n\n                // Compute quartiles. Must return exactly 3 elements.\n                var quartileData = d.quartiles = quartiles(d);\n\n                // Compute whiskers. Must return exactly 2 elements, or null.\n                var whiskerIndices = whiskers && whiskers.call(this, d, i),\n                    whiskerData = whiskerIndices && whiskerIndices.map(function (i) { return d[i]; });\n\n                // Compute outliers. If no whiskers are specified, all data are 'outliers'.\n                // We compute the outliers as indices, so that we can join across transitions!\n                var outlierIndices = whiskerIndices ?\n                    d3.range(0, whiskerIndices[0]).concat(d3.range(whiskerIndices[1] + 1, n)) : d3.range(n);\n\n                // Compute the new x-scale.\n                var x1 = d3.scale.linear()\n                    .domain(domain && domain.call(this, d, i) || [min, max])\n                    .range([height, 0]);\n\n                // Retrieve the old x-scale, if this is an update.\n                var x0 = this.__chart__ || d3.scale.linear()\n                    .domain([0, Infinity])\n                    .range(x1.range());\n\n                // Stash the new scale.\n                this.__chart__ = x1;\n\n                // Note: the box, median, and box tick elements are fixed in number,\n                // so we only have to handle enter and update. In contrast, the outliers\n                // and other elements are variable, so we need to exit them! Variable\n                // elements also fade in and out.\n\n                // Update center line: the vertical line spanning the whiskers.\n                var center = g.selectAll('line.center')\n                    .data(whiskerData ? [whiskerData] : []);\n\n                center.enter().insert('line', 'rect')\n                    .attr('class', 'center')\n                    .attr('x1', width / 2)\n                    .attr('y1', function (d) { return x0(d[0]); })\n                    .attr('x2', width / 2)\n                    .attr('y2', function (d) { return x0(d[1]); })\n                    .style('opacity', 1e-6)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .style('opacity', 1)\n                    .attr('y1', function (d) { return x1(d[0]); })\n                    .attr('y2', function (d) { return x1(d[1]); });\n\n                center.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .style('opacity', 1)\n                    .attr('x1', width / 2)\n                    .attr('x2', width / 2)\n                    .attr('y1', function (d) { return x1(d[0]); })\n                    .attr('y2', function (d) { return x1(d[1]); });\n\n                center.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .style('opacity', 1e-6)\n                    .attr('y1', function (d) { return x1(d[0]); })\n                    .attr('y2', function (d) { return x1(d[1]); })\n                    .remove();\n\n                // Update innerquartile box.\n                var box = g.selectAll('rect.box')\n                    .data([quartileData]);\n\n                box.enter().append('rect')\n                    .attr('class', 'box')\n                    .attr('x', 0)\n                    .attr('y', function (d) { return x0(d[2]); })\n                    .attr('width', width)\n                    .attr('height', function (d) { return x0(d[0]) - x0(d[2]); })\n                  .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', function (d) { return x1(d[2]); })\n                    .attr('height', function (d) { return x1(d[0]) - x1(d[2]); });\n\n                box.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('width', width)\n                    .attr('y', function (d) { return x1(d[2]); })\n                    .attr('height', function (d) { return x1(d[0]) - x1(d[2]); });\n\n                // Update median line.\n                var medianLine = g.selectAll('line.median')\n                    .data([quartileData[1]]);\n\n                medianLine.enter().append('line')\n                    .attr('class', 'median')\n                    .attr('x1', 0)\n                    .attr('y1', x0)\n                    .attr('x2', width)\n                    .attr('y2', x0)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y1', x1)\n                    .attr('y2', x1);\n\n                medianLine.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('x1', 0)\n                    .attr('x2', width)\n                    .attr('y1', x1)\n                    .attr('y2', x1);\n\n                // Update whiskers.\n                var whisker = g.selectAll('line.whisker')\n                    .data(whiskerData || []);\n\n                whisker.enter().insert('line', 'circle, text')\n                    .attr('class', 'whisker')\n                    .attr('x1', 0)\n                    .attr('y1', x0)\n                    .attr('x2', width)\n                    .attr('y2', x0)\n                    .style('opacity', 1e-6)\n                  .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y1', x1)\n                    .attr('y2', x1)\n                    .style('opacity', 1);\n\n                whisker.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('x1', 0)\n                    .attr('x2', width)\n                    .attr('y1', x1)\n                    .attr('y2', x1)\n                    .style('opacity', 1);\n\n                whisker.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y1', x1)\n                    .attr('y2', x1)\n                    .style('opacity', 1e-6)\n                    .remove();\n\n                // Update outliers.\n                var outlier = g.selectAll('circle.outlier')\n                    .data(outlierIndices, Number);\n\n                outlier.enter().insert('circle', 'text')\n                    .attr('class', 'outlier')\n                    .attr('r', 5)\n                    .attr('cx', width / 2)\n                    .attr('cy', function (i) { return x0(d[i]); })\n                    .style('opacity', 1e-6)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('cy', function (i) { return x1(d[i]); })\n                    .style('opacity', 1);\n\n                outlier.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('cx', width / 2)\n                    .attr('cy', function (i) { return x1(d[i]); })\n                    .style('opacity', 1);\n\n                outlier.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('cy', function (i) { return x1(d[i]); })\n                    .style('opacity', 1e-6)\n                    .remove();\n\n                // Compute the tick format.\n                var format = tickFormat || x1.tickFormat(8);\n\n                // Update box ticks.\n                var boxTick = g.selectAll('text.box')\n                    .data(quartileData);\n\n                boxTick.enter().append('text')\n                    .attr('class', 'box')\n                    .attr('dy', '.3em')\n                    .attr('dx', function (d, i) { return i & 1 ? 6 : -6; })\n                    .attr('x', function (d, i) { return i & 1 ? width : 0; })\n                    .attr('y', x0)\n                    .attr('text-anchor', function (d, i) { return i & 1 ? 'start' : 'end'; })\n                    .text(format)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', x1);\n\n                boxTick.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .text(format)\n                    .attr('x', function (d, i) { return i & 1 ? width : 0; })\n                    .attr('y', x1);\n\n                // Update whisker ticks. These are handled separately from the box\n                // ticks because they may or may not exist, and we want don't want\n                // to join box ticks pre-transition with whisker ticks post-.\n                var whiskerTick = g.selectAll('text.whisker')\n                    .data(whiskerData || []);\n\n                whiskerTick.enter().append('text')\n                    .attr('class', 'whisker')\n                    .attr('dy', '.3em')\n                    .attr('dx', 6)\n                    .attr('x', width)\n                    .attr('y', x0)\n                    .text(format)\n                    .style('opacity', 1e-6)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', x1)\n                    .style('opacity', 1);\n\n                whiskerTick.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .text(format)\n                    .attr('x', width)\n                    .attr('y', x1)\n                    .style('opacity', 1);\n\n                whiskerTick.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', x1)\n                    .style('opacity', 1e-6)\n                    .remove();\n            });\n            d3.timer.flush();\n        }\n\n        box.width = function (x) {\n            if (!arguments.length) {\n                return width;\n            }\n            width = x;\n            return box;\n        };\n\n        box.height = function (x) {\n            if (!arguments.length) {\n                return height;\n            }\n            height = x;\n            return box;\n        };\n\n        box.tickFormat = function (x) {\n            if (!arguments.length) {\n                return tickFormat;\n            }\n            tickFormat = x;\n            return box;\n        };\n\n        box.duration = function (x) {\n            if (!arguments.length) {\n                return duration;\n            }\n            duration = x;\n            return box;\n        };\n\n        box.domain = function (x) {\n            if (!arguments.length) {\n                return domain;\n            }\n            domain = x === null ? x : d3.functor(x);\n            return box;\n        };\n\n        box.value = function (x) {\n            if (!arguments.length) {\n                return value;\n            }\n            value = x;\n            return box;\n        };\n\n        box.whiskers = function (x) {\n            if (!arguments.length) {\n                return whiskers;\n            }\n            whiskers = x;\n            return box;\n        };\n\n        box.quartiles = function (x) {\n            if (!arguments.length) {\n                return quartiles;\n            }\n            quartiles = x;\n            return box;\n        };\n\n        return box;\n    };\n\n    function boxWhiskers (d) {\n        return [0, d.length - 1];\n    }\n\n    function boxQuartiles (d) {\n        return [\n            d3.quantile(d, 0.25),\n            d3.quantile(d, 0.5),\n            d3.quantile(d, 0.75)\n        ];\n    }\n\n})();\n\n\n/**\n * A box plot is a chart that depicts numerical data via their quartile ranges.\n *\n * Examples:\n * - {@link http://dc-js.github.io/dc.js/examples/box-plot-time.html Box plot time example}\n * - {@link http://dc-js.github.io/dc.js/examples/box-plot.html Box plot example}\n * @class boxPlot\n * @memberof dc\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a box plot under #chart-container1 element using the default global chart group\n * var boxPlot1 = dc.boxPlot('#chart-container1');\n * // create a box plot under #chart-container2 element using chart group A\n * var boxPlot2 = dc.boxPlot('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.boxPlot}\n */\ndc.boxPlot = function (parent, chartGroup) {\n    var _chart = dc.coordinateGridMixin({});\n\n    // Returns a function to compute the interquartile range.\n    function DEFAULT_WHISKERS_IQR (k) {\n        return function (d) {\n            var q1 = d.quartiles[0],\n                q3 = d.quartiles[2],\n                iqr = (q3 - q1) * k,\n                i = -1,\n                j = d.length;\n            do { ++i; } while (d[i] < q1 - iqr);\n            do { --j; } while (d[j] > q3 + iqr);\n            return [i, j];\n        };\n    }\n\n    var _whiskerIqrFactor = 1.5;\n    var _whiskersIqr = DEFAULT_WHISKERS_IQR;\n    var _whiskers = _whiskersIqr(_whiskerIqrFactor);\n\n    var _box = d3.box();\n    var _tickFormat = null;\n\n    var _boxWidth = function (innerChartWidth, xUnits) {\n        if (_chart.isOrdinal()) {\n            return _chart.x().rangeBand();\n        } else {\n            return innerChartWidth / (1 + _chart.boxPadding()) / xUnits;\n        }\n    };\n\n    // default padding to handle min/max whisker text\n    _chart.yAxisPadding(12);\n\n    // default to ordinal\n    _chart.x(d3.scale.ordinal());\n    _chart.xUnits(dc.units.ordinal);\n\n    // valueAccessor should return an array of values that can be coerced into numbers\n    // or if data is overloaded for a static array of arrays, it should be `Number`.\n    // Empty arrays are not included.\n    _chart.data(function (group) {\n        return group.all().map(function (d) {\n            d.map = function (accessor) { return accessor.call(d, d); };\n            return d;\n        }).filter(function (d) {\n            var values = _chart.valueAccessor()(d);\n            return values.length !== 0;\n        });\n    });\n\n    /**\n     * Get or set the spacing between boxes as a fraction of box size. Valid values are within 0-1.\n     * See the {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3 docs}\n     * for a visual description of how the padding is applied.\n     * @method boxPadding\n     * @memberof dc.boxPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3.scale.ordinal.rangeBands}\n     * @param {Number} [padding=0.8]\n     * @returns {Number|dc.boxPlot}\n     */\n    _chart.boxPadding = _chart._rangeBandPadding;\n    _chart.boxPadding(0.8);\n\n    /**\n     * Get or set the outer padding on an ordinal box chart. This setting has no effect on non-ordinal charts\n     * or on charts with a custom {@link dc.boxPlot#boxWidth .boxWidth}. Will pad the width by\n     * `padding * barWidth` on each side of the chart.\n     * @method outerPadding\n     * @memberof dc.boxPlot\n     * @instance\n     * @param {Number} [padding=0.5]\n     * @returns {Number|dc.boxPlot}\n     */\n    _chart.outerPadding = _chart._outerRangeBandPadding;\n    _chart.outerPadding(0.5);\n\n    /**\n     * Get or set the numerical width of the boxplot box. The width may also be a function taking as\n     * parameters the chart width excluding the right and left margins, as well as the number of x\n     * units.\n     * @example\n     * // Using numerical parameter\n     * chart.boxWidth(10);\n     * // Using function\n     * chart.boxWidth((innerChartWidth, xUnits) { ... });\n     * @method boxWidth\n     * @memberof dc.boxPlot\n     * @instance\n     * @param {Number|Function} [boxWidth=0.5]\n     * @returns {Number|Function|dc.boxPlot}\n     */\n    _chart.boxWidth = function (boxWidth) {\n        if (!arguments.length) {\n            return _boxWidth;\n        }\n        _boxWidth = d3.functor(boxWidth);\n        return _chart;\n    };\n\n    var boxTransform = function (d, i) {\n        var xOffset = _chart.x()(_chart.keyAccessor()(d, i));\n        return 'translate(' + xOffset + ', 0)';\n    };\n\n    _chart._preprocessData = function () {\n        if (_chart.elasticX()) {\n            _chart.x().domain([]);\n        }\n    };\n\n    _chart.plotData = function () {\n        var _calculatedBoxWidth = _boxWidth(_chart.effectiveWidth(), _chart.xUnitCount());\n\n        _box.whiskers(_whiskers)\n            .width(_calculatedBoxWidth)\n            .height(_chart.effectiveHeight())\n            .value(_chart.valueAccessor())\n            .domain(_chart.y().domain())\n            .duration(_chart.transitionDuration())\n            .tickFormat(_tickFormat);\n\n        var boxesG = _chart.chartBodyG().selectAll('g.box').data(_chart.data(), _chart.keyAccessor());\n\n        renderBoxes(boxesG);\n        updateBoxes(boxesG);\n        removeBoxes(boxesG);\n\n        _chart.fadeDeselectedArea();\n    };\n\n    function renderBoxes (boxesG) {\n        var boxesGEnter = boxesG.enter().append('g');\n\n        boxesGEnter\n            .attr('class', 'box')\n            .attr('transform', boxTransform)\n            .call(_box)\n            .on('click', function (d) {\n                _chart.filter(_chart.keyAccessor()(d));\n                _chart.redrawGroup();\n            });\n    }\n\n    function updateBoxes (boxesG) {\n        dc.transition(boxesG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', boxTransform)\n            .call(_box)\n            .each(function () {\n                d3.select(this).select('rect.box').attr('fill', _chart.getColor);\n            });\n    }\n\n    function removeBoxes (boxesG) {\n        boxesG.exit().remove().call(_box);\n    }\n\n    _chart.fadeDeselectedArea = function () {\n        if (_chart.hasFilter()) {\n            if (_chart.isOrdinal()) {\n                _chart.g().selectAll('g.box').each(function (d) {\n                    if (_chart.isSelectedNode(d)) {\n                        _chart.highlightSelected(this);\n                    } else {\n                        _chart.fadeDeselected(this);\n                    }\n                });\n            } else {\n                var extent = _chart.brush().extent();\n                var start = extent[0];\n                var end = extent[1];\n                var keyAccessor = _chart.keyAccessor();\n                _chart.g().selectAll('g.box').each(function (d) {\n                    var key = keyAccessor(d);\n                    if (key < start || key >= end) {\n                        _chart.fadeDeselected(this);\n                    } else {\n                        _chart.highlightSelected(this);\n                    }\n                });\n            }\n        } else {\n            _chart.g().selectAll('g.box').each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(_chart.keyAccessor()(d));\n    };\n\n    _chart.yAxisMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return d3.min(_chart.valueAccessor()(e));\n        });\n        return dc.utils.subtract(min, _chart.yAxisPadding());\n    };\n\n    _chart.yAxisMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return d3.max(_chart.valueAccessor()(e));\n        });\n        return dc.utils.add(max, _chart.yAxisPadding());\n    };\n\n    /**\n     * Set the numerical format of the boxplot median, whiskers and quartile labels. Defaults to\n     * integer formatting.\n     * @example\n     * // format ticks to 2 decimal places\n     * chart.tickFormat(d3.format('.2f'));\n     * @method tickFormat\n     * @memberof dc.boxPlot\n     * @instance\n     * @param {Function} [tickFormat]\n     * @returns {Number|Function|dc.boxPlot}\n     */\n    _chart.tickFormat = function (tickFormat) {\n        if (!arguments.length) {\n            return _tickFormat;\n        }\n        _tickFormat = tickFormat;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The select menu is a simple widget designed to filter a dimension by selecting an option from\n * an HTML `<select/>` menu. The menu can be optionally turned into a multiselect.\n * @class selectMenu\n * @memberof dc\n * @mixes dc.baseMixin\n * @example\n * // create a select menu under #select-container using the default global chart group\n * var select = dc.selectMenu('#select-container')\n *                .dimension(states)\n *                .group(stateGroup);\n * // the option text can be set via the title() function\n * // by default the option text is '`key`: `value`'\n * select.title(function (d){\n *     return 'STATE: ' + d.key;\n * })\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\n * [d3 single selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this widget should be placed in.\n * Interaction with the widget will only trigger events and redraws within its group.\n * @returns {selectMenu}\n **/\ndc.selectMenu = function (parent, chartGroup) {\n    var SELECT_CSS_CLASS = 'dc-select-menu';\n    var OPTION_CSS_CLASS = 'dc-select-option';\n\n    var _chart = dc.baseMixin({});\n\n    var _select;\n    var _promptText = 'Select all';\n    var _multiple = false;\n    var _promptValue = null;\n    var _numberVisible = null;\n    var _order = function (a, b) {\n        return _chart.keyAccessor()(a) > _chart.keyAccessor()(b) ?\n             1 : _chart.keyAccessor()(b) > _chart.keyAccessor()(a) ?\n            -1 : 0;\n    };\n\n    var _filterDisplayed = function (d) {\n        return _chart.valueAccessor()(d) > 0;\n    };\n\n    _chart.data(function (group) {\n        return group.all().filter(_filterDisplayed);\n    });\n\n    _chart._doRender = function () {\n        _chart.select('select').remove();\n        _select = _chart.root().append('select')\n                        .classed(SELECT_CSS_CLASS, true);\n        _select.append('option').text(_promptText).attr('value', '');\n\n        _chart._doRedraw();\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        setAttributes();\n        renderOptions();\n        // select the option(s) corresponding to current filter(s)\n        if (_chart.hasFilter() && _multiple) {\n            _select.selectAll('option')\n                .property('selected', function (d) {\n                    return d && _chart.filters().indexOf(String(_chart.keyAccessor()(d))) >= 0;\n                });\n        } else if (_chart.hasFilter()) {\n            _select.property('value', _chart.filter());\n        } else {\n            _select.property('value', '');\n        }\n        return _chart;\n    };\n\n    function renderOptions () {\n        var options = _select.selectAll('option.' + OPTION_CSS_CLASS)\n          .data(_chart.data(), function (d) { return _chart.keyAccessor()(d); });\n\n        options.enter()\n              .append('option')\n              .classed(OPTION_CSS_CLASS, true)\n              .attr('value', function (d) { return _chart.keyAccessor()(d); });\n\n        options.text(_chart.title());\n        options.exit().remove();\n        _select.selectAll('option.' + OPTION_CSS_CLASS).sort(_order);\n\n        _select.on('change', onChange);\n        return options;\n    }\n\n    function onChange (d, i) {\n        var values;\n        var target = d3.event.target;\n        if (target.selectedOptions) {\n            var selectedOptions = Array.prototype.slice.call(target.selectedOptions);\n            values = selectedOptions.map(function (d) {\n                return d.value;\n            });\n        } else { // IE and other browsers do not support selectedOptions\n            // adapted from this polyfill: https://gist.github.com/brettz9/4212217\n            var options = [].slice.call(d3.event.target.options);\n            values = options.filter(function (option) {\n                return option.selected;\n            }).map(function (option) {\n                return option.value;\n            });\n        }\n        // console.log(values);\n        // check if only prompt option is selected\n        if (values.length === 1 && values[0] === '') {\n            values = _promptValue || null;\n        } else if (!_multiple && values.length === 1) {\n            values = values[0];\n        }\n        _chart.onChange(values);\n    }\n\n    _chart.onChange = function (val) {\n        if (val && _multiple) {\n            _chart.replaceFilter([val]);\n        } else if (val) {\n            _chart.replaceFilter(val);\n        } else {\n            _chart.filterAll();\n        }\n        dc.events.trigger(function () {\n            _chart.redrawGroup();\n        });\n    };\n\n    function setAttributes () {\n        if (_multiple) {\n            _select.attr('multiple', true);\n        } else {\n            _select.attr('multiple', null);\n        }\n        if (_numberVisible !== null) {\n            _select.attr('size', _numberVisible);\n        } else {\n            _select.attr('size', null);\n        }\n    }\n\n    /**\n     * Get or set the function that controls the ordering of option tags in the\n     * select menu. By default options are ordered by the group key in ascending\n     * order.\n     * @name order\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {Function} [order]\n     * @example\n     * // order by the group's value\n     * chart.order(function (a,b) {\n     *     return a.value > b.value ? 1 : b.value > a.value ? -1 : 0;\n     * });\n     **/\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    /**\n     * Get or set the text displayed in the options used to prompt selection.\n     * @name promptText\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {String} [promptText='Select all']\n     * @example\n     * chart.promptText('All states');\n     **/\n    _chart.promptText = function (_) {\n        if (!arguments.length) {\n            return _promptText;\n        }\n        _promptText = _;\n        return _chart;\n    };\n\n    /**\n     * Get or set the function that filters option tags prior to display. By default options\n     * with a value of < 1 are not displayed.\n     * @name filterDisplayed\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {function} [filterDisplayed]\n     * @example\n     * // display all options override the `filterDisplayed` function:\n     * chart.filterDisplayed(function () {\n     *     return true;\n     * });\n     **/\n    _chart.filterDisplayed = function (filterDisplayed) {\n        if (!arguments.length) {\n            return _filterDisplayed;\n        }\n        _filterDisplayed = filterDisplayed;\n        return _chart;\n    };\n\n    /**\n     * Controls the type of select menu. Setting it to true converts the underlying\n     * HTML tag into a multiple select.\n     * @name multiple\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {boolean} [multiple=false]\n     * @example\n     * chart.multiple(true);\n     **/\n    _chart.multiple = function (multiple) {\n        if (!arguments.length) {\n            return _multiple;\n        }\n        _multiple = multiple;\n\n        return _chart;\n    };\n\n    /**\n     * Controls the default value to be used for\n     * [dimension.filter](https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension_filter)\n     * when only the prompt value is selected. If `null` (the default), no filtering will occur when\n     * just the prompt is selected.\n     * @name promptValue\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {?*} [promptValue=null]\n     **/\n    _chart.promptValue = function (promptValue) {\n        if (!arguments.length) {\n            return _promptValue;\n        }\n        _promptValue = promptValue;\n\n        return _chart;\n    };\n\n    /**\n     * Controls the number of items to show in the select menu, when `.multiple()` is true. This\n     * controls the [`size` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#Attributes) of\n     * the `select` element. If `null` (the default), uses the browser's default height.\n     * @name numberItems\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {?number} [numberVisible=null]\n     * @example\n     * chart.numberVisible(10);\n     **/\n    _chart.numberVisible = function (numberVisible) {\n        if (!arguments.length) {\n            return _numberVisible;\n        }\n        _numberVisible = numberVisible;\n\n        return _chart;\n    };\n\n    _chart.size = dc.logger.deprecate(_chart.numberVisible, 'selectMenu.size is ambiguous - use numberVisible instead');\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n// Renamed functions\n\ndc.abstractBubbleChart = dc.bubbleMixin;\ndc.baseChart = dc.baseMixin;\ndc.capped = dc.capMixin;\ndc.colorChart = dc.colorMixin;\ndc.coordinateGridChart = dc.coordinateGridMixin;\ndc.marginable = dc.marginMixin;\ndc.stackableChart = dc.stackMixin;\n\n// Expose d3 and crossfilter, so that clients in browserify\n// case can obtain them if they need them.\ndc.d3 = d3;\ndc.crossfilter = crossfilter;\n\nreturn dc;}\n    if(true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(271), __webpack_require__(272)], __WEBPACK_AMD_DEFINE_FACTORY__ = (_dc),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if(typeof module === \"object\" && module.exports) {\n        var _d3 = require('d3');\n        var _crossfilter = require('crossfilter2');\n        // When using npm + browserify, 'crossfilter' is a function,\n        // since package.json specifies index.js as main function, and it\n        // does special handling. When using bower + browserify,\n        // there's no main in bower.json (in fact, there's no bower.json),\n        // so we need to fix it.\n        if (typeof _crossfilter !== \"function\") {\n            _crossfilter = _crossfilter.crossfilter;\n        }\n        module.exports = _dc(_d3, _crossfilter);\n    } else {\n        this.dc = _dc(d3, crossfilter);\n    }\n}\n)();\n\n//# sourceMappingURL=dc.js.map\n\n/***/ }),\n\n/***/ 271:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {\n  var d3 = {\n    version: \"3.5.17\"\n  };\n  var d3_arraySlice = [].slice, d3_array = function(list) {\n    return d3_arraySlice.call(list);\n  };\n  var d3_document = this.document;\n  function d3_documentElement(node) {\n    return node && (node.ownerDocument || node.document || node).documentElement;\n  }\n  function d3_window(node) {\n    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\n  }\n  if (d3_document) {\n    try {\n      d3_array(d3_document.documentElement.childNodes)[0].nodeType;\n    } catch (e) {\n      d3_array = function(list) {\n        var i = list.length, array = new Array(i);\n        while (i--) array[i] = list[i];\n        return array;\n      };\n    }\n  }\n  if (!Date.now) Date.now = function() {\n    return +new Date();\n  };\n  if (d3_document) {\n    try {\n      d3_document.createElement(\"DIV\").style.setProperty(\"opacity\", 0, \"\");\n    } catch (error) {\n      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\n      d3_element_prototype.setAttribute = function(name, value) {\n        d3_element_setAttribute.call(this, name, value + \"\");\n      };\n      d3_element_prototype.setAttributeNS = function(space, local, value) {\n        d3_element_setAttributeNS.call(this, space, local, value + \"\");\n      };\n      d3_style_prototype.setProperty = function(name, value, priority) {\n        d3_style_setProperty.call(this, name, value + \"\", priority);\n      };\n    }\n  }\n  d3.ascending = d3_ascending;\n  function d3_ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n  d3.descending = function(a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  };\n  d3.min = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n    }\n    return a;\n  };\n  d3.max = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n    }\n    return a;\n  };\n  d3.extent = function(array, f) {\n    var i = -1, n = array.length, a, b, c;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    }\n    return [ a, c ];\n  };\n  function d3_number(x) {\n    return x === null ? NaN : +x;\n  }\n  function d3_numeric(x) {\n    return !isNaN(x);\n  }\n  d3.sum = function(array, f) {\n    var s = 0, n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = +array[i])) s += a;\n    } else {\n      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\n    }\n    return s;\n  };\n  d3.mean = function(array, f) {\n    var s = 0, n = array.length, a, i = -1, j = n;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;\n    }\n    if (j) return s / j;\n  };\n  d3.quantile = function(values, p) {\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\n    return e ? v + e * (values[h] - v) : v;\n  };\n  d3.median = function(array, f) {\n    var numbers = [], n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\n    }\n    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\n  };\n  d3.variance = function(array, f) {\n    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\n    if (arguments.length === 1) {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(array[i]))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    } else {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    }\n    if (j > 1) return s / (j - 1);\n  };\n  d3.deviation = function() {\n    var v = d3.variance.apply(this, arguments);\n    return v ? Math.sqrt(v) : v;\n  };\n  function d3_bisector(compare) {\n    return {\n      left: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;\n        }\n        return lo;\n      },\n      right: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  var d3_bisect = d3_bisector(d3_ascending);\n  d3.bisectLeft = d3_bisect.left;\n  d3.bisect = d3.bisectRight = d3_bisect.right;\n  d3.bisector = function(f) {\n    return d3_bisector(f.length === 1 ? function(d, x) {\n      return d3_ascending(f(d), x);\n    } : f);\n  };\n  d3.shuffle = function(array, i0, i1) {\n    if ((m = arguments.length) < 3) {\n      i1 = array.length;\n      if (m < 2) i0 = 0;\n    }\n    var m = i1 - i0, t, i;\n    while (m) {\n      i = Math.random() * m-- | 0;\n      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\n    }\n    return array;\n  };\n  d3.permute = function(array, indexes) {\n    var i = indexes.length, permutes = new Array(i);\n    while (i--) permutes[i] = array[indexes[i]];\n    return permutes;\n  };\n  d3.pairs = function(array) {\n    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);\n    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];\n    return pairs;\n  };\n  d3.transpose = function(matrix) {\n    if (!(n = matrix.length)) return [];\n    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {\n      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {\n        row[j] = matrix[j][i];\n      }\n    }\n    return transpose;\n  };\n  function d3_transposeLength(d) {\n    return d.length;\n  }\n  d3.zip = function() {\n    return d3.transpose(arguments);\n  };\n  d3.keys = function(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  };\n  d3.values = function(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  };\n  d3.entries = function(map) {\n    var entries = [];\n    for (var key in map) entries.push({\n      key: key,\n      value: map[key]\n    });\n    return entries;\n  };\n  d3.merge = function(arrays) {\n    var n = arrays.length, m, i = -1, j = 0, merged, array;\n    while (++i < n) j += arrays[i].length;\n    merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  };\n  var abs = Math.abs;\n  d3.range = function(start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n    return range;\n  };\n  function d3_range_integerScale(x) {\n    var k = 1;\n    while (x * k % 1) k *= 10;\n    return k;\n  }\n  function d3_class(ctor, properties) {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  }\n  d3.map = function(object, f) {\n    var map = new d3_Map();\n    if (object instanceof d3_Map) {\n      object.forEach(function(key, value) {\n        map.set(key, value);\n      });\n    } else if (Array.isArray(object)) {\n      var i = -1, n = object.length, o;\n      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n    } else {\n      for (var key in object) map.set(key, object[key]);\n    }\n    return map;\n  };\n  function d3_Map() {\n    this._ = Object.create(null);\n  }\n  var d3_map_proto = \"__proto__\", d3_map_zero = \"\\x00\";\n  d3_class(d3_Map, {\n    has: d3_map_has,\n    get: function(key) {\n      return this._[d3_map_escape(key)];\n    },\n    set: function(key, value) {\n      return this._[d3_map_escape(key)] = value;\n    },\n    remove: d3_map_remove,\n    keys: d3_map_keys,\n    values: function() {\n      var values = [];\n      for (var key in this._) values.push(this._[key]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var key in this._) entries.push({\n        key: d3_map_unescape(key),\n        value: this._[key]\n      });\n      return entries;\n    },\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n    }\n  });\n  function d3_map_escape(key) {\n    return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n  }\n  function d3_map_unescape(key) {\n    return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n  }\n  function d3_map_has(key) {\n    return d3_map_escape(key) in this._;\n  }\n  function d3_map_remove(key) {\n    return (key = d3_map_escape(key)) in this._ && delete this._[key];\n  }\n  function d3_map_keys() {\n    var keys = [];\n    for (var key in this._) keys.push(d3_map_unescape(key));\n    return keys;\n  }\n  function d3_map_size() {\n    var size = 0;\n    for (var key in this._) ++size;\n    return size;\n  }\n  function d3_map_empty() {\n    for (var key in this._) return false;\n    return true;\n  }\n  d3.nest = function() {\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\n    function map(mapType, array, depth) {\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n          values.push(object);\n        } else {\n          valuesByKey.set(keyValue, [ object ]);\n        }\n      }\n      if (mapType) {\n        object = mapType();\n        setter = function(keyValue, values) {\n          object.set(keyValue, map(mapType, values, depth));\n        };\n      } else {\n        object = {};\n        setter = function(keyValue, values) {\n          object[keyValue] = map(mapType, values, depth);\n        };\n      }\n      valuesByKey.forEach(setter);\n      return object;\n    }\n    function entries(map, depth) {\n      if (depth >= keys.length) return map;\n      var array = [], sortKey = sortKeys[depth++];\n      map.forEach(function(key, keyMap) {\n        array.push({\n          key: key,\n          values: entries(keyMap, depth)\n        });\n      });\n      return sortKey ? array.sort(function(a, b) {\n        return sortKey(a.key, b.key);\n      }) : array;\n    }\n    nest.map = function(array, mapType) {\n      return map(mapType, array, 0);\n    };\n    nest.entries = function(array) {\n      return entries(map(d3.map, array, 0), 0);\n    };\n    nest.key = function(d) {\n      keys.push(d);\n      return nest;\n    };\n    nest.sortKeys = function(order) {\n      sortKeys[keys.length - 1] = order;\n      return nest;\n    };\n    nest.sortValues = function(order) {\n      sortValues = order;\n      return nest;\n    };\n    nest.rollup = function(f) {\n      rollup = f;\n      return nest;\n    };\n    return nest;\n  };\n  d3.set = function(array) {\n    var set = new d3_Set();\n    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\n    return set;\n  };\n  function d3_Set() {\n    this._ = Object.create(null);\n  }\n  d3_class(d3_Set, {\n    has: d3_map_has,\n    add: function(key) {\n      this._[d3_map_escape(key += \"\")] = true;\n      return key;\n    },\n    remove: d3_map_remove,\n    values: d3_map_keys,\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key));\n    }\n  });\n  d3.behavior = {};\n  function d3_identity(d) {\n    return d;\n  }\n  d3.rebind = function(target, source) {\n    var i = 1, n = arguments.length, method;\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n    return target;\n  };\n  function d3_rebind(target, source, method) {\n    return function() {\n      var value = method.apply(source, arguments);\n      return value === source ? target : value;\n    };\n  }\n  function d3_vendorSymbol(object, name) {\n    if (name in object) return name;\n    name = name.charAt(0).toUpperCase() + name.slice(1);\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n      var prefixName = d3_vendorPrefixes[i] + name;\n      if (prefixName in object) return prefixName;\n    }\n  }\n  var d3_vendorPrefixes = [ \"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\" ];\n  function d3_noop() {}\n  d3.dispatch = function() {\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    return dispatch;\n  };\n  function d3_dispatch() {}\n  d3_dispatch.prototype.on = function(type, listener) {\n    var i = type.indexOf(\".\"), name = \"\";\n    if (i >= 0) {\n      name = type.slice(i + 1);\n      type = type.slice(0, i);\n    }\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n    if (arguments.length === 2) {\n      if (listener == null) for (type in this) {\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\n      }\n      return this;\n    }\n  };\n  function d3_dispatch_event(dispatch) {\n    var listeners = [], listenerByName = new d3_Map();\n    function event() {\n      var z = listeners, i = -1, n = z.length, l;\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n      return dispatch;\n    }\n    event.on = function(name, listener) {\n      var l = listenerByName.get(name), i;\n      if (arguments.length < 2) return l && l.on;\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      }\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n    return event;\n  }\n  d3.event = null;\n  function d3_eventPreventDefault() {\n    d3.event.preventDefault();\n  }\n  function d3_eventSource() {\n    var e = d3.event, s;\n    while (s = e.sourceEvent) e = s;\n    return e;\n  }\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    dispatch.of = function(thiz, argumentz) {\n      return function(e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n    return dispatch;\n  }\n  d3.requote = function(s) {\n    return s.replace(d3_requote_re, \"\\\\$&\");\n  };\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  var d3_subclass = {}.__proto__ ? function(object, prototype) {\n    object.__proto__ = prototype;\n  } : function(object, prototype) {\n    for (var property in prototype) object[property] = prototype[property];\n  };\n  function d3_selection(groups) {\n    d3_subclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n  var d3_select = function(s, n) {\n    return n.querySelector(s);\n  }, d3_selectAll = function(s, n) {\n    return n.querySelectorAll(s);\n  }, d3_selectMatches = function(n, s) {\n    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n    d3_selectMatches = function(n, s) {\n      return d3_selectMatcher.call(n, s);\n    };\n    return d3_selectMatches(n, s);\n  };\n  if (typeof Sizzle === \"function\") {\n    d3_select = function(s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n    d3_selectAll = Sizzle;\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n  d3.selection = function() {\n    return d3.select(d3_document.documentElement);\n  };\n  var d3_selectionPrototype = d3.selection.prototype = [];\n  d3_selectionPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, group, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selector(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_select(selector, this);\n    };\n  }\n  d3_selectionPrototype.selectAll = function(selector) {\n    var subgroups = [], subgroup, node;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selectorAll(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_selectAll(selector, this);\n    };\n  }\n  var d3_nsXhtml = \"http://www.w3.org/1999/xhtml\";\n  var d3_nsPrefix = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: d3_nsXhtml,\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function(name) {\n      var i = name.indexOf(\":\"), prefix = name;\n      if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n  d3_selectionPrototype.attr = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      }\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_attr(name, value));\n  };\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\n    }\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\n    }\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, \" \");\n  }\n  d3_selectionPrototype.classed = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;\n        if (value = node.classList) {\n          while (++i < n) if (!value.contains(name[i])) return false;\n        } else {\n          value = node.getAttribute(\"class\");\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n        }\n        return true;\n      }\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_classed(name, value));\n  };\n  function d3_selection_classedRe(name) {\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n  }\n  function d3_selection_classes(name) {\n    return (name + \"\").trim().split(/^|\\s+/);\n  }\n  function d3_selection_classed(name, value) {\n    name = d3_selection_classes(name).map(d3_selection_classedName);\n    var n = name.length;\n    function classedConstant() {\n      var i = -1;\n      while (++i < n) name[i](this, value);\n    }\n    function classedFunction() {\n      var i = -1, x = value.apply(this, arguments);\n      while (++i < n) name[i](this, x);\n    }\n    return typeof value === \"function\" ? classedFunction : classedConstant;\n  }\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function(node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.getAttribute(\"class\") || \"\";\n      if (value) {\n        re.lastIndex = 0;\n        if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n      } else {\n        node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n      }\n    };\n  }\n  d3_selectionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n        return this;\n      }\n      if (n < 2) {\n        var node = this.node();\n        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n      }\n      priority = \"\";\n    }\n    return this.each(d3_selection_style(name, value, priority));\n  };\n  function d3_selection_style(name, value, priority) {\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\n    }\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n  }\n  d3_selectionPrototype.property = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") return this.node()[name];\n      for (value in name) this.each(d3_selection_property(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_property(name, value));\n  };\n  function d3_selection_property(name, value) {\n    function propertyNull() {\n      delete this[name];\n    }\n    function propertyConstant() {\n      this[name] = value;\n    }\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name]; else this[name] = x;\n    }\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n  }\n  d3_selectionPrototype.text = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.textContent = \"\";\n    } : function() {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n  d3_selectionPrototype.html = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.innerHTML = \"\";\n    } : function() {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n  d3_selectionPrototype.append = function(name) {\n    name = d3_selection_creator(name);\n    return this.select(function() {\n      return this.appendChild(name.apply(this, arguments));\n    });\n  };\n  function d3_selection_creator(name) {\n    function create() {\n      var document = this.ownerDocument, namespace = this.namespaceURI;\n      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);\n    }\n    function createNS() {\n      return this.ownerDocument.createElementNS(name.space, name.local);\n    }\n    return typeof name === \"function\" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\n  }\n  d3_selectionPrototype.insert = function(name, before) {\n    name = d3_selection_creator(name);\n    before = d3_selection_selector(before);\n    return this.select(function() {\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n    });\n  };\n  d3_selectionPrototype.remove = function() {\n    return this.each(d3_selectionRemove);\n  };\n  function d3_selectionRemove() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  }\n  d3_selectionPrototype.data = function(value, key) {\n    var i = -1, n = this.length, group, node;\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n      return value;\n    }\n    function bind(group, groupData) {\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\n      if (key) {\n        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;\n        for (i = -1; ++i < n; ) {\n          if (node = group[i]) {\n            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\n              exitNodes[i] = node;\n            } else {\n              nodeByKeyValue.set(keyValue, node);\n            }\n            keyValues[i] = keyValue;\n          }\n        }\n        for (i = -1; ++i < m; ) {\n          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          } else if (node !== true) {\n            updateNodes[i] = node;\n            node.__data__ = nodeData;\n          }\n          nodeByKeyValue.set(keyValue, true);\n        }\n        for (i = -1; ++i < n; ) {\n          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0; ) {\n          node = group[i];\n          nodeData = groupData[i];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n        }\n        for (;i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        }\n        for (;i < n; ++i) {\n          exitNodes[i] = group[i];\n        }\n      }\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\n    if (typeof value === \"function\") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n    update.enter = function() {\n      return enter;\n    };\n    update.exit = function() {\n      return exit;\n    };\n    return update;\n  };\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n  d3_selectionPrototype.datum = function(value) {\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n  };\n  d3_selectionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_filter(selector) {\n    return function() {\n      return d3_selectMatches(this, selector);\n    };\n  }\n  d3_selectionPrototype.order = function() {\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n    return this;\n  };\n  d3_selectionPrototype.sort = function(comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\n    return this.order();\n  };\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3_ascending;\n    return function(a, b) {\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n    };\n  }\n  d3_selectionPrototype.each = function(callback) {\n    return d3_selection_each(this, function(node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n    return groups;\n  }\n  d3_selectionPrototype.call = function(callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n  d3_selectionPrototype.empty = function() {\n    return !this.node();\n  };\n  d3_selectionPrototype.node = function() {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n    return null;\n  };\n  d3_selectionPrototype.size = function() {\n    var n = 0;\n    d3_selection_each(this, function() {\n      ++n;\n    });\n    return n;\n  };\n  function d3_selection_enter(selection) {\n    d3_subclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n  d3_selection_enterPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\n    for (var j = -1, m = this.length; ++j < m; ) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  d3_selection_enterPrototype.insert = function(name, before) {\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n    return d3_selectionPrototype.insert.call(this, name, before);\n  };\n  function d3_selection_enterInsertBefore(enter) {\n    var i0, j0;\n    return function(d, i, j) {\n      var group = enter[j].update, n = group.length, node;\n      if (j != j0) j0 = j, i0 = 0;\n      if (i >= i0) i0 = i + 1;\n      while (!(node = group[i0]) && ++i0 < n) ;\n      return node;\n    };\n  }\n  d3.select = function(node) {\n    var group;\n    if (typeof node === \"string\") {\n      group = [ d3_select(node, d3_document) ];\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = [ node ];\n      group.parentNode = d3_documentElement(node);\n    }\n    return d3_selection([ group ]);\n  };\n  d3.selectAll = function(nodes) {\n    var group;\n    if (typeof nodes === \"string\") {\n      group = d3_array(d3_selectAll(nodes, d3_document));\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = d3_array(nodes);\n      group.parentNode = null;\n    }\n    return d3_selection([ group ]);\n  };\n  d3_selectionPrototype.on = function(type, listener, capture) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof type !== \"string\") {\n        if (n < 2) listener = false;\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n        return this;\n      }\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n      capture = false;\n    }\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n  function d3_selection_on(type, listener, capture) {\n    var name = \"__on\" + type, i = type.indexOf(\".\"), wrap = d3_selection_onListener;\n    if (i > 0) type = type.slice(0, i);\n    var filter = d3_selection_onFilters.get(type);\n    if (filter) type = filter, wrap = d3_selection_onFilter;\n    function onRemove() {\n      var l = this[name];\n      if (l) {\n        this.removeEventListener(type, l, l.$);\n        delete this[name];\n      }\n    }\n    function onAdd() {\n      var l = wrap(listener, d3_array(arguments));\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = l, l.$ = capture);\n      l._ = listener;\n    }\n    function removeAll() {\n      var re = new RegExp(\"^__on([^.]+)\" + d3.requote(type) + \"$\"), match;\n      for (var name in this) {\n        if (match = name.match(re)) {\n          var l = this[name];\n          this.removeEventListener(match[1], l, l.$);\n          delete this[name];\n        }\n      }\n    }\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n  }\n  var d3_selection_onFilters = d3.map({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  });\n  if (d3_document) {\n    d3_selection_onFilters.forEach(function(k) {\n      if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n    });\n  }\n  function d3_selection_onListener(listener, argumentz) {\n    return function(e) {\n      var o = d3.event;\n      d3.event = e;\n      argumentz[0] = this.__data__;\n      try {\n        listener.apply(this, argumentz);\n      } finally {\n        d3.event = o;\n      }\n    };\n  }\n  function d3_selection_onFilter(listener, argumentz) {\n    var l = d3_selection_onListener(listener, argumentz);\n    return function(e) {\n      var target = this, related = e.relatedTarget;\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n        l.call(target, e);\n      }\n    };\n  }\n  var d3_event_dragSelect, d3_event_dragId = 0;\n  function d3_event_dragSuppress(node) {\n    var name = \".dragsuppress-\" + ++d3_event_dragId, click = \"click\" + name, w = d3.select(d3_window(node)).on(\"touchmove\" + name, d3_eventPreventDefault).on(\"dragstart\" + name, d3_eventPreventDefault).on(\"selectstart\" + name, d3_eventPreventDefault);\n    if (d3_event_dragSelect == null) {\n      d3_event_dragSelect = \"onselectstart\" in node ? false : d3_vendorSymbol(node.style, \"userSelect\");\n    }\n    if (d3_event_dragSelect) {\n      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];\n      style[d3_event_dragSelect] = \"none\";\n    }\n    return function(suppressClick) {\n      w.on(name, null);\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n      if (suppressClick) {\n        var off = function() {\n          w.on(click, null);\n        };\n        w.on(click, function() {\n          d3_eventPreventDefault();\n          off();\n        }, true);\n        setTimeout(off, 0);\n      }\n    };\n  }\n  d3.mouse = function(container) {\n    return d3_mousePoint(container, d3_eventSource());\n  };\n  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n  function d3_mousePoint(container, e) {\n    if (e.changedTouches) e = e.changedTouches[0];\n    var svg = container.ownerSVGElement || container;\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n      if (d3_mouse_bug44083 < 0) {\n        var window = d3_window(container);\n        if (window.scrollX || window.scrollY) {\n          svg = d3.select(\"body\").append(\"svg\").style({\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            margin: 0,\n            padding: 0,\n            border: \"none\"\n          }, \"important\");\n          var ctm = svg[0][0].getScreenCTM();\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\n          svg.remove();\n        }\n      }\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, \n      point.y = e.clientY;\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [ point.x, point.y ];\n    }\n    var rect = container.getBoundingClientRect();\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\n  }\n  d3.touch = function(container, touches, identifier) {\n    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\n    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\n      if ((touch = touches[i]).identifier === identifier) {\n        return d3_mousePoint(container, touch);\n      }\n    }\n  };\n  d3.behavior.drag = function() {\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, \"mousemove\", \"mouseup\"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, \"touchmove\", \"touchend\");\n    function drag() {\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", touchstart);\n    }\n    function dragstart(id, position, subject, move, end) {\n      return function() {\n        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = \".drag\" + (dragId == null ? \"\" : \"-\" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);\n        if (origin) {\n          dragOffset = origin.apply(that, arguments);\n          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\n        } else {\n          dragOffset = [ 0, 0 ];\n        }\n        dispatch({\n          type: \"dragstart\"\n        });\n        function moved() {\n          var position1 = position(parent, dragId), dx, dy;\n          if (!position1) return;\n          dx = position1[0] - position0[0];\n          dy = position1[1] - position0[1];\n          dragged |= dx | dy;\n          position0 = position1;\n          dispatch({\n            type: \"drag\",\n            x: position1[0] + dragOffset[0],\n            y: position1[1] + dragOffset[1],\n            dx: dx,\n            dy: dy\n          });\n        }\n        function ended() {\n          if (!position(parent, dragId)) return;\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\n          dragRestore(dragged);\n          dispatch({\n            type: \"dragend\"\n          });\n        }\n      };\n    }\n    drag.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n    return d3.rebind(drag, event, \"on\");\n  };\n  function d3_behavior_dragTouchId() {\n    return d3.event.changedTouches[0].identifier;\n  }\n  d3.touches = function(container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function(touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;\n  function d3_sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n  function d3_cross2d(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n  }\n  function d3_acos(x) {\n    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n  }\n  function d3_asin(x) {\n    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n  }\n  function d3_sinh(x) {\n    return ((x = Math.exp(x)) - 1 / x) / 2;\n  }\n  function d3_cosh(x) {\n    return ((x = Math.exp(x)) + 1 / x) / 2;\n  }\n  function d3_tanh(x) {\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n  }\n  function d3_haversin(x) {\n    return (x = Math.sin(x / 2)) * x;\n  }\n  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;\n  d3.interpolateZoom = function(p0, p1) {\n    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < ε2) {\n      S = Math.log(w1 / w0) / ρ;\n      i = function(t) {\n        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n      S = (r1 - r0) / ρ;\n      i = function(t) {\n        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));\n        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];\n      };\n    }\n    i.duration = S * 1e3;\n    return i;\n  };\n  d3.behavior.zoom = function() {\n    var view = {\n      x: 0,\n      y: 0,\n      k: 1\n    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = \"mousedown.zoom\", mousemove = \"mousemove.zoom\", mouseup = \"mouseup.zoom\", mousewheelTimer, touchstart = \"touchstart.zoom\", touchtime, event = d3_eventDispatch(zoom, \"zoomstart\", \"zoom\", \"zoomend\"), x0, x1, y0, y1;\n    if (!d3_behavior_zoomWheel) {\n      d3_behavior_zoomWheel = \"onwheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\n      }, \"wheel\") : \"onmousewheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return d3.event.wheelDelta;\n      }, \"mousewheel\") : (d3_behavior_zoomDelta = function() {\n        return -d3.event.detail;\n      }, \"MozMousePixelScroll\");\n    }\n    function zoom(g) {\n      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + \".zoom\", mousewheeled).on(\"dblclick.zoom\", dblclicked).on(touchstart, touchstarted);\n    }\n    zoom.event = function(g) {\n      g.each(function() {\n        var dispatch = event.of(this, arguments), view1 = view;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.zoom\", function() {\n            view = this.__chart__ || {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            zoomstarted(dispatch);\n          }).tween(\"zoom:zoom\", function() {\n            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);\n            return function(t) {\n              var l = i(t), k = dx / l[2];\n              this.__chart__ = view = {\n                x: cx - l[0] * k,\n                y: cy - l[1] * k,\n                k: k\n              };\n              zoomed(dispatch);\n            };\n          }).each(\"interrupt.zoom\", function() {\n            zoomended(dispatch);\n          }).each(\"end.zoom\", function() {\n            zoomended(dispatch);\n          });\n        } else {\n          this.__chart__ = view;\n          zoomstarted(dispatch);\n          zoomed(dispatch);\n          zoomended(dispatch);\n        }\n      });\n    };\n    zoom.translate = function(_) {\n      if (!arguments.length) return [ view.x, view.y ];\n      view = {\n        x: +_[0],\n        y: +_[1],\n        k: view.k\n      };\n      rescale();\n      return zoom;\n    };\n    zoom.scale = function(_) {\n      if (!arguments.length) return view.k;\n      view = {\n        x: view.x,\n        y: view.y,\n        k: null\n      };\n      scaleTo(+_);\n      rescale();\n      return zoom;\n    };\n    zoom.scaleExtent = function(_) {\n      if (!arguments.length) return scaleExtent;\n      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.center = function(_) {\n      if (!arguments.length) return center;\n      center = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.size = function(_) {\n      if (!arguments.length) return size;\n      size = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.duration = function(_) {\n      if (!arguments.length) return duration;\n      duration = +_;\n      return zoom;\n    };\n    zoom.x = function(z) {\n      if (!arguments.length) return x1;\n      x1 = z;\n      x0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    zoom.y = function(z) {\n      if (!arguments.length) return y1;\n      y1 = z;\n      y0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    function location(p) {\n      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];\n    }\n    function point(l) {\n      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\n    }\n    function scaleTo(s) {\n      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n    }\n    function translateTo(p, l) {\n      l = point(l);\n      view.x += p[0] - l[0];\n      view.y += p[1] - l[1];\n    }\n    function zoomTo(that, p, l, k) {\n      that.__chart__ = {\n        x: view.x,\n        y: view.y,\n        k: view.k\n      };\n      scaleTo(Math.pow(2, k));\n      translateTo(center0 = p, l);\n      that = d3.select(that);\n      if (duration > 0) that = that.transition().duration(duration);\n      that.call(zoom.event);\n    }\n    function rescale() {\n      if (x1) x1.domain(x0.range().map(function(x) {\n        return (x - view.x) / view.k;\n      }).map(x0.invert));\n      if (y1) y1.domain(y0.range().map(function(y) {\n        return (y - view.y) / view.k;\n      }).map(y0.invert));\n    }\n    function zoomstarted(dispatch) {\n      if (!zooming++) dispatch({\n        type: \"zoomstart\"\n      });\n    }\n    function zoomed(dispatch) {\n      rescale();\n      dispatch({\n        type: \"zoom\",\n        scale: view.k,\n        translate: [ view.x, view.y ]\n      });\n    }\n    function zoomended(dispatch) {\n      if (!--zooming) dispatch({\n        type: \"zoomend\"\n      }), center0 = null;\n    }\n    function mousedowned() {\n      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);\n      d3_selection_interrupt.call(that);\n      zoomstarted(dispatch);\n      function moved() {\n        dragged = 1;\n        translateTo(d3.mouse(that), location0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        subject.on(mousemove, null).on(mouseup, null);\n        dragRestore(dragged);\n        zoomended(dispatch);\n      }\n    }\n    function touchstarted() {\n      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = \".zoom-\" + d3.event.changedTouches[0].identifier, touchmove = \"touchmove\" + zoomName, touchend = \"touchend\" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);\n      started();\n      zoomstarted(dispatch);\n      subject.on(mousedown, null).on(touchstart, started);\n      function relocate() {\n        var touches = d3.touches(that);\n        scale0 = view.k;\n        touches.forEach(function(t) {\n          if (t.identifier in locations0) locations0[t.identifier] = location(t);\n        });\n        return touches;\n      }\n      function started() {\n        var target = d3.event.target;\n        d3.select(target).on(touchmove, moved).on(touchend, ended);\n        targets.push(target);\n        var changed = d3.event.changedTouches;\n        for (var i = 0, n = changed.length; i < n; ++i) {\n          locations0[changed[i].identifier] = null;\n        }\n        var touches = relocate(), now = Date.now();\n        if (touches.length === 1) {\n          if (now - touchtime < 500) {\n            var p = touches[0];\n            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\n            d3_eventPreventDefault();\n          }\n          touchtime = now;\n        } else if (touches.length > 1) {\n          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\n          distance0 = dx * dx + dy * dy;\n        }\n      }\n      function moved() {\n        var touches = d3.touches(that), p0, l0, p1, l1;\n        d3_selection_interrupt.call(that);\n        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\n          p1 = touches[i];\n          if (l1 = locations0[p1.identifier]) {\n            if (l0) break;\n            p0 = p1, l0 = l1;\n          }\n        }\n        if (l1) {\n          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);\n          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\n          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\n          scaleTo(scale1 * scale0);\n        }\n        touchtime = null;\n        translateTo(p0, l0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        if (d3.event.touches.length) {\n          var changed = d3.event.changedTouches;\n          for (var i = 0, n = changed.length; i < n; ++i) {\n            delete locations0[changed[i].identifier];\n          }\n          for (var identifier in locations0) {\n            return void relocate();\n          }\n        }\n        d3.selectAll(targets).on(zoomName, null);\n        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\n        dragRestore();\n        zoomended(dispatch);\n      }\n    }\n    function mousewheeled() {\n      var dispatch = event.of(this, arguments);\n      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), \n      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\n      mousewheelTimer = setTimeout(function() {\n        mousewheelTimer = null;\n        zoomended(dispatch);\n      }, 50);\n      d3_eventPreventDefault();\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\n      translateTo(center0, translate0);\n      zoomed(dispatch);\n    }\n    function dblclicked() {\n      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;\n      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\n    }\n    return d3.rebind(zoom, event, \"on\");\n  };\n  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\n  d3.color = d3_color;\n  function d3_color() {}\n  d3_color.prototype.toString = function() {\n    return this.rgb() + \"\";\n  };\n  d3.hsl = d3_hsl;\n  function d3_hsl(h, s, l) {\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n  }\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n  d3_hslPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, this.l / k);\n  };\n  d3_hslPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, k * this.l);\n  };\n  d3_hslPrototype.rgb = function() {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n    function v(h) {\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n  d3.hcl = d3_hcl;\n  function d3_hcl(h, c, l) {\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n  }\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n  d3_hclPrototype.brighter = function(k) {\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.darker = function(k) {\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.rgb = function() {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n  function d3_hcl_lab(h, c, l) {\n    if (isNaN(h)) h = 0;\n    if (isNaN(c)) c = 0;\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n  d3.lab = d3_lab;\n  function d3_lab(l, a, b) {\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n  }\n  var d3_lab_K = 18;\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\n  d3_labPrototype.brighter = function(k) {\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.darker = function(k) {\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.rgb = function() {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n  }\n  function d3_lab_hcl(l, a, b) {\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n  }\n  function d3_lab_xyz(x) {\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n  function d3_xyz_lab(x) {\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n  }\n  d3.rgb = d3_rgb;\n  function d3_rgb(r, g, b) {\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n  }\n  function d3_rgbNumber(value) {\n    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n  }\n  function d3_rgbString(value) {\n    return d3_rgbNumber(value) + \"\";\n  }\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n  d3_rgbPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    var r = this.r, g = this.g, b = this.b, i = 30;\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n  };\n  d3_rgbPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\n  };\n  d3_rgbPrototype.hsl = function() {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n  d3_rgbPrototype.toString = function() {\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n  function d3_rgb_hex(v) {\n    return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0, g = 0, b = 0, m1, m2, color;\n    m1 = /([a-z]+)\\((.*)\\)/.exec(format = format.toLowerCase());\n    if (m1) {\n      m2 = m1[2].split(\",\");\n      switch (m1[1]) {\n       case \"hsl\":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n       case \"rgb\":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n        }\n      }\n    }\n    if (color = d3_rgb_names.get(format)) {\n      return rgb(color.r, color.g, color.b);\n    }\n    if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n      if (format.length === 4) {\n        r = (color & 3840) >> 4;\n        r = r >> 4 | r;\n        g = color & 240;\n        g = g >> 4 | g;\n        b = color & 15;\n        b = b << 4 | b;\n      } else if (format.length === 7) {\n        r = (color & 16711680) >> 16;\n        g = (color & 65280) >> 8;\n        b = color & 255;\n      }\n    }\n    return rgb(r, g, b);\n  }\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      h = NaN;\n      s = l > 0 && l < 1 ? 0 : h;\n    }\n    return new d3_hsl(h, s, l);\n  }\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n  }\n  function d3_rgb_parseNumber(c) {\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n  }\n  var d3_rgb_names = d3.map({\n    aliceblue: 15792383,\n    antiquewhite: 16444375,\n    aqua: 65535,\n    aquamarine: 8388564,\n    azure: 15794175,\n    beige: 16119260,\n    bisque: 16770244,\n    black: 0,\n    blanchedalmond: 16772045,\n    blue: 255,\n    blueviolet: 9055202,\n    brown: 10824234,\n    burlywood: 14596231,\n    cadetblue: 6266528,\n    chartreuse: 8388352,\n    chocolate: 13789470,\n    coral: 16744272,\n    cornflowerblue: 6591981,\n    cornsilk: 16775388,\n    crimson: 14423100,\n    cyan: 65535,\n    darkblue: 139,\n    darkcyan: 35723,\n    darkgoldenrod: 12092939,\n    darkgray: 11119017,\n    darkgreen: 25600,\n    darkgrey: 11119017,\n    darkkhaki: 12433259,\n    darkmagenta: 9109643,\n    darkolivegreen: 5597999,\n    darkorange: 16747520,\n    darkorchid: 10040012,\n    darkred: 9109504,\n    darksalmon: 15308410,\n    darkseagreen: 9419919,\n    darkslateblue: 4734347,\n    darkslategray: 3100495,\n    darkslategrey: 3100495,\n    darkturquoise: 52945,\n    darkviolet: 9699539,\n    deeppink: 16716947,\n    deepskyblue: 49151,\n    dimgray: 6908265,\n    dimgrey: 6908265,\n    dodgerblue: 2003199,\n    firebrick: 11674146,\n    floralwhite: 16775920,\n    forestgreen: 2263842,\n    fuchsia: 16711935,\n    gainsboro: 14474460,\n    ghostwhite: 16316671,\n    gold: 16766720,\n    goldenrod: 14329120,\n    gray: 8421504,\n    green: 32768,\n    greenyellow: 11403055,\n    grey: 8421504,\n    honeydew: 15794160,\n    hotpink: 16738740,\n    indianred: 13458524,\n    indigo: 4915330,\n    ivory: 16777200,\n    khaki: 15787660,\n    lavender: 15132410,\n    lavenderblush: 16773365,\n    lawngreen: 8190976,\n    lemonchiffon: 16775885,\n    lightblue: 11393254,\n    lightcoral: 15761536,\n    lightcyan: 14745599,\n    lightgoldenrodyellow: 16448210,\n    lightgray: 13882323,\n    lightgreen: 9498256,\n    lightgrey: 13882323,\n    lightpink: 16758465,\n    lightsalmon: 16752762,\n    lightseagreen: 2142890,\n    lightskyblue: 8900346,\n    lightslategray: 7833753,\n    lightslategrey: 7833753,\n    lightsteelblue: 11584734,\n    lightyellow: 16777184,\n    lime: 65280,\n    limegreen: 3329330,\n    linen: 16445670,\n    magenta: 16711935,\n    maroon: 8388608,\n    mediumaquamarine: 6737322,\n    mediumblue: 205,\n    mediumorchid: 12211667,\n    mediumpurple: 9662683,\n    mediumseagreen: 3978097,\n    mediumslateblue: 8087790,\n    mediumspringgreen: 64154,\n    mediumturquoise: 4772300,\n    mediumvioletred: 13047173,\n    midnightblue: 1644912,\n    mintcream: 16121850,\n    mistyrose: 16770273,\n    moccasin: 16770229,\n    navajowhite: 16768685,\n    navy: 128,\n    oldlace: 16643558,\n    olive: 8421376,\n    olivedrab: 7048739,\n    orange: 16753920,\n    orangered: 16729344,\n    orchid: 14315734,\n    palegoldenrod: 15657130,\n    palegreen: 10025880,\n    paleturquoise: 11529966,\n    palevioletred: 14381203,\n    papayawhip: 16773077,\n    peachpuff: 16767673,\n    peru: 13468991,\n    pink: 16761035,\n    plum: 14524637,\n    powderblue: 11591910,\n    purple: 8388736,\n    rebeccapurple: 6697881,\n    red: 16711680,\n    rosybrown: 12357519,\n    royalblue: 4286945,\n    saddlebrown: 9127187,\n    salmon: 16416882,\n    sandybrown: 16032864,\n    seagreen: 3050327,\n    seashell: 16774638,\n    sienna: 10506797,\n    silver: 12632256,\n    skyblue: 8900331,\n    slateblue: 6970061,\n    slategray: 7372944,\n    slategrey: 7372944,\n    snow: 16775930,\n    springgreen: 65407,\n    steelblue: 4620980,\n    tan: 13808780,\n    teal: 32896,\n    thistle: 14204888,\n    tomato: 16737095,\n    turquoise: 4251856,\n    violet: 15631086,\n    wheat: 16113331,\n    white: 16777215,\n    whitesmoke: 16119285,\n    yellow: 16776960,\n    yellowgreen: 10145074\n  });\n  d3_rgb_names.forEach(function(key, value) {\n    d3_rgb_names.set(key, d3_rgbNumber(value));\n  });\n  function d3_functor(v) {\n    return typeof v === \"function\" ? v : function() {\n      return v;\n    };\n  }\n  d3.functor = d3_functor;\n  d3.xhr = d3_xhrType(d3_identity);\n  function d3_xhrType(response) {\n    return function(url, mimeType, callback) {\n      if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, \n      mimeType = null;\n      return d3_xhr(url, mimeType, response, callback);\n    };\n  }\n  function d3_xhr(url, mimeType, response, callback) {\n    var xhr = {}, dispatch = d3.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"), headers = {}, request = new XMLHttpRequest(), responseType = null;\n    if (this.XDomainRequest && !(\"withCredentials\" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\n      request.readyState > 3 && respond();\n    };\n    function respond() {\n      var status = request.status, result;\n      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n        try {\n          result = response.call(xhr, request);\n        } catch (e) {\n          dispatch.error.call(xhr, e);\n          return;\n        }\n        dispatch.load.call(xhr, result);\n      } else {\n        dispatch.error.call(xhr, request);\n      }\n    }\n    request.onprogress = function(event) {\n      var o = d3.event;\n      d3.event = event;\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n    xhr.header = function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name]; else headers[name] = value + \"\";\n      return xhr;\n    };\n    xhr.mimeType = function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return xhr;\n    };\n    xhr.responseType = function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return xhr;\n    };\n    xhr.response = function(value) {\n      response = value;\n      return xhr;\n    };\n    [ \"get\", \"post\" ].forEach(function(method) {\n      xhr[method] = function() {\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\n      };\n    });\n    xhr.send = function(method, data, callback) {\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (responseType != null) request.responseType = responseType;\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function(request) {\n        callback(null, request);\n      });\n      dispatch.beforesend.call(xhr, request);\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n    xhr.abort = function() {\n      request.abort();\n      return xhr;\n    };\n    d3.rebind(xhr, dispatch, \"on\");\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  }\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function(error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n  function d3_xhrHasResponse(request) {\n    var type = request.responseType;\n    return type && type !== \"text\" ? request.response : request.responseText;\n  }\n  d3.dsv = function(delimiter, mimeType) {\n    var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"), delimiterCode = delimiter.charCodeAt(0);\n    function dsv(url, row, callback) {\n      if (arguments.length < 3) callback = row, row = null;\n      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\n      xhr.row = function(_) {\n        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\n      };\n      return xhr;\n    }\n    function response(request) {\n      return dsv.parse(request.responseText);\n    }\n    function typedResponse(f) {\n      return function(request) {\n        return dsv.parse(request.responseText, f);\n      };\n    }\n    dsv.parse = function(text, f) {\n      var o;\n      return dsv.parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function(\"d\", \"return {\" + row.map(function(name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n        o = f ? function(row, i) {\n          return f(a(row), i);\n        } : a;\n      });\n    };\n    dsv.parseRows = function(text, f) {\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\n      function token() {\n        if (I >= N) return EOF;\n        if (eol) return eol = false, EOL;\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, '\"');\n        }\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n        return text.slice(j);\n      }\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n      return rows;\n    };\n    dsv.format = function(rows) {\n      if (Array.isArray(rows[0])) return dsv.formatRows(rows);\n      var fieldSet = new d3_Set(), fields = [];\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!fieldSet.has(field)) {\n            fields.push(fieldSet.add(field));\n          }\n        }\n      });\n      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    };\n    dsv.formatRows = function(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n    function formatValue(text) {\n      return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\n    }\n    return dsv;\n  };\n  d3.csv = d3.dsv(\",\", \"text/csv\");\n  d3.tsv = d3.dsv(\"\t\", \"text/tab-separated-values\");\n  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, \"requestAnimationFrame\")] || function(callback) {\n    setTimeout(callback, 17);\n  };\n  d3.timer = function() {\n    d3_timer.apply(this, arguments);\n  };\n  function d3_timer(callback, delay, then) {\n    var n = arguments.length;\n    if (n < 2) delay = 0;\n    if (n < 3) then = Date.now();\n    var time = then + delay, timer = {\n      c: callback,\n      t: time,\n      n: null\n    };\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\n    d3_timer_queueTail = timer;\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n    return timer;\n  }\n  function d3_timer_step() {\n    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n  d3.timer.flush = function() {\n    d3_timer_mark();\n    d3_timer_sweep();\n  };\n  function d3_timer_mark() {\n    var now = Date.now(), timer = d3_timer_queueHead;\n    while (timer) {\n      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\n      timer = timer.n;\n    }\n    return now;\n  }\n  function d3_timer_sweep() {\n    var t0, t1 = d3_timer_queueHead, time = Infinity;\n    while (t1) {\n      if (t1.c) {\n        if (t1.t < time) time = t1.t;\n        t1 = (t0 = t1).n;\n      } else {\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n      }\n    }\n    d3_timer_queueTail = t0;\n    return time;\n  }\n  function d3_format_precision(x, p) {\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n  }\n  d3.round = function(x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n  var d3_formatPrefixes = [ \"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\" ].map(d3_formatPrefix);\n  d3.formatPrefix = function(value, precision) {\n    var i = 0;\n    if (value = +value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n    }\n    return d3_formatPrefixes[8 + i / 3];\n  };\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function(d) {\n        return d / k;\n      } : function(d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n  function d3_locale_numberFormat(locale) {\n    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {\n      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\n      }\n      return t.reverse().join(locale_thousands);\n    } : d3_identity;\n    return function(specifier) {\n      var match = d3_format_re.exec(specifier), fill = match[1] || \" \", align = match[2] || \">\", sign = match[3] || \"-\", symbol = match[4] || \"\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = \"\", suffix = \"\", integer = false, exponent = true;\n      if (precision) precision = +precision.substring(1);\n      if (zfill || fill === \"0\" && align === \"=\") {\n        zfill = fill = \"0\";\n        align = \"=\";\n      }\n      switch (type) {\n       case \"n\":\n        comma = true;\n        type = \"g\";\n        break;\n\n       case \"%\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"f\";\n        break;\n\n       case \"p\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"r\";\n        break;\n\n       case \"b\":\n       case \"o\":\n       case \"x\":\n       case \"X\":\n        if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n\n       case \"c\":\n        exponent = false;\n\n       case \"d\":\n        integer = true;\n        precision = 0;\n        break;\n\n       case \"s\":\n        scale = -1;\n        type = \"r\";\n        break;\n      }\n      if (symbol === \"$\") prefix = locale_currency[0], suffix = locale_currency[1];\n      if (type == \"r\" && !precision) type = \"g\";\n      if (precision != null) {\n        if (type == \"g\") precision = Math.max(1, Math.min(21, precision)); else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n      }\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      var zcomma = zfill && comma;\n      return function(value) {\n        var fullSuffix = suffix;\n        if (integer && value % 1) return \"\";\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign === \"-\" ? \"\" : sign;\n        if (scale < 0) {\n          var unit = d3.formatPrefix(value, precision);\n          value = unit.scale(value);\n          fullSuffix = unit.symbol + suffix;\n        } else {\n          value *= scale;\n        }\n        value = type(value, precision);\n        var i = value.lastIndexOf(\".\"), before, after;\n        if (i < 0) {\n          var j = exponent ? value.lastIndexOf(\"e\") : -1;\n          if (j < 0) before = value, after = \"\"; else before = value.substring(0, j), after = value.substring(j);\n        } else {\n          before = value.substring(0, i);\n          after = locale_decimal + value.substring(i + 1);\n        }\n        if (!zfill && comma) before = formatGroup(before, Infinity);\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\n        negative += prefix;\n        value = before + after;\n        return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n      };\n    };\n  }\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n  var d3_format_types = d3.map({\n    b: function(x) {\n      return x.toString(2);\n    },\n    c: function(x) {\n      return String.fromCharCode(x);\n    },\n    o: function(x) {\n      return x.toString(8);\n    },\n    x: function(x) {\n      return x.toString(16);\n    },\n    X: function(x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function(x, p) {\n      return x.toPrecision(p);\n    },\n    e: function(x, p) {\n      return x.toExponential(p);\n    },\n    f: function(x, p) {\n      return x.toFixed(p);\n    },\n    r: function(x, p) {\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n    }\n  });\n  function d3_format_typeDefault(x) {\n    return x + \"\";\n  }\n  var d3_time = d3.time = {}, d3_date = Date;\n  function d3_date_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n  d3_date_utc.prototype = {\n    getDate: function() {\n      return this._.getUTCDate();\n    },\n    getDay: function() {\n      return this._.getUTCDay();\n    },\n    getFullYear: function() {\n      return this._.getUTCFullYear();\n    },\n    getHours: function() {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function() {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function() {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function() {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function() {\n      return this._.getUTCSeconds();\n    },\n    getTime: function() {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function() {\n      return 0;\n    },\n    valueOf: function() {\n      return this._.valueOf();\n    },\n    setDate: function() {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function() {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function() {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function() {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function() {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function() {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function() {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function() {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function() {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date), d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n    function ceil(date) {\n      step(date = local(new d3_date(date - 1)), 1);\n      return date;\n    }\n    function offset(date, k) {\n      step(date = new d3_date(+date), k);\n      return date;\n    }\n    function range(t0, t1, dt) {\n      var time = ceil(t0), times = [];\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\n      }\n      return times;\n    }\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_date = Date;\n      }\n    }\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n  function d3_time_interval_utc(method) {\n    return function(date, k) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_date = Date;\n      }\n    };\n  }\n  d3_time.year = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(date) {\n    return date.getFullYear();\n  });\n  d3_time.years = d3_time.year.range;\n  d3_time.years.utc = d3_time.year.utc.range;\n  d3_time.day = d3_time_interval(function(date) {\n    var day = new d3_date(2e3, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n  d3_time.days = d3_time.day.range;\n  d3_time.days.utc = d3_time.day.utc.range;\n  d3_time.dayOfYear = function(date) {\n    var year = d3_time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n  [ \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\" ].forEach(function(day, i) {\n    i = 7 - i;\n    var interval = d3_time[day] = d3_time_interval(function(date) {\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function(date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3_time[day + \"s\"] = interval.range;\n    d3_time[day + \"s\"].utc = interval.utc.range;\n    d3_time[day + \"OfYear\"] = function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3_time.week = d3_time.sunday;\n  d3_time.weeks = d3_time.sunday.range;\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\n  d3_time.weekOfYear = d3_time.sundayOfYear;\n  function d3_locale_timeFormat(locale) {\n    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\n    function d3_time_format(template) {\n      var n = template.length;\n      function format(date) {\n        var string = [], i = -1, j = 0, c, p, f;\n        while (++i < n) {\n          if (template.charCodeAt(i) === 37) {\n            string.push(template.slice(j, i));\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n        string.push(template.slice(j, i));\n        return string.join(\"\");\n      }\n      format.parse = function(string) {\n        var d = {\n          y: 1900,\n          m: 0,\n          d: 1,\n          H: 0,\n          M: 0,\n          S: 0,\n          L: 0,\n          Z: null\n        }, i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null;\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();\n        if (\"j\" in d) date.setFullYear(d.y, 0, d.j); else if (\"W\" in d || \"U\" in d) {\n          if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n          date.setFullYear(d.y, 0, 1);\n          date.setFullYear(d.y, 0, \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n        } else date.setFullYear(d.y, d.m, d.d);\n        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\n        return localZ ? date._ : date;\n      };\n      format.toString = function() {\n        return template;\n      };\n      return format;\n    }\n    function d3_time_parse(date, template, string, j) {\n      var c, p, t, i = 0, n = template.length, m = string.length;\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n        if (c === 37) {\n          t = template.charAt(i++);\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n      return j;\n    }\n    d3_time_format.utc = function(template) {\n      var local = d3_time_format(template);\n      function format(date) {\n        try {\n          d3_date = d3_date_utc;\n          var utc = new d3_date();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_date = Date;\n        }\n      }\n      format.parse = function(string) {\n        try {\n          d3_date = d3_date_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_date = Date;\n        }\n      };\n      format.toString = local.toString;\n      return format;\n    };\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n    locale_periods.forEach(function(p, i) {\n      d3_time_periodLookup.set(p.toLowerCase(), i);\n    });\n    var d3_time_formats = {\n      a: function(d) {\n        return locale_shortDays[d.getDay()];\n      },\n      A: function(d) {\n        return locale_days[d.getDay()];\n      },\n      b: function(d) {\n        return locale_shortMonths[d.getMonth()];\n      },\n      B: function(d) {\n        return locale_months[d.getMonth()];\n      },\n      c: d3_time_format(locale_dateTime),\n      d: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      e: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      H: function(d, p) {\n        return d3_time_formatPad(d.getHours(), p, 2);\n      },\n      I: function(d, p) {\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n      },\n      j: function(d, p) {\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n      },\n      L: function(d, p) {\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\n      },\n      m: function(d, p) {\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\n      },\n      M: function(d, p) {\n        return d3_time_formatPad(d.getMinutes(), p, 2);\n      },\n      p: function(d) {\n        return locale_periods[+(d.getHours() >= 12)];\n      },\n      S: function(d, p) {\n        return d3_time_formatPad(d.getSeconds(), p, 2);\n      },\n      U: function(d, p) {\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n      },\n      w: function(d) {\n        return d.getDay();\n      },\n      W: function(d, p) {\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n      },\n      x: d3_time_format(locale_date),\n      X: d3_time_format(locale_time),\n      y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n      },\n      Y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n      },\n      Z: d3_time_zone,\n      \"%\": function() {\n        return \"%\";\n      }\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      j: d3_time_parseDayOfYear,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      U: d3_time_parseWeekNumberSunday,\n      w: d3_time_parseWeekdayNumber,\n      W: d3_time_parseWeekNumberMonday,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n      Z: d3_time_parseZone,\n      \"%\": d3_time_parseLiteralPercent\n    };\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (date.p = n, i);\n    }\n    return d3_time_format;\n  }\n  var d3_time_formatPads = {\n    \"-\": \"\",\n    _: \" \",\n    \"0\": \"0\"\n  }, d3_time_numberRe = /^\\s*\\d+/, d3_time_percentRe = /^%/;\n  function d3_time_formatPad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\", string = (sign ? -value : value) + \"\", length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n  function d3_time_formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n  }\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(), i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n  function d3_time_parseWeekdayNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 1));\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberSunday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberMonday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 4));\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n  }\n  function d3_time_parseZone(date, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, \n    i + 5) : -1;\n  }\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2e3);\n  }\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n  }\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseDayOfYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(), zs = z > 0 ? \"-\" : \"+\", zh = abs(z) / 60 | 0, zm = abs(z) % 60;\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n  }\n  function d3_time_parseLiteralPercent(date, string, i) {\n    d3_time_percentRe.lastIndex = 0;\n    var n = d3_time_percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n  function d3_time_formatMulti(formats) {\n    var n = formats.length, i = -1;\n    while (++i < n) formats[i][0] = this(formats[i][0]);\n    return function(date) {\n      var i = 0, f = formats[i];\n      while (!f[1](date)) f = formats[++i];\n      return f[0](date);\n    };\n  }\n  d3.locale = function(locale) {\n    return {\n      numberFormat: d3_locale_numberFormat(locale),\n      timeFormat: d3_locale_timeFormat(locale)\n    };\n  };\n  var d3_locale_enUS = d3.locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [ 3 ],\n    currency: [ \"$\", \"\" ],\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [ \"AM\", \"PM\" ],\n    days: [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ],\n    shortDays: [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ],\n    months: [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\n    shortMonths: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]\n  });\n  d3.format = d3_locale_enUS.numberFormat;\n  d3.geo = {};\n  function d3_adder() {}\n  d3_adder.prototype = {\n    s: 0,\n    t: 0,\n    add: function(y) {\n      d3_adderSum(y, this.t, d3_adderTemp);\n      d3_adderSum(d3_adderTemp.s, this.s, this);\n      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\n    },\n    reset: function() {\n      this.s = this.t = 0;\n    },\n    valueOf: function() {\n      return this.s;\n    }\n  };\n  var d3_adderTemp = new d3_adder();\n  function d3_adderSum(a, b, o) {\n    var x = o.s = a + b, bv = x - a, av = x - bv;\n    o.t = a - av + (b - bv);\n  }\n  d3.geo.stream = function(object, listener) {\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n  var d3_geo_streamObjectType = {\n    Feature: function(feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function(object, listener) {\n      var features = object.features, i = -1, n = features.length;\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function(object, listener) {\n      listener.sphere();\n    },\n    Point: function(object, listener) {\n      object = object.coordinates;\n      listener.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\n    },\n    LineString: function(object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n    },\n    Polygon: function(object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n    },\n    GeometryCollection: function(object, listener) {\n      var geometries = object.geometries, i = -1, n = geometries.length;\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n    }\n  };\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1, n = coordinates.length - closed, coordinate;\n    listener.lineStart();\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n    listener.lineEnd();\n  }\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1, n = coordinates.length;\n    listener.polygonStart();\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n    listener.polygonEnd();\n  }\n  d3.geo.area = function(object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\n  var d3_geo_area = {\n    sphere: function() {\n      d3_geo_areaSum += 4 * π;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_areaRingSum.reset();\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function() {\n      var area = 2 * d3_geo_areaRingSum;\n      d3_geo_areaSum += area < 0 ? 4 * π + area : area;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n  function d3_geo_areaRingStart() {\n    var λ00, φ00, λ0, cosφ0, sinφ0;\n    d3_geo_area.point = function(λ, φ) {\n      d3_geo_area.point = nextPoint;\n      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), \n      sinφ0 = Math.sin(φ);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      φ = φ * d3_radians / 2 + π / 4;\n      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);\n      d3_geo_areaRingSum.add(Math.atan2(v, u));\n      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\n    }\n    d3_geo_area.lineEnd = function() {\n      nextPoint(λ00, φ00);\n    };\n  }\n  function d3_geo_cartesian(spherical) {\n    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);\n    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];\n  }\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function d3_geo_cartesianCross(a, b) {\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\n  }\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n  function d3_geo_cartesianScale(vector, k) {\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\n  }\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n  function d3_geo_spherical(cartesian) {\n    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];\n  }\n  function d3_geo_sphericalEqual(a, b) {\n    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;\n  }\n  d3.geo.bounds = function() {\n    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;\n    var bound = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        bound.point = ringPoint;\n        bound.lineStart = ringStart;\n        bound.lineEnd = ringEnd;\n        dλSum = 0;\n        d3_geo_area.polygonStart();\n      },\n      polygonEnd: function() {\n        d3_geo_area.polygonEnd();\n        bound.point = point;\n        bound.lineStart = lineStart;\n        bound.lineEnd = lineEnd;\n        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;\n        range[0] = λ0, range[1] = λ1;\n      }\n    };\n    function point(λ, φ) {\n      ranges.push(range = [ λ0 = λ, λ1 = λ ]);\n      if (φ < φ0) φ0 = φ;\n      if (φ > φ1) φ1 = φ;\n    }\n    function linePoint(λ, φ) {\n      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);\n      if (p0) {\n        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);\n        d3_geo_cartesianNormalize(inflection);\n        inflection = d3_geo_spherical(inflection);\n        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;\n        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = inflection[1] * d3_degrees;\n          if (φi > φ1) φ1 = φi;\n        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = -inflection[1] * d3_degrees;\n          if (φi < φ0) φ0 = φi;\n        } else {\n          if (φ < φ0) φ0 = φ;\n          if (φ > φ1) φ1 = φ;\n        }\n        if (antimeridian) {\n          if (λ < λ_) {\n            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n          } else {\n            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n          }\n        } else {\n          if (λ1 >= λ0) {\n            if (λ < λ0) λ0 = λ;\n            if (λ > λ1) λ1 = λ;\n          } else {\n            if (λ > λ_) {\n              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n            } else {\n              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n            }\n          }\n        }\n      } else {\n        point(λ, φ);\n      }\n      p0 = p, λ_ = λ;\n    }\n    function lineStart() {\n      bound.point = linePoint;\n    }\n    function lineEnd() {\n      range[0] = λ0, range[1] = λ1;\n      bound.point = point;\n      p0 = null;\n    }\n    function ringPoint(λ, φ) {\n      if (p0) {\n        var dλ = λ - λ_;\n        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;\n      } else λ__ = λ, φ__ = φ;\n      d3_geo_area.point(λ, φ);\n      linePoint(λ, φ);\n    }\n    function ringStart() {\n      d3_geo_area.lineStart();\n    }\n    function ringEnd() {\n      ringPoint(λ__, φ__);\n      d3_geo_area.lineEnd();\n      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);\n      range[0] = λ0, range[1] = λ1;\n      p0 = null;\n    }\n    function angle(λ0, λ1) {\n      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;\n    }\n    function compareRanges(a, b) {\n      return a[0] - b[0];\n    }\n    function withinRange(x, range) {\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    return function(feature) {\n      φ1 = λ1 = -(λ0 = φ0 = Infinity);\n      ranges = [];\n      d3.geo.stream(feature, bound);\n      var n = ranges.length;\n      if (n) {\n        ranges.sort(compareRanges);\n        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {\n          b = ranges[i];\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n          } else {\n            merged.push(a = b);\n          }\n        }\n        var best = -Infinity, dλ;\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n          b = merged[i];\n          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];\n        }\n      }\n      ranges = range = null;\n      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];\n    };\n  }();\n  d3.geo.centroid = function(object) {\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\n    if (m < ε2) {\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\n      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n      m = x * x + y * y + z * z;\n      if (m < ε2) return [ NaN, NaN ];\n    }\n    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];\n  };\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  };\n  function d3_geo_centroidPoint(λ, φ) {\n    λ *= d3_radians;\n    var cosφ = Math.cos(φ *= d3_radians);\n    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));\n  }\n  function d3_geo_centroidPointXYZ(x, y, z) {\n    ++d3_geo_centroidW0;\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n  }\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroid.point = nextPoint;\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  }\n  function d3_geo_centroidRingStart() {\n    var λ00, φ00, x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ00 = λ, φ00 = φ;\n      d3_geo_centroid.point = nextPoint;\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    d3_geo_centroid.lineEnd = function() {\n      nextPoint(λ00, φ00);\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n      d3_geo_centroid.point = d3_geo_centroidPoint;\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);\n      d3_geo_centroidX2 += v * cx;\n      d3_geo_centroidY2 += v * cy;\n      d3_geo_centroidZ2 += v * cz;\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function(x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n  function d3_true() {\n    return true;\n  }\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n    var subject = [], clip = [];\n    segments.forEach(function(segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n, p0 = segment[0], p1 = segment[n];\n      if (d3_geo_sphericalEqual(p0, p1)) {\n        listener.lineStart();\n        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\n        listener.lineEnd();\n        return;\n      }\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(compare);\n    d3_geo_clipPolygonLinkCircular(subject);\n    d3_geo_clipPolygonLinkCircular(clip);\n    if (!subject.length) return;\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n      clip[i].e = entry = !entry;\n    }\n    var start = subject[0], points, point;\n    while (1) {\n      var current = start, isSubject = true;\n      while (current.v) if ((current = current.n) === start) return;\n      points = current.z;\n      listener.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.n.x, 1, listener);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.p.x, -1, listener);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      listener.lineEnd();\n    }\n  }\n  function d3_geo_clipPolygonLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n, i = 0, a = array[0], b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n    return function(rotate, listener) {\n      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n          if (segments.length) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n          } else if (clipStartInside) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function() {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n      function point(λ, φ) {\n        var point = rotate(λ, φ);\n        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);\n      }\n      function pointLine(λ, φ) {\n        var point = rotate(λ, φ);\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      var segments;\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;\n      function pointRing(λ, φ) {\n        ring.push([ λ, φ ]);\n        var point = rotate(λ, φ);\n        ringListener.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          var n = segment.length - 1, i = -1, point;\n          if (n > 0) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            while (++i < n) listener.point((point = segment[i])[0], point[1]);\n            listener.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n      return clip;\n    };\n  }\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n  function d3_geo_clipBufferListener() {\n    var lines = [], line;\n    return {\n      lineStart: function() {\n        lines.push(line = []);\n      },\n      point: function(λ, φ) {\n        line.push([ λ, φ ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function() {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      },\n      rejoin: function() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      }\n    };\n  }\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);\n  }\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);\n  function d3_geo_clipAntimeridianLine(listener) {\n    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;\n    return {\n      lineStart: function() {\n        listener.lineStart();\n        clean = 1;\n      },\n      point: function(λ1, φ1) {\n        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);\n        if (abs(dλ - π) < ε) {\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          listener.point(λ1, φ0);\n          clean = 0;\n        } else if (sλ0 !== sλ1 && dλ >= π) {\n          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\n          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          clean = 0;\n        }\n        listener.point(λ0 = λ1, φ0 = φ1);\n        sλ0 = sλ1;\n      },\n      lineEnd: function() {\n        listener.lineEnd();\n        λ0 = φ0 = NaN;\n      },\n      clean: function() {\n        return 2 - clean;\n      }\n    };\n  }\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\n    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);\n    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\n  }\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var φ;\n    if (from == null) {\n      φ = direction * halfπ;\n      listener.point(-π, φ);\n      listener.point(0, φ);\n      listener.point(π, φ);\n      listener.point(π, 0);\n      listener.point(π, -φ);\n      listener.point(0, -φ);\n      listener.point(-π, -φ);\n      listener.point(-π, 0);\n      listener.point(-π, φ);\n    } else if (abs(from[0] - to[0]) > ε) {\n      var s = from[0] < to[0] ? π : -π;\n      φ = direction * s / 2;\n      listener.point(-s, φ);\n      listener.point(0, φ);\n      listener.point(s, φ);\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n  function d3_geo_pointInPolygon(point, polygon) {\n    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;\n    d3_geo_areaRingSum.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      var ring = polygon[i], m = ring.length;\n      if (!m) continue;\n      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;\n      while (true) {\n        if (j === m) j = 0;\n        point = ring[j];\n        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;\n        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));\n        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;\n        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n          d3_geo_cartesianNormalize(arc);\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n          d3_geo_cartesianNormalize(intersection);\n          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ dλ >= 0 ? 1 : -1;\n          }\n        }\n        if (!j++) break;\n        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;\n      }\n    }\n    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;\n  }\n  function d3_geo_clipCircle(radius) {\n    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);\n    function visible(λ, φ) {\n      return Math.cos(λ) * Math.cos(φ) > cr;\n    }\n    function clipLine(listener) {\n      var point0, c0, v0, v00, clean;\n      return {\n        lineStart: function() {\n          v00 = v0 = false;\n          clean = 1;\n        },\n        point: function(λ, φ) {\n          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ε;\n              point1[1] += ε;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            clean = 0;\n            if (v) {\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              clean = 0;\n              if (smallRadius) {\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n              } else {\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n            listener.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function() {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        clean: function() {\n          return clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B);\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      q = d3_geo_spherical(q);\n      if (!two) return q;\n      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;\n      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;\n      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;\n      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;\n      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n        d3_geo_cartesianAdd(q1, A);\n        return [ q, d3_geo_spherical(q1) ];\n      }\n    }\n    function code(λ, φ) {\n      var r = smallRadius ? radius : π - radius, code = 0;\n      if (λ < -r) code |= 1; else if (λ > r) code |= 2;\n      if (φ < -r) code |= 4; else if (φ > r) code |= 8;\n      return code;\n    }\n  }\n  function d3_geom_clipLine(x0, y0, x1, y1) {\n    return function(line) {\n      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n      r = x0 - ax;\n      if (!dx && r > 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dx > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = x1 - ax;\n      if (!dx && r < 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dx > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      r = y0 - ay;\n      if (!dy && r > 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dy > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = y1 - ay;\n      if (!dy && r < 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dy > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      if (t0 > 0) line.a = {\n        x: ax + t0 * dx,\n        y: ay + t0 * dy\n      };\n      if (t1 < 1) line.b = {\n        x: ax + t1 * dx,\n        y: ay + t1 * dy\n      };\n      return line;\n    };\n  }\n  var d3_geo_clipExtentMAX = 1e9;\n  d3.geo.clipExtent = function() {\n    var x0, y0, x1, y1, stream, clip, clipExtent = {\n      stream: function(output) {\n        if (stream) stream.valid = false;\n        stream = clip(output);\n        stream.valid = true;\n        return stream;\n      },\n      extent: function(_) {\n        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n        if (stream) stream.valid = false, stream = null;\n        return clipExtent;\n      }\n    };\n    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);\n  };\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\n    return function(listener) {\n      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          listener = bufferListener;\n          segments = [];\n          polygon = [];\n          clean = true;\n        },\n        polygonEnd: function() {\n          listener = listener_;\n          segments = d3.merge(segments);\n          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;\n          if (inside || visible) {\n            listener.polygonStart();\n            if (inside) {\n              listener.lineStart();\n              interpolate(null, null, 1, listener);\n              listener.lineEnd();\n            }\n            if (visible) {\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n            }\n            listener.polygonEnd();\n          }\n          segments = polygon = ring = null;\n        }\n      };\n      function insidePolygon(p) {\n        var wn = 0, n = polygon.length, y = p[1];\n        for (var i = 0; i < n; ++i) {\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n            b = v[j];\n            if (a[1] <= y) {\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n            } else {\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n            }\n            a = b;\n          }\n        }\n        return wn !== 0;\n      }\n      function interpolate(from, to, direction, listener) {\n        var a = 0, a1 = 0;\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n          do {\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n          } while ((a = (a + direction + 4) % 4) !== a1);\n        } else {\n          listener.point(to[0], to[1]);\n        }\n      }\n      function pointVisible(x, y) {\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n      }\n      function point(x, y) {\n        if (pointVisible(x, y)) listener.point(x, y);\n      }\n      var x__, y__, v__, x_, y_, v_, first, clean;\n      function lineStart() {\n        clip.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferListener.rejoin();\n          segments.push(bufferListener.buffer());\n        }\n        clip.point = point;\n        if (v_) listener.lineEnd();\n      }\n      function linePoint(x, y) {\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n        var v = pointVisible(x, y);\n        if (polygon) ring.push([ x, y ]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            listener.lineStart();\n            listener.point(x, y);\n          }\n        } else {\n          if (v && v_) listener.point(x, y); else {\n            var l = {\n              a: {\n                x: x_,\n                y: y_\n              },\n              b: {\n                x: x,\n                y: y\n              }\n            };\n            if (clipLine(l)) {\n              if (!v_) {\n                listener.lineStart();\n                listener.point(l.a.x, l.a.y);\n              }\n              listener.point(l.b.x, l.b.y);\n              if (!v) listener.lineEnd();\n              clean = false;\n            } else if (v) {\n              listener.lineStart();\n              listener.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clip;\n    };\n    function corner(p, direction) {\n      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compare(a, b) {\n      return comparePoints(a.x, b.x);\n    }\n    function comparePoints(a, b) {\n      var ca = corner(a, 1), cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n  }\n  function d3_geo_conic(projectAt) {\n    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);\n    p.parallels = function(_) {\n      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];\n      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);\n    };\n    return p;\n  }\n  function d3_geo_conicEqualArea(φ0, φ1) {\n    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;\n    function forward(λ, φ) {\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\n      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = ρ0 - y;\n      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEqualArea = function() {\n    return d3_geo_conic(d3_geo_conicEqualArea);\n  }).raw = d3_geo_conicEqualArea;\n  d3.geo.albers = function() {\n    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);\n  };\n  d3.geo.albersUsa = function() {\n    var lower48 = d3.geo.albers();\n    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);\n    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);\n    var point, pointStream = {\n      point: function(x, y) {\n        point = [ x, y ];\n      }\n    }, lower48Point, alaskaPoint, hawaiiPoint;\n    function albersUsa(coordinates) {\n      var x = coordinates[0], y = coordinates[1];\n      point = null;\n      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\n      return point;\n    }\n    albersUsa.invert = function(coordinates) {\n      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n    };\n    albersUsa.stream = function(stream) {\n      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);\n      return {\n        point: function(x, y) {\n          lower48Stream.point(x, y);\n          alaskaStream.point(x, y);\n          hawaiiStream.point(x, y);\n        },\n        sphere: function() {\n          lower48Stream.sphere();\n          alaskaStream.sphere();\n          hawaiiStream.sphere();\n        },\n        lineStart: function() {\n          lower48Stream.lineStart();\n          alaskaStream.lineStart();\n          hawaiiStream.lineStart();\n        },\n        lineEnd: function() {\n          lower48Stream.lineEnd();\n          alaskaStream.lineEnd();\n          hawaiiStream.lineEnd();\n        },\n        polygonStart: function() {\n          lower48Stream.polygonStart();\n          alaskaStream.polygonStart();\n          hawaiiStream.polygonStart();\n        },\n        polygonEnd: function() {\n          lower48Stream.polygonEnd();\n          alaskaStream.polygonEnd();\n          hawaiiStream.polygonEnd();\n        }\n      };\n    };\n    albersUsa.precision = function(_) {\n      if (!arguments.length) return lower48.precision();\n      lower48.precision(_);\n      alaska.precision(_);\n      hawaii.precision(_);\n      return albersUsa;\n    };\n    albersUsa.scale = function(_) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(_);\n      alaska.scale(_ * .35);\n      hawaii.scale(_);\n      return albersUsa.translate(lower48.translate());\n    };\n    albersUsa.translate = function(_) {\n      if (!arguments.length) return lower48.translate();\n      var k = lower48.scale(), x = +_[0], y = +_[1];\n      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;\n      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      return albersUsa;\n    };\n    return albersUsa.scale(1070);\n  };\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathArea.point = function(x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    }\n    d3_geo_pathArea.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n  var d3_geo_pathBounds = {\n    point: d3_geo_pathBoundsPoint,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_pathBoundsPoint(x, y) {\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n  }\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointCircle = d3_geo_pathBufferCircle(_);\n        return stream;\n      },\n      result: function() {\n        if (buffer.length) {\n          var result = buffer.join(\"\");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n    function point(x, y) {\n      buffer.push(\"M\", x, \",\", y, pointCircle);\n    }\n    function pointLineStart(x, y) {\n      buffer.push(\"M\", x, \",\", y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      buffer.push(\"L\", x, \",\", y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      buffer.push(\"Z\");\n    }\n    return stream;\n  }\n  function d3_geo_pathBufferCircle(radius) {\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius + \"z\";\n  }\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    polygonStart: function() {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n  function d3_geo_pathCentroidPoint(x, y) {\n    d3_geo_centroidX0 += x;\n    d3_geo_centroidY0 += y;\n    ++d3_geo_centroidZ0;\n  }\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n  }\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      z = y0 * x - x0 * y;\n      d3_geo_centroidX2 += z * (x0 + x);\n      d3_geo_centroidY2 += z * (y0 + y);\n      d3_geo_centroidZ2 += z * 3;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n    d3_geo_pathCentroid.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  function d3_geo_pathContext(context) {\n    var pointRadius = 4.5;\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n    function point(x, y) {\n      context.moveTo(x + pointRadius, y);\n      context.arc(x, y, pointRadius, 0, τ);\n    }\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      context.closePath();\n    }\n    return stream;\n  }\n  function d3_geo_resample(project) {\n    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;\n    function resample(stream) {\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\n    }\n    function resampleNone(stream) {\n      return d3_geo_transformPoint(stream, function(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      });\n    }\n    function resampleRecursive(stream) {\n      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          stream.polygonStart();\n          resample.lineStart = ringStart;\n        },\n        polygonEnd: function() {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(λ, φ) {\n        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resample.point = ringPoint;\n        resample.lineEnd = ringEnd;\n      }\n      function ringPoint(λ, φ) {\n        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resample.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\n        resample.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resample;\n    }\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n      if (d2 > 4 * δ2 && depth--) {\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    resample.precision = function(_) {\n      if (!arguments.length) return Math.sqrt(δ2);\n      maxDepth = (δ2 = _ * _) > 0 && 16;\n      return resample;\n    };\n    return resample;\n  }\n  d3.geo.path = function() {\n    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\n    function path(object) {\n      if (object) {\n        if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n        d3.geo.stream(object, cacheStream);\n      }\n      return contextStream.result();\n    }\n    path.area = function(object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n    path.centroid = function(object) {\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\n    };\n    path.bounds = function(object) {\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\n    };\n    path.projection = function(_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return reset();\n    };\n    path.context = function(_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n      return reset();\n    };\n    path.pointRadius = function(_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n      return path;\n    };\n    function reset() {\n      cacheStream = null;\n      return path;\n    }\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function(x, y) {\n      return project([ x * d3_degrees, y * d3_degrees ]);\n    });\n    return function(stream) {\n      return d3_geo_projectionRadians(resample(stream));\n    };\n  }\n  d3.geo.transform = function(methods) {\n    return {\n      stream: function(stream) {\n        var transform = new d3_geo_transform(stream);\n        for (var k in methods) transform[k] = methods[k];\n        return transform;\n      }\n    };\n  };\n  function d3_geo_transform(stream) {\n    this.stream = stream;\n  }\n  d3_geo_transform.prototype = {\n    point: function(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function() {\n      this.stream.sphere();\n    },\n    lineStart: function() {\n      this.stream.lineStart();\n    },\n    lineEnd: function() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function() {\n      this.stream.polygonEnd();\n    }\n  };\n  function d3_geo_transformPoint(stream, point) {\n    return {\n      point: point,\n      sphere: function() {\n        stream.sphere();\n      },\n      lineStart: function() {\n        stream.lineStart();\n      },\n      lineEnd: function() {\n        stream.lineEnd();\n      },\n      polygonStart: function() {\n        stream.polygonStart();\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n      }\n    };\n  }\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function() {\n      return project;\n    })();\n  }\n  function d3_geo_projectionMutator(projectAt) {\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\n      x = project(x, y);\n      return [ x[0] * k + δx, δy - x[1] * k ];\n    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [ point[0] * k + δx, δy - point[1] * k ];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\n    }\n    projection.stream = function(output) {\n      if (stream) stream.valid = false;\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n      stream.valid = true;\n      return stream;\n    };\n    projection.clipAngle = function(_) {\n      if (!arguments.length) return clipAngle;\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n      return invalidate();\n    };\n    projection.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n      return invalidate();\n    };\n    projection.scale = function(_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n    projection.translate = function(_) {\n      if (!arguments.length) return [ x, y ];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n    projection.center = function(_) {\n      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];\n      λ = _[0] % 360 * d3_radians;\n      φ = _[1] % 360 * d3_radians;\n      return reset();\n    };\n    projection.rotate = function(_) {\n      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];\n      δλ = _[0] % 360 * d3_radians;\n      δφ = _[1] % 360 * d3_radians;\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n    d3.rebind(projection, projectResample, \"precision\");\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\n      var center = project(λ, φ);\n      δx = x - center[0] * k;\n      δy = y + center[1] * k;\n      return invalidate();\n    }\n    function invalidate() {\n      if (stream) stream.valid = false, stream = null;\n      return projection;\n    }\n    return function() {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n  function d3_geo_projectionRadians(stream) {\n    return d3_geo_transformPoint(stream, function(x, y) {\n      stream.point(x * d3_radians, y * d3_radians);\n    });\n  }\n  function d3_geo_equirectangular(λ, φ) {\n    return [ λ, φ ];\n  }\n  (d3.geo.equirectangular = function() {\n    return d3_geo_projection(d3_geo_equirectangular);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n  d3.geo.rotation = function(rotate) {\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    }\n    forward.invert = function(coordinates) {\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    };\n    return forward;\n  };\n  function d3_geo_identityRotation(λ, φ) {\n    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n  }\n  d3_geo_identityRotation.invert = d3_geo_equirectangular;\n  function d3_geo_rotation(δλ, δφ, δγ) {\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;\n  }\n  function d3_geo_forwardRotationλ(δλ) {\n    return function(λ, φ) {\n      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n    };\n  }\n  function d3_geo_rotationλ(δλ) {\n    var rotation = d3_geo_forwardRotationλ(δλ);\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\n    return rotation;\n  }\n  function d3_geo_rotationφγ(δφ, δγ) {\n    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);\n    function rotation(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;\n      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];\n    }\n    rotation.invert = function(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;\n      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];\n    };\n    return rotation;\n  }\n  d3.geo.circle = function() {\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\n    function circle() {\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\n      interpolate(null, null, 1, {\n        point: function(x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: \"Polygon\",\n        coordinates: [ ring ]\n      };\n    }\n    circle.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n    circle.angle = function(x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n    circle.precision = function(_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n    return circle.angle(90);\n  };\n  function d3_geo_circleInterpolate(radius, precision) {\n    var cr = Math.cos(radius), sr = Math.sin(radius);\n    return function(from, to, direction, listener) {\n      var step = direction * precision;\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * τ;\n      } else {\n        from = radius + direction * τ;\n        to = radius - .5 * step;\n      }\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\n      }\n    };\n  }\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = d3_acos(-a[1]);\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\n  }\n  d3.geo.distance = function(a, b) {\n    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;\n    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);\n  };\n  d3.geo.graticule = function() {\n    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n    function graticule() {\n      return {\n        type: \"MultiLineString\",\n        coordinates: lines()\n      };\n    }\n    function lines() {\n      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {\n        return abs(x % DX) > ε;\n      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {\n        return abs(y % DY) > ε;\n      }).map(y));\n    }\n    graticule.lines = function() {\n      return lines().map(function(coordinates) {\n        return {\n          type: \"LineString\",\n          coordinates: coordinates\n        };\n      });\n    };\n    graticule.outline = function() {\n      return {\n        type: \"Polygon\",\n        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]\n      };\n    };\n    graticule.extent = function(_) {\n      if (!arguments.length) return graticule.minorExtent();\n      return graticule.majorExtent(_).minorExtent(_);\n    };\n    graticule.majorExtent = function(_) {\n      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];\n      X0 = +_[0][0], X1 = +_[1][0];\n      Y0 = +_[0][1], Y1 = +_[1][1];\n      if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.minorExtent = function(_) {\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n      x0 = +_[0][0], x1 = +_[1][0];\n      y0 = +_[0][1], y1 = +_[1][1];\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.step = function(_) {\n      if (!arguments.length) return graticule.minorStep();\n      return graticule.majorStep(_).minorStep(_);\n    };\n    graticule.majorStep = function(_) {\n      if (!arguments.length) return [ DX, DY ];\n      DX = +_[0], DY = +_[1];\n      return graticule;\n    };\n    graticule.minorStep = function(_) {\n      if (!arguments.length) return [ dx, dy ];\n      dx = +_[0], dy = +_[1];\n      return graticule;\n    };\n    graticule.precision = function(_) {\n      if (!arguments.length) return precision;\n      precision = +_;\n      x = d3_geo_graticuleX(y0, y1, 90);\n      y = d3_geo_graticuleY(x0, x1, precision);\n      X = d3_geo_graticuleX(Y0, Y1, 90);\n      Y = d3_geo_graticuleY(X0, X1, precision);\n      return graticule;\n    };\n    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);\n  };\n  function d3_geo_graticuleX(y0, y1, dy) {\n    var y = d3.range(y0, y1 - ε, dy).concat(y1);\n    return function(x) {\n      return y.map(function(y) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_geo_graticuleY(x0, x1, dx) {\n    var x = d3.range(x0, x1 - ε, dx).concat(x1);\n    return function(y) {\n      return x.map(function(x) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_source(d) {\n    return d.source;\n  }\n  function d3_target(d) {\n    return d.target;\n  }\n  d3.geo.greatArc = function() {\n    var source = d3_source, source_, target = d3_target, target_;\n    function greatArc() {\n      return {\n        type: \"LineString\",\n        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]\n      };\n    }\n    greatArc.distance = function() {\n      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\n    };\n    greatArc.source = function(_) {\n      if (!arguments.length) return source;\n      source = _, source_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.target = function(_) {\n      if (!arguments.length) return target;\n      target = _, target_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.precision = function() {\n      return arguments.length ? greatArc : 0;\n    };\n    return greatArc;\n  };\n  d3.geo.interpolate = function(source, target) {\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n  };\n  function d3_geo_interpolate(x0, y0, x1, y1) {\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);\n    var interpolate = d ? function(t) {\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];\n    } : function() {\n      return [ x0 * d3_degrees, y0 * d3_degrees ];\n    };\n    interpolate.distance = d;\n    return interpolate;\n  }\n  d3.geo.length = function(object) {\n    d3_geo_lengthSum = 0;\n    d3.geo.stream(object, d3_geo_length);\n    return d3_geo_lengthSum;\n  };\n  var d3_geo_lengthSum;\n  var d3_geo_length = {\n    sphere: d3_noop,\n    point: d3_noop,\n    lineStart: d3_geo_lengthLineStart,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_lengthLineStart() {\n    var λ0, sinφ0, cosφ0;\n    d3_geo_length.point = function(λ, φ) {\n      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);\n      d3_geo_length.point = nextPoint;\n    };\n    d3_geo_length.lineEnd = function() {\n      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\n    };\n    function nextPoint(λ, φ) {\n      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);\n      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);\n      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;\n    }\n  }\n  function d3_geo_azimuthal(scale, angle) {\n    function azimuthal(λ, φ) {\n      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);\n      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];\n    }\n    azimuthal.invert = function(x, y) {\n      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);\n      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];\n    };\n    return azimuthal;\n  }\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {\n    return Math.sqrt(2 / (1 + cosλcosφ));\n  }, function(ρ) {\n    return 2 * Math.asin(ρ / 2);\n  });\n  (d3.geo.azimuthalEqualArea = function() {\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\n  }).raw = d3_geo_azimuthalEqualArea;\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {\n    var c = Math.acos(cosλcosφ);\n    return c && c / Math.sin(c);\n  }, d3_identity);\n  (d3.geo.azimuthalEquidistant = function() {\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\n  }).raw = d3_geo_azimuthalEquidistant;\n  function d3_geo_conicConformal(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), t = function(φ) {\n      return Math.tan(π / 4 + φ / 2);\n    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;\n    if (!n) return d3_geo_mercator;\n    function forward(λ, φ) {\n      if (F > 0) {\n        if (φ < -halfπ + ε) φ = -halfπ + ε;\n      } else {\n        if (φ > halfπ - ε) φ = halfπ - ε;\n      }\n      var ρ = F / Math.pow(t(φ), n);\n      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);\n      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];\n    };\n    return forward;\n  }\n  (d3.geo.conicConformal = function() {\n    return d3_geo_conic(d3_geo_conicConformal);\n  }).raw = d3_geo_conicConformal;\n  function d3_geo_conicEquidistant(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;\n    if (abs(n) < ε) return d3_geo_equirectangular;\n    function forward(λ, φ) {\n      var ρ = G - φ;\n      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = G - y;\n      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEquidistant = function() {\n    return d3_geo_conic(d3_geo_conicEquidistant);\n  }).raw = d3_geo_conicEquidistant;\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / cosλcosφ;\n  }, Math.atan);\n  (d3.geo.gnomonic = function() {\n    return d3_geo_projection(d3_geo_gnomonic);\n  }).raw = d3_geo_gnomonic;\n  function d3_geo_mercator(λ, φ) {\n    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];\n  }\n  d3_geo_mercator.invert = function(x, y) {\n    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];\n  };\n  function d3_geo_mercatorProjection(project) {\n    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\n    m.scale = function() {\n      var v = scale.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.translate = function() {\n      var v = translate.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.clipExtent = function(_) {\n      var v = clipExtent.apply(m, arguments);\n      if (v === m) {\n        if (clipAuto = _ == null) {\n          var k = π * scale(), t = translate();\n          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);\n        }\n      } else if (clipAuto) {\n        v = null;\n      }\n      return v;\n    };\n    return m.clipExtent(null);\n  }\n  (d3.geo.mercator = function() {\n    return d3_geo_mercatorProjection(d3_geo_mercator);\n  }).raw = d3_geo_mercator;\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\n    return 1;\n  }, Math.asin);\n  (d3.geo.orthographic = function() {\n    return d3_geo_projection(d3_geo_orthographic);\n  }).raw = d3_geo_orthographic;\n  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / (1 + cosλcosφ);\n  }, function(ρ) {\n    return 2 * Math.atan(ρ);\n  });\n  (d3.geo.stereographic = function() {\n    return d3_geo_projection(d3_geo_stereographic);\n  }).raw = d3_geo_stereographic;\n  function d3_geo_transverseMercator(λ, φ) {\n    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];\n  }\n  d3_geo_transverseMercator.invert = function(x, y) {\n    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];\n  };\n  (d3.geo.transverseMercator = function() {\n    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;\n    projection.center = function(_) {\n      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);\n    };\n    projection.rotate = function(_) {\n      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), \n      [ _[0], _[1], _[2] - 90 ]);\n    };\n    return rotate([ 0, 0, 90 ]);\n  }).raw = d3_geo_transverseMercator;\n  d3.geom = {};\n  function d3_geom_pointX(d) {\n    return d[0];\n  }\n  function d3_geom_pointY(d) {\n    return d[1];\n  }\n  d3.geom.hull = function(vertices) {\n    var x = d3_geom_pointX, y = d3_geom_pointY;\n    if (arguments.length) return hull(vertices);\n    function hull(data) {\n      if (data.length < 3) return [];\n      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];\n      for (i = 0; i < n; i++) {\n        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);\n      }\n      points.sort(d3_geom_hullOrder);\n      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);\n      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);\n      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\n      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\n      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\n      return polygon;\n    }\n    hull.x = function(_) {\n      return arguments.length ? (x = _, hull) : x;\n    };\n    hull.y = function(_) {\n      return arguments.length ? (y = _, hull) : y;\n    };\n    return hull;\n  };\n  function d3_geom_hullUpper(points) {\n    var n = points.length, hull = [ 0, 1 ], hs = 2;\n    for (var i = 2; i < n; i++) {\n      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\n      hull[hs++] = i;\n    }\n    return hull.slice(0, hs);\n  }\n  function d3_geom_hullOrder(a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  }\n  d3.geom.polygon = function(coordinates) {\n    d3_subclass(coordinates, d3_geom_polygonPrototype);\n    return coordinates;\n  };\n  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\n  d3_geom_polygonPrototype.area = function() {\n    var i = -1, n = this.length, a, b = this[n - 1], area = 0;\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      area += a[1] * b[0] - a[0] * b[1];\n    }\n    return area * .5;\n  };\n  d3_geom_polygonPrototype.centroid = function(k) {\n    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\n    if (!arguments.length) k = -1 / (6 * this.area());\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [ x * k, y * k ];\n  };\n  d3_geom_polygonPrototype.clip = function(subject) {\n    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = this[i];\n      c = input[(m = input.length - closed) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      if (closed) subject.push(subject[0]);\n      a = b;\n    }\n    return subject;\n  };\n  function d3_geom_polygonInside(p, a, b) {\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n  }\n  function d3_geom_polygonIntersect(c, d, a, b) {\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n    return [ x1 + ua * x21, y1 + ua * y21 ];\n  }\n  function d3_geom_polygonClosed(coordinates) {\n    var a = coordinates[0], b = coordinates[coordinates.length - 1];\n    return !(a[0] - b[0] || a[1] - b[1]);\n  }\n  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\n  function d3_geom_voronoiBeach() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.edge = this.site = this.circle = null;\n  }\n  function d3_geom_voronoiCreateBeach(site) {\n    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\n    beach.site = site;\n    return beach;\n  }\n  function d3_geom_voronoiDetachBeach(beach) {\n    d3_geom_voronoiDetachCircle(beach);\n    d3_geom_voronoiBeaches.remove(beach);\n    d3_geom_voronoiBeachPool.push(beach);\n    d3_geom_voronoiRedBlackNode(beach);\n  }\n  function d3_geom_voronoiRemoveBeach(beach) {\n    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\n      x: x,\n      y: y\n    }, previous = beach.P, next = beach.N, disappearing = [ beach ];\n    d3_geom_voronoiDetachBeach(beach);\n    var lArc = previous;\n    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {\n      previous = lArc.P;\n      disappearing.unshift(lArc);\n      d3_geom_voronoiDetachBeach(lArc);\n      lArc = previous;\n    }\n    disappearing.unshift(lArc);\n    d3_geom_voronoiDetachCircle(lArc);\n    var rArc = next;\n    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {\n      next = rArc.N;\n      disappearing.push(rArc);\n      d3_geom_voronoiDetachBeach(rArc);\n      rArc = next;\n    }\n    disappearing.push(rArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var nArcs = disappearing.length, iArc;\n    for (iArc = 1; iArc < nArcs; ++iArc) {\n      rArc = disappearing[iArc];\n      lArc = disappearing[iArc - 1];\n      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n    }\n    lArc = disappearing[0];\n    rArc = disappearing[nArcs - 1];\n    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiAddBeach(site) {\n    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\n    while (node) {\n      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\n      if (dxl > ε) node = node.L; else {\n        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\n        if (dxr > ε) {\n          if (!node.R) {\n            lArc = node;\n            break;\n          }\n          node = node.R;\n        } else {\n          if (dxl > -ε) {\n            lArc = node.P;\n            rArc = node;\n          } else if (dxr > -ε) {\n            lArc = node;\n            rArc = node.N;\n          } else {\n            lArc = rArc = node;\n          }\n          break;\n        }\n      }\n    }\n    var newArc = d3_geom_voronoiCreateBeach(site);\n    d3_geom_voronoiBeaches.insert(lArc, newArc);\n    if (!lArc && !rArc) return;\n    if (lArc === rArc) {\n      d3_geom_voronoiDetachCircle(lArc);\n      rArc = d3_geom_voronoiCreateBeach(lArc.site);\n      d3_geom_voronoiBeaches.insert(newArc, rArc);\n      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      d3_geom_voronoiAttachCircle(lArc);\n      d3_geom_voronoiAttachCircle(rArc);\n      return;\n    }\n    if (!rArc) {\n      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      return;\n    }\n    d3_geom_voronoiDetachCircle(lArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\n      x: (cy * hb - by * hc) / d + ax,\n      y: (bx * hc - cx * hb) / d + ay\n    };\n    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\n    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\n    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\n    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\n    if (!pby2) return rfocx;\n    var lArc = arc.P;\n    if (!lArc) return -Infinity;\n    site = lArc.site;\n    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\n    if (!plby2) return lfocx;\n    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n    return (rfocx + lfocx) / 2;\n  }\n  function d3_geom_voronoiRightBreakPoint(arc, directrix) {\n    var rArc = arc.N;\n    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n  }\n  function d3_geom_voronoiCell(site) {\n    this.site = site;\n    this.edges = [];\n  }\n  d3_geom_voronoiCell.prototype.prepare = function() {\n    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\n    while (iHalfEdge--) {\n      edge = halfEdges[iHalfEdge].edge;\n      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n    }\n    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n    return halfEdges.length;\n  };\n  function d3_geom_voronoiCloseCells(extent) {\n    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\n    while (iCell--) {\n      cell = cells[iCell];\n      if (!cell || !cell.prepare()) continue;\n      halfEdges = cell.edges;\n      nHalfEdges = halfEdges.length;\n      iHalfEdge = 0;\n      while (iHalfEdge < nHalfEdges) {\n        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {\n            x: x0,\n            y: abs(x2 - x0) < ε ? y2 : y1\n          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {\n            x: abs(y2 - y1) < ε ? x2 : x1,\n            y: y1\n          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {\n            x: x1,\n            y: abs(x2 - x1) < ε ? y2 : y0\n          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {\n            x: abs(y2 - y0) < ε ? x2 : x0,\n            y: y0\n          } : null), cell.site, null));\n          ++nHalfEdges;\n        }\n      }\n    }\n  }\n  function d3_geom_voronoiHalfEdgeOrder(a, b) {\n    return b.angle - a.angle;\n  }\n  function d3_geom_voronoiCircle() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.x = this.y = this.arc = this.site = this.cy = null;\n  }\n  function d3_geom_voronoiAttachCircle(arc) {\n    var lArc = arc.P, rArc = arc.N;\n    if (!lArc || !rArc) return;\n    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n    if (lSite === rSite) return;\n    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\n    var d = 2 * (ax * cy - ay * cx);\n    if (d >= -ε2) return;\n    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;\n    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\n    circle.arc = arc;\n    circle.site = cSite;\n    circle.x = x + bx;\n    circle.y = cy + Math.sqrt(x * x + y * y);\n    circle.cy = cy;\n    arc.circle = circle;\n    var before = null, node = d3_geom_voronoiCircles._;\n    while (node) {\n      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n        if (node.L) node = node.L; else {\n          before = node.P;\n          break;\n        }\n      } else {\n        if (node.R) node = node.R; else {\n          before = node;\n          break;\n        }\n      }\n    }\n    d3_geom_voronoiCircles.insert(before, circle);\n    if (!before) d3_geom_voronoiFirstCircle = circle;\n  }\n  function d3_geom_voronoiDetachCircle(arc) {\n    var circle = arc.circle;\n    if (circle) {\n      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\n      d3_geom_voronoiCircles.remove(circle);\n      d3_geom_voronoiCirclePool.push(circle);\n      d3_geom_voronoiRedBlackNode(circle);\n      arc.circle = null;\n    }\n  }\n  function d3_geom_voronoiClipEdges(extent) {\n    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;\n    while (i--) {\n      e = edges[i];\n      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {\n        e.a = e.b = null;\n        edges.splice(i, 1);\n      }\n    }\n  }\n  function d3_geom_voronoiConnectEdge(edge, extent) {\n    var vb = edge.b;\n    if (vb) return true;\n    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n    if (ry === ly) {\n      if (fx < x0 || fx >= x1) return;\n      if (lx > rx) {\n        if (!va) va = {\n          x: fx,\n          y: y0\n        }; else if (va.y >= y1) return;\n        vb = {\n          x: fx,\n          y: y1\n        };\n      } else {\n        if (!va) va = {\n          x: fx,\n          y: y1\n        }; else if (va.y < y0) return;\n        vb = {\n          x: fx,\n          y: y0\n        };\n      }\n    } else {\n      fm = (lx - rx) / (ry - ly);\n      fb = fy - fm * fx;\n      if (fm < -1 || fm > 1) {\n        if (lx > rx) {\n          if (!va) va = {\n            x: (y0 - fb) / fm,\n            y: y0\n          }; else if (va.y >= y1) return;\n          vb = {\n            x: (y1 - fb) / fm,\n            y: y1\n          };\n        } else {\n          if (!va) va = {\n            x: (y1 - fb) / fm,\n            y: y1\n          }; else if (va.y < y0) return;\n          vb = {\n            x: (y0 - fb) / fm,\n            y: y0\n          };\n        }\n      } else {\n        if (ly < ry) {\n          if (!va) va = {\n            x: x0,\n            y: fm * x0 + fb\n          }; else if (va.x >= x1) return;\n          vb = {\n            x: x1,\n            y: fm * x1 + fb\n          };\n        } else {\n          if (!va) va = {\n            x: x1,\n            y: fm * x1 + fb\n          }; else if (va.x < x0) return;\n          vb = {\n            x: x0,\n            y: fm * x0 + fb\n          };\n        }\n      }\n    }\n    edge.a = va;\n    edge.b = vb;\n    return true;\n  }\n  function d3_geom_voronoiEdge(lSite, rSite) {\n    this.l = lSite;\n    this.r = rSite;\n    this.a = this.b = null;\n  }\n  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, rSite);\n    d3_geom_voronoiEdges.push(edge);\n    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\n    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\n    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\n    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\n    return edge;\n  }\n  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, null);\n    edge.a = va;\n    edge.b = vb;\n    d3_geom_voronoiEdges.push(edge);\n    return edge;\n  }\n  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\n    if (!edge.a && !edge.b) {\n      edge.a = vertex;\n      edge.l = lSite;\n      edge.r = rSite;\n    } else if (edge.l === rSite) {\n      edge.b = vertex;\n    } else {\n      edge.a = vertex;\n    }\n  }\n  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\n    var va = edge.a, vb = edge.b;\n    this.edge = edge;\n    this.site = lSite;\n    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n  }\n  d3_geom_voronoiHalfEdge.prototype = {\n    start: function() {\n      return this.edge.l === this.site ? this.edge.a : this.edge.b;\n    },\n    end: function() {\n      return this.edge.l === this.site ? this.edge.b : this.edge.a;\n    }\n  };\n  function d3_geom_voronoiRedBlackTree() {\n    this._ = null;\n  }\n  function d3_geom_voronoiRedBlackNode(node) {\n    node.U = node.C = node.L = node.R = node.P = node.N = null;\n  }\n  d3_geom_voronoiRedBlackTree.prototype = {\n    insert: function(after, node) {\n      var parent, grandpa, uncle;\n      if (after) {\n        node.P = after;\n        node.N = after.N;\n        if (after.N) after.N.P = node;\n        after.N = node;\n        if (after.R) {\n          after = after.R;\n          while (after.L) after = after.L;\n          after.L = node;\n        } else {\n          after.R = node;\n        }\n        parent = after;\n      } else if (this._) {\n        after = d3_geom_voronoiRedBlackFirst(this._);\n        node.P = null;\n        node.N = after;\n        after.P = after.L = node;\n        parent = after;\n      } else {\n        node.P = node.N = null;\n        this._ = node;\n        parent = null;\n      }\n      node.L = node.R = null;\n      node.U = parent;\n      node.C = true;\n      after = node;\n      while (parent && parent.C) {\n        grandpa = parent.U;\n        if (parent === grandpa.L) {\n          uncle = grandpa.R;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.R) {\n              d3_geom_voronoiRedBlackRotateLeft(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, grandpa);\n          }\n        } else {\n          uncle = grandpa.L;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.L) {\n              d3_geom_voronoiRedBlackRotateRight(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\n          }\n        }\n        parent = after.U;\n      }\n      this._.C = false;\n    },\n    remove: function(node) {\n      if (node.N) node.N.P = node.P;\n      if (node.P) node.P.N = node.N;\n      node.N = node.P = null;\n      var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);\n      if (parent) {\n        if (parent.L === node) parent.L = next; else parent.R = next;\n      } else {\n        this._ = next;\n      }\n      if (left && right) {\n        red = next.C;\n        next.C = node.C;\n        next.L = left;\n        left.U = next;\n        if (next !== right) {\n          parent = next.U;\n          next.U = node.U;\n          node = next.R;\n          parent.L = node;\n          next.R = right;\n          right.U = next;\n        } else {\n          next.U = parent;\n          parent = next;\n          node = next.R;\n        }\n      } else {\n        red = node.C;\n        node = next;\n      }\n      if (node) node.U = parent;\n      if (red) return;\n      if (node && node.C) {\n        node.C = false;\n        return;\n      }\n      do {\n        if (node === this._) break;\n        if (node === parent.L) {\n          sibling = parent.R;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            sibling = parent.R;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.R || !sibling.R.C) {\n              sibling.L.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateRight(this, sibling);\n              sibling = parent.R;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.R.C = false;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            node = this._;\n            break;\n          }\n        } else {\n          sibling = parent.L;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            sibling = parent.L;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.L || !sibling.L.C) {\n              sibling.R.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateLeft(this, sibling);\n              sibling = parent.L;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.L.C = false;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            node = this._;\n            break;\n          }\n        }\n        sibling.C = true;\n        node = parent;\n        parent = parent.U;\n      } while (!node.C);\n      if (node) node.C = false;\n    }\n  };\n  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\n    var p = node, q = node.R, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.R = q.L;\n    if (p.R) p.R.U = p;\n    q.L = p;\n  }\n  function d3_geom_voronoiRedBlackRotateRight(tree, node) {\n    var p = node, q = node.L, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.L = q.R;\n    if (p.L) p.L.U = p;\n    q.R = p;\n  }\n  function d3_geom_voronoiRedBlackFirst(node) {\n    while (node.L) node = node.L;\n    return node;\n  }\n  function d3_geom_voronoi(sites, bbox) {\n    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;\n    d3_geom_voronoiEdges = [];\n    d3_geom_voronoiCells = new Array(sites.length);\n    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\n    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\n    while (true) {\n      circle = d3_geom_voronoiFirstCircle;\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n        if (site.x !== x0 || site.y !== y0) {\n          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\n          d3_geom_voronoiAddBeach(site);\n          x0 = site.x, y0 = site.y;\n        }\n        site = sites.pop();\n      } else if (circle) {\n        d3_geom_voronoiRemoveBeach(circle.arc);\n      } else {\n        break;\n      }\n    }\n    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\n    var diagram = {\n      cells: d3_geom_voronoiCells,\n      edges: d3_geom_voronoiEdges\n    };\n    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\n    return diagram;\n  }\n  function d3_geom_voronoiVertexOrder(a, b) {\n    return b.y - a.y || b.x - a.x;\n  }\n  d3.geom.voronoi = function(points) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\n    if (points) return voronoi(points);\n    function voronoi(data) {\n      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\n      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {\n          var s = e.start();\n          return [ s.x, s.y ];\n        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\n        polygon.point = data[i];\n      });\n      return polygons;\n    }\n    function sites(data) {\n      return data.map(function(d, i) {\n        return {\n          x: Math.round(fx(d, i) / ε) * ε,\n          y: Math.round(fy(d, i) / ε) * ε,\n          i: i\n        };\n      });\n    }\n    voronoi.links = function(data) {\n      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n        return edge.l && edge.r;\n      }).map(function(edge) {\n        return {\n          source: data[edge.l.i],\n          target: data[edge.r.i]\n        };\n      });\n    };\n    voronoi.triangles = function(data) {\n      var triangles = [];\n      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\n        while (++j < m) {\n          e0 = e1;\n          s0 = s1;\n          e1 = edges[j].edge;\n          s1 = e1.l === site ? e1.r : e1.l;\n          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n            triangles.push([ data[i], data[s0.i], data[s1.i] ]);\n          }\n        }\n      });\n      return triangles;\n    };\n    voronoi.x = function(_) {\n      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n    };\n    voronoi.y = function(_) {\n      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n    };\n    voronoi.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n      return voronoi;\n    };\n    voronoi.size = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);\n    };\n    return voronoi;\n  };\n  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\n  function d3_geom_voronoiTriangleArea(a, b, c) {\n    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n  }\n  d3.geom.delaunay = function(vertices) {\n    return d3.geom.voronoi().triangles(vertices);\n  };\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, compat;\n    if (compat = arguments.length) {\n      x = d3_geom_quadtreeCompatX;\n      y = d3_geom_quadtreeCompatY;\n      if (compat === 3) {\n        y2 = y1;\n        x2 = x1;\n        y1 = x1 = 0;\n      }\n      return quadtree(points);\n    }\n    function quadtree(data) {\n      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;\n      if (x1 != null) {\n        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n      } else {\n        x2_ = y2_ = -(x1_ = y1_ = Infinity);\n        xs = [], ys = [];\n        n = data.length;\n        if (compat) for (i = 0; i < n; ++i) {\n          d = data[i];\n          if (d.x < x1_) x1_ = d.x;\n          if (d.y < y1_) y1_ = d.y;\n          if (d.x > x2_) x2_ = d.x;\n          if (d.y > y2_) y2_ = d.y;\n          xs.push(d.x);\n          ys.push(d.y);\n        } else for (i = 0; i < n; ++i) {\n          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);\n          if (x_ < x1_) x1_ = x_;\n          if (y_ < y1_) y1_ = y_;\n          if (x_ > x2_) x2_ = x_;\n          if (y_ > y2_) y2_ = y_;\n          xs.push(x_);\n          ys.push(y_);\n        }\n      }\n      var dx = x2_ - x1_, dy = y2_ - y1_;\n      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;\n      function insert(n, d, x, y, x1, y1, x2, y2) {\n        if (isNaN(x) || isNaN(y)) return;\n        if (n.leaf) {\n          var nx = n.x, ny = n.y;\n          if (nx != null) {\n            if (abs(nx - x) + abs(ny - y) < .01) {\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            } else {\n              var nPoint = n.point;\n              n.x = n.y = n.point = null;\n              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            }\n          } else {\n            n.x = x, n.y = y, n.point = d;\n          }\n        } else {\n          insertChild(n, d, x, y, x1, y1, x2, y2);\n        }\n      }\n      function insertChild(n, d, x, y, x1, y1, x2, y2) {\n        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\n        n.leaf = false;\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n        if (right) x1 = xm; else x2 = xm;\n        if (below) y1 = ym; else y2 = ym;\n        insert(n, d, x, y, x1, y1, x2, y2);\n      }\n      var root = d3_geom_quadtreeNode();\n      root.add = function(d) {\n        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\n      };\n      root.visit = function(f) {\n        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\n      };\n      root.find = function(point) {\n        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\n      };\n      i = -1;\n      if (x1 == null) {\n        while (++i < n) {\n          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\n        }\n        --i;\n      } else data.forEach(root.add);\n      xs = ys = data = d = null;\n      return root;\n    }\n    quadtree.x = function(_) {\n      return arguments.length ? (x = _, quadtree) : x;\n    };\n    quadtree.y = function(_) {\n      return arguments.length ? (y = _, quadtree) : y;\n    };\n    quadtree.extent = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], \n      y2 = +_[1][1];\n      return quadtree;\n    };\n    quadtree.size = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\n      return quadtree;\n    };\n    return quadtree;\n  };\n  function d3_geom_quadtreeCompatX(d) {\n    return d.x;\n  }\n  function d3_geom_quadtreeCompatY(d) {\n    return d.y;\n  }\n  function d3_geom_quadtreeNode() {\n    return {\n      leaf: true,\n      nodes: [],\n      point: null,\n      x: null,\n      y: null\n    };\n  }\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n    if (!f(node, x1, y1, x2, y2)) {\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n    }\n  }\n  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\n    var minDistance2 = Infinity, closestPoint;\n    (function find(node, x1, y1, x2, y2) {\n      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\n      if (point = node.point) {\n        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\n        if (distance2 < minDistance2) {\n          var distance = Math.sqrt(minDistance2 = distance2);\n          x0 = x - distance, y0 = y - distance;\n          x3 = x + distance, y3 = y + distance;\n          closestPoint = point;\n        }\n      }\n      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;\n      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\n        if (node = children[i & 3]) switch (i & 3) {\n         case 0:\n          find(node, x1, y1, xm, ym);\n          break;\n\n         case 1:\n          find(node, xm, y1, x2, ym);\n          break;\n\n         case 2:\n          find(node, x1, ym, xm, y2);\n          break;\n\n         case 3:\n          find(node, xm, ym, x2, y2);\n          break;\n        }\n      }\n    })(root, x0, y0, x3, y3);\n    return closestPoint;\n  }\n  d3.interpolateRgb = d3_interpolateRgb;\n  function d3_interpolateRgb(a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\n    return function(t) {\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  }\n  d3.interpolateObject = d3_interpolateObject;\n  function d3_interpolateObject(a, b) {\n    var i = {}, c = {}, k;\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolate(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n    return function(t) {\n      for (k in i) c[k] = i[k](t);\n      return c;\n    };\n  }\n  d3.interpolateNumber = d3_interpolateNumber;\n  function d3_interpolateNumber(a, b) {\n    a = +a, b = +b;\n    return function(t) {\n      return a * (1 - t) + b * t;\n    };\n  }\n  d3.interpolateString = d3_interpolateString;\n  function d3_interpolateString(a, b) {\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\n    a = a + \"\", b = b + \"\";\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n      if ((bs = bm.index) > bi) {\n        bs = b.slice(bi, bs);\n        if (s[i]) s[i] += bs; else s[++i] = bs;\n      }\n      if ((am = am[0]) === (bm = bm[0])) {\n        if (s[i]) s[i] += bm; else s[++i] = bm;\n      } else {\n        s[++i] = null;\n        q.push({\n          i: i,\n          x: d3_interpolateNumber(am, bm)\n        });\n      }\n      bi = d3_interpolate_numberB.lastIndex;\n    }\n    if (bi < b.length) {\n      bs = b.slice(bi);\n      if (s[i]) s[i] += bs; else s[++i] = bs;\n    }\n    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {\n      return b(t) + \"\";\n    }) : function() {\n      return b;\n    } : (b = q.length, function(t) {\n      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    });\n  }\n  var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \"g\");\n  d3.interpolate = d3_interpolate;\n  function d3_interpolate(a, b) {\n    var i = d3.interpolators.length, f;\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\n    return f;\n  }\n  d3.interpolators = [ function(a, b) {\n    var t = typeof b;\n    return (t === \"string\" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\(|hsl\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \"object\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n  } ];\n  d3.interpolateArray = d3_interpolateArray;\n  function d3_interpolateArray(a, b) {\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\n    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\n    for (;i < na; ++i) c[i] = a[i];\n    for (;i < nb; ++i) c[i] = b[i];\n    return function(t) {\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\n      return c;\n    };\n  }\n  var d3_ease_default = function() {\n    return d3_identity;\n  };\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function() {\n      return d3_ease_quad;\n    },\n    cubic: function() {\n      return d3_ease_cubic;\n    },\n    sin: function() {\n      return d3_ease_sin;\n    },\n    exp: function() {\n      return d3_ease_exp;\n    },\n    circle: function() {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function() {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    \"in\": d3_identity,\n    out: d3_ease_reverse,\n    \"in-out\": d3_ease_reflect,\n    \"out-in\": function(f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n  d3.ease = function(name) {\n    var i = name.indexOf(\"-\"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : \"in\";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n  };\n  function d3_ease_clamp(f) {\n    return function(t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n  function d3_ease_reverse(f) {\n    return function(t) {\n      return 1 - f(1 - t);\n    };\n  }\n  function d3_ease_reflect(f) {\n    return function(t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  }\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t, t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n  function d3_ease_poly(e) {\n    return function(t) {\n      return Math.pow(t, e);\n    };\n  }\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * halfπ);\n  }\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = .45;\n    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;\n    return function(t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);\n    };\n  }\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function(t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n  d3.interpolateHcl = d3_interpolateHcl;\n  function d3_interpolateHcl(a, b) {\n    a = d3.hcl(a);\n    b = d3.hcl(b);\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\n    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateHsl = d3_interpolateHsl;\n  function d3_interpolateHsl(a, b) {\n    a = d3.hsl(a);\n    b = d3.hsl(b);\n    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\n    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateLab = d3_interpolateLab;\n  function d3_interpolateLab(a, b) {\n    a = d3.lab(a);\n    b = d3.lab(b);\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\n    return function(t) {\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n    };\n  }\n  d3.interpolateRound = d3_interpolateRound;\n  function d3_interpolateRound(a, b) {\n    b -= a;\n    return function(t) {\n      return Math.round(a + b * t);\n    };\n  }\n  d3.transform = function(string) {\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\n    return (d3.transform = function(string) {\n      if (string != null) {\n        g.setAttribute(\"transform\", string);\n        var t = g.transform.baseVal.consolidate();\n      }\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  };\n  function d3_transform(m) {\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [ m.e, m.f ];\n    this.scale = [ kx, ky ];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n  d3_transform.prototype.toString = function() {\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n  };\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n    return k;\n  }\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n  d3.interpolateTransform = d3_interpolateTransform;\n  function d3_interpolateTransformPop(s) {\n    return s.length ? s.pop() + \",\" : \"\";\n  }\n  function d3_interpolateTranslate(ta, tb, s, q) {\n    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\n      var i = s.push(\"translate(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ta[0], tb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push(\"translate(\" + tb + \")\");\n    }\n  }\n  function d3_interpolateRotate(ra, rb, s, q) {\n    if (ra !== rb) {\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"rotate(\", null, \")\") - 2,\n        x: d3_interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(d3_interpolateTransformPop(s) + \"rotate(\" + rb + \")\");\n    }\n  }\n  function d3_interpolateSkew(wa, wb, s, q) {\n    if (wa !== wb) {\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"skewX(\", null, \")\") - 2,\n        x: d3_interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(d3_interpolateTransformPop(s) + \"skewX(\" + wb + \")\");\n    }\n  }\n  function d3_interpolateScale(ka, kb, s, q) {\n    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\n      var i = s.push(d3_interpolateTransformPop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ka[0], kb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] !== 1 || kb[1] !== 1) {\n      s.push(d3_interpolateTransformPop(s) + \"scale(\" + kb + \")\");\n    }\n  }\n  function d3_interpolateTransform(a, b) {\n    var s = [], q = [];\n    a = d3.transform(a), b = d3.transform(b);\n    d3_interpolateTranslate(a.translate, b.translate, s, q);\n    d3_interpolateRotate(a.rotate, b.rotate, s, q);\n    d3_interpolateSkew(a.skew, b.skew, s, q);\n    d3_interpolateScale(a.scale, b.scale, s, q);\n    a = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  }\n  function d3_uninterpolateNumber(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return (x - a) / b;\n    };\n  }\n  function d3_uninterpolateClamp(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return Math.max(0, Math.min(1, (x - a) / b));\n    };\n  }\n  d3.layout = {};\n  d3.layout.bundle = function() {\n    return function(links) {\n      var paths = [], i = -1, n = links.length;\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n      return paths;\n    };\n  };\n  function d3_layout_bundlePath(link) {\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\n    while (start !== lca) {\n      start = start.parent;\n      points.push(start);\n    }\n    var k = points.length;\n    while (end !== lca) {\n      points.splice(k, 0, end);\n      end = end.parent;\n    }\n    return points;\n  }\n  function d3_layout_bundleAncestors(node) {\n    var ancestors = [], parent = node.parent;\n    while (parent != null) {\n      ancestors.push(node);\n      node = parent;\n      parent = parent.parent;\n    }\n    ancestors.push(node);\n    return ancestors;\n  }\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\n    if (a === b) return a;\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\n    while (aNode === bNode) {\n      sharedNode = aNode;\n      aNode = aNodes.pop();\n      bNode = bNodes.pop();\n    }\n    return sharedNode;\n  }\n  d3.layout.chord = function() {\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\n    function relayout() {\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\n      chords = [];\n      groups = [];\n      k = 0, i = -1;\n      while (++i < n) {\n        x = 0, j = -1;\n        while (++j < n) {\n          x += matrix[i][j];\n        }\n        groupSums.push(x);\n        subgroupIndex.push(d3.range(n));\n        k += x;\n      }\n      if (sortGroups) {\n        groupIndex.sort(function(a, b) {\n          return sortGroups(groupSums[a], groupSums[b]);\n        });\n      }\n      if (sortSubgroups) {\n        subgroupIndex.forEach(function(d, i) {\n          d.sort(function(a, b) {\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\n          });\n        });\n      }\n      k = (τ - padding * n) / k;\n      x = 0, i = -1;\n      while (++i < n) {\n        x0 = x, j = -1;\n        while (++j < n) {\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\n          subgroups[di + \"-\" + dj] = {\n            index: di,\n            subindex: dj,\n            startAngle: a0,\n            endAngle: a1,\n            value: v\n          };\n        }\n        groups[di] = {\n          index: di,\n          startAngle: x0,\n          endAngle: x,\n          value: groupSums[di]\n        };\n        x += padding;\n      }\n      i = -1;\n      while (++i < n) {\n        j = i - 1;\n        while (++j < n) {\n          var source = subgroups[i + \"-\" + j], target = subgroups[j + \"-\" + i];\n          if (source.value || target.value) {\n            chords.push(source.value < target.value ? {\n              source: target,\n              target: source\n            } : {\n              source: source,\n              target: target\n            });\n          }\n        }\n      }\n      if (sortChords) resort();\n    }\n    function resort() {\n      chords.sort(function(a, b) {\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n      });\n    }\n    chord.matrix = function(x) {\n      if (!arguments.length) return matrix;\n      n = (matrix = x) && matrix.length;\n      chords = groups = null;\n      return chord;\n    };\n    chord.padding = function(x) {\n      if (!arguments.length) return padding;\n      padding = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortGroups = function(x) {\n      if (!arguments.length) return sortGroups;\n      sortGroups = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortSubgroups = function(x) {\n      if (!arguments.length) return sortSubgroups;\n      sortSubgroups = x;\n      chords = null;\n      return chord;\n    };\n    chord.sortChords = function(x) {\n      if (!arguments.length) return sortChords;\n      sortChords = x;\n      if (chords) resort();\n      return chord;\n    };\n    chord.chords = function() {\n      if (!chords) relayout();\n      return chords;\n    };\n    chord.groups = function() {\n      if (!groups) relayout();\n      return groups;\n    };\n    return chord;\n  };\n  d3.layout.force = function() {\n    var force = {}, event = d3.dispatch(\"start\", \"tick\", \"end\"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\n    function repulse(node) {\n      return function(quad, x1, _, x2) {\n        if (quad.point !== node) {\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\n          if (dw * dw / theta2 < dn) {\n            if (dn < chargeDistance2) {\n              var k = quad.charge / dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n            }\n            return true;\n          }\n          if (quad.point && dn && dn < chargeDistance2) {\n            var k = quad.pointCharge / dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n          }\n        }\n        return !quad.charge;\n      };\n    }\n    force.tick = function() {\n      if ((alpha *= .99) < .005) {\n        timer = null;\n        event.end({\n          type: \"end\",\n          alpha: alpha = 0\n        });\n        return true;\n      }\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        s = o.source;\n        t = o.target;\n        x = t.x - s.x;\n        y = t.y - s.y;\n        if (l = x * x + y * y) {\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n          x *= l;\n          y *= l;\n          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\n          t.y -= y * k;\n          s.x += x * (k = 1 - k);\n          s.y += y * k;\n        }\n      }\n      if (k = alpha * gravity) {\n        x = size[0] / 2;\n        y = size[1] / 2;\n        i = -1;\n        if (k) while (++i < n) {\n          o = nodes[i];\n          o.x += (x - o.x) * k;\n          o.y += (y - o.y) * k;\n        }\n      }\n      if (charge) {\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n        i = -1;\n        while (++i < n) {\n          if (!(o = nodes[i]).fixed) {\n            q.visit(repulse(o));\n          }\n        }\n      }\n      i = -1;\n      while (++i < n) {\n        o = nodes[i];\n        if (o.fixed) {\n          o.x = o.px;\n          o.y = o.py;\n        } else {\n          o.x -= (o.px - (o.px = o.x)) * friction;\n          o.y -= (o.py - (o.py = o.y)) * friction;\n        }\n      }\n      event.tick({\n        type: \"tick\",\n        alpha: alpha\n      });\n    };\n    force.nodes = function(x) {\n      if (!arguments.length) return nodes;\n      nodes = x;\n      return force;\n    };\n    force.links = function(x) {\n      if (!arguments.length) return links;\n      links = x;\n      return force;\n    };\n    force.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return force;\n    };\n    force.linkDistance = function(x) {\n      if (!arguments.length) return linkDistance;\n      linkDistance = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.distance = force.linkDistance;\n    force.linkStrength = function(x) {\n      if (!arguments.length) return linkStrength;\n      linkStrength = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.friction = function(x) {\n      if (!arguments.length) return friction;\n      friction = +x;\n      return force;\n    };\n    force.charge = function(x) {\n      if (!arguments.length) return charge;\n      charge = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.chargeDistance = function(x) {\n      if (!arguments.length) return Math.sqrt(chargeDistance2);\n      chargeDistance2 = x * x;\n      return force;\n    };\n    force.gravity = function(x) {\n      if (!arguments.length) return gravity;\n      gravity = +x;\n      return force;\n    };\n    force.theta = function(x) {\n      if (!arguments.length) return Math.sqrt(theta2);\n      theta2 = x * x;\n      return force;\n    };\n    force.alpha = function(x) {\n      if (!arguments.length) return alpha;\n      x = +x;\n      if (alpha) {\n        if (x > 0) {\n          alpha = x;\n        } else {\n          timer.c = null, timer.t = NaN, timer = null;\n          event.end({\n            type: \"end\",\n            alpha: alpha = 0\n          });\n        }\n      } else if (x > 0) {\n        event.start({\n          type: \"start\",\n          alpha: alpha = x\n        });\n        timer = d3_timer(force.tick);\n      }\n      return force;\n    };\n    force.start = function() {\n      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\n      for (i = 0; i < n; ++i) {\n        (o = nodes[i]).index = i;\n        o.weight = 0;\n      }\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        if (typeof o.source == \"number\") o.source = nodes[o.source];\n        if (typeof o.target == \"number\") o.target = nodes[o.target];\n        ++o.source.weight;\n        ++o.target.weight;\n      }\n      for (i = 0; i < n; ++i) {\n        o = nodes[i];\n        if (isNaN(o.x)) o.x = position(\"x\", w);\n        if (isNaN(o.y)) o.y = position(\"y\", h);\n        if (isNaN(o.px)) o.px = o.x;\n        if (isNaN(o.py)) o.py = o.y;\n      }\n      distances = [];\n      if (typeof linkDistance === \"function\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\n      strengths = [];\n      if (typeof linkStrength === \"function\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\n      charges = [];\n      if (typeof charge === \"function\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\n      function position(dimension, size) {\n        if (!neighbors) {\n          neighbors = new Array(n);\n          for (j = 0; j < n; ++j) {\n            neighbors[j] = [];\n          }\n          for (j = 0; j < m; ++j) {\n            var o = links[j];\n            neighbors[o.source.index].push(o.target);\n            neighbors[o.target.index].push(o.source);\n          }\n        }\n        var candidates = neighbors[i], j = -1, l = candidates.length, x;\n        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\n        return Math.random() * size;\n      }\n      return force.resume();\n    };\n    force.resume = function() {\n      return force.alpha(.1);\n    };\n    force.stop = function() {\n      return force.alpha(0);\n    };\n    force.drag = function() {\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\", d3_layout_forceDragstart).on(\"drag.force\", dragmove).on(\"dragend.force\", d3_layout_forceDragend);\n      if (!arguments.length) return drag;\n      this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\n    };\n    function dragmove(d) {\n      d.px = d3.event.x, d.py = d3.event.y;\n      force.resume();\n    }\n    return d3.rebind(force, event, \"on\");\n  };\n  function d3_layout_forceDragstart(d) {\n    d.fixed |= 2;\n  }\n  function d3_layout_forceDragend(d) {\n    d.fixed &= ~6;\n  }\n  function d3_layout_forceMouseover(d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  }\n  function d3_layout_forceMouseout(d) {\n    d.fixed &= ~4;\n  }\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\n    var cx = 0, cy = 0;\n    quad.charge = 0;\n    if (!quad.leaf) {\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\n      while (++i < n) {\n        c = nodes[i];\n        if (c == null) continue;\n        d3_layout_forceAccumulate(c, alpha, charges);\n        quad.charge += c.charge;\n        cx += c.charge * c.cx;\n        cy += c.charge * c.cy;\n      }\n    }\n    if (quad.point) {\n      if (!quad.leaf) {\n        quad.point.x += Math.random() - .5;\n        quad.point.y += Math.random() - .5;\n      }\n      var k = alpha * charges[quad.point.index];\n      quad.charge += quad.pointCharge = k;\n      cx += k * quad.point.x;\n      cy += k * quad.point.y;\n    }\n    quad.cx = cx / quad.charge;\n    quad.cy = cy / quad.charge;\n  }\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\n  d3.layout.hierarchy = function() {\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\n    function hierarchy(root) {\n      var stack = [ root ], nodes = [], node;\n      root.depth = 0;\n      while ((node = stack.pop()) != null) {\n        nodes.push(node);\n        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n          var n, childs, child;\n          while (--n >= 0) {\n            stack.push(child = childs[n]);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n          if (value) node.value = 0;\n          node.children = childs;\n        } else {\n          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          delete node.children;\n        }\n      }\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var childs, parent;\n        if (sort && (childs = node.children)) childs.sort(sort);\n        if (value && (parent = node.parent)) parent.value += node.value;\n      });\n      return nodes;\n    }\n    hierarchy.sort = function(x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return hierarchy;\n    };\n    hierarchy.children = function(x) {\n      if (!arguments.length) return children;\n      children = x;\n      return hierarchy;\n    };\n    hierarchy.value = function(x) {\n      if (!arguments.length) return value;\n      value = x;\n      return hierarchy;\n    };\n    hierarchy.revalue = function(root) {\n      if (value) {\n        d3_layout_hierarchyVisitBefore(root, function(node) {\n          if (node.children) node.value = 0;\n        });\n        d3_layout_hierarchyVisitAfter(root, function(node) {\n          var parent;\n          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          if (parent = node.parent) parent.value += node.value;\n        });\n      }\n      return root;\n    };\n    return hierarchy;\n  };\n  function d3_layout_hierarchyRebind(object, hierarchy) {\n    d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n    object.nodes = object;\n    object.links = d3_layout_hierarchyLinks;\n    return object;\n  }\n  function d3_layout_hierarchyVisitBefore(node, callback) {\n    var nodes = [ node ];\n    while ((node = nodes.pop()) != null) {\n      callback(node);\n      if ((children = node.children) && (n = children.length)) {\n        var n, children;\n        while (--n >= 0) nodes.push(children[n]);\n      }\n    }\n  }\n  function d3_layout_hierarchyVisitAfter(node, callback) {\n    var nodes = [ node ], nodes2 = [];\n    while ((node = nodes.pop()) != null) {\n      nodes2.push(node);\n      if ((children = node.children) && (n = children.length)) {\n        var i = -1, n, children;\n        while (++i < n) nodes.push(children[i]);\n      }\n    }\n    while ((node = nodes2.pop()) != null) {\n      callback(node);\n    }\n  }\n  function d3_layout_hierarchyChildren(d) {\n    return d.children;\n  }\n  function d3_layout_hierarchyValue(d) {\n    return d.value;\n  }\n  function d3_layout_hierarchySort(a, b) {\n    return b.value - a.value;\n  }\n  function d3_layout_hierarchyLinks(nodes) {\n    return d3.merge(nodes.map(function(parent) {\n      return (parent.children || []).map(function(child) {\n        return {\n          source: parent,\n          target: child\n        };\n      });\n    }));\n  }\n  d3.layout.partition = function() {\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n      if (children && (n = children.length)) {\n        var i = -1, n, c, d;\n        dx = node.value ? dx / node.value : 0;\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n    function depth(node) {\n      var children = node.children, d = 0;\n      if (children && (n = children.length)) {\n        var i = -1, n;\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n      return 1 + d;\n    }\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n    partition.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n  d3.layout.pie = function() {\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;\n    function pie(data) {\n      var n = data.length, values = data.map(function(d, i) {\n        return +value.call(pie, d, i);\n      }), a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === \"function\" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\n        return values[j] - values[i];\n      } : function(i, j) {\n        return sort(data[i], data[j]);\n      });\n      index.forEach(function(i) {\n        arcs[i] = {\n          data: data[i],\n          value: v = values[i],\n          startAngle: a,\n          endAngle: a += v * k + pa,\n          padAngle: p\n        };\n      });\n      return arcs;\n    }\n    pie.value = function(_) {\n      if (!arguments.length) return value;\n      value = _;\n      return pie;\n    };\n    pie.sort = function(_) {\n      if (!arguments.length) return sort;\n      sort = _;\n      return pie;\n    };\n    pie.startAngle = function(_) {\n      if (!arguments.length) return startAngle;\n      startAngle = _;\n      return pie;\n    };\n    pie.endAngle = function(_) {\n      if (!arguments.length) return endAngle;\n      endAngle = _;\n      return pie;\n    };\n    pie.padAngle = function(_) {\n      if (!arguments.length) return padAngle;\n      padAngle = _;\n      return pie;\n    };\n    return pie;\n  };\n  var d3_layout_pieSortByValue = {};\n  d3.layout.stack = function() {\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\n    function stack(data, index) {\n      if (!(n = data.length)) return data;\n      var series = data.map(function(d, i) {\n        return values.call(stack, d, i);\n      });\n      var points = series.map(function(d) {\n        return d.map(function(v, i) {\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\n        });\n      });\n      var orders = order.call(stack, points, index);\n      series = d3.permute(series, orders);\n      points = d3.permute(points, orders);\n      var offsets = offset.call(stack, points, index);\n      var m = series[0].length, n, i, j, o;\n      for (j = 0; j < m; ++j) {\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n        for (i = 1; i < n; ++i) {\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n        }\n      }\n      return data;\n    }\n    stack.values = function(x) {\n      if (!arguments.length) return values;\n      values = x;\n      return stack;\n    };\n    stack.order = function(x) {\n      if (!arguments.length) return order;\n      order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n      return stack;\n    };\n    stack.offset = function(x) {\n      if (!arguments.length) return offset;\n      offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n      return stack;\n    };\n    stack.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      return stack;\n    };\n    stack.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      return stack;\n    };\n    stack.out = function(z) {\n      if (!arguments.length) return out;\n      out = z;\n      return stack;\n    };\n    return stack;\n  };\n  function d3_layout_stackX(d) {\n    return d.x;\n  }\n  function d3_layout_stackY(d) {\n    return d.y;\n  }\n  function d3_layout_stackOut(d, y0, y) {\n    d.y0 = y0;\n    d.y = y;\n  }\n  var d3_layout_stackOrders = d3.map({\n    \"inside-out\": function(data) {\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\n        return max[a] - max[b];\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\n      for (i = 0; i < n; ++i) {\n        j = index[i];\n        if (top < bottom) {\n          top += sums[j];\n          tops.push(j);\n        } else {\n          bottom += sums[j];\n          bottoms.push(j);\n        }\n      }\n      return bottoms.reverse().concat(tops);\n    },\n    reverse: function(data) {\n      return d3.range(data.length).reverse();\n    },\n    \"default\": d3_layout_stackOrderDefault\n  });\n  var d3_layout_stackOffsets = d3.map({\n    silhouette: function(data) {\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o > max) max = o;\n        sums.push(o);\n      }\n      for (j = 0; j < m; ++j) {\n        y0[j] = (max - sums[j]) / 2;\n      }\n      return y0;\n    },\n    wiggle: function(data) {\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\n      y0[0] = o = o0 = 0;\n      for (j = 1; j < m; ++j) {\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n          }\n          s2 += s3 * data[i][j][1];\n        }\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n        if (o < o0) o0 = o;\n      }\n      for (j = 0; j < m; ++j) y0[j] -= o0;\n      return y0;\n    },\n    expand: function(data) {\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\n      }\n      for (j = 0; j < m; ++j) y0[j] = 0;\n      return y0;\n    },\n    zero: d3_layout_stackOffsetZero\n  });\n  function d3_layout_stackOrderDefault(data) {\n    return d3.range(data.length);\n  }\n  function d3_layout_stackOffsetZero(data) {\n    var j = -1, m = data[0].length, y0 = [];\n    while (++j < m) y0[j] = 0;\n    return y0;\n  }\n  function d3_layout_stackMaxIndex(array) {\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\n    for (;i < n; ++i) {\n      if ((k = array[i][1]) > v) {\n        j = i;\n        v = k;\n      }\n    }\n    return j;\n  }\n  function d3_layout_stackReduceSum(d) {\n    return d.reduce(d3_layout_stackSum, 0);\n  }\n  function d3_layout_stackSum(p, d) {\n    return p + d[1];\n  }\n  d3.layout.histogram = function() {\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\n    function histogram(data, i) {\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\n      while (++i < m) {\n        bin = bins[i] = [];\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n        bin.y = 0;\n      }\n      if (m > 0) {\n        i = -1;\n        while (++i < n) {\n          x = values[i];\n          if (x >= range[0] && x <= range[1]) {\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n            bin.y += k;\n            bin.push(data[i]);\n          }\n        }\n      }\n      return bins;\n    }\n    histogram.value = function(x) {\n      if (!arguments.length) return valuer;\n      valuer = x;\n      return histogram;\n    };\n    histogram.range = function(x) {\n      if (!arguments.length) return ranger;\n      ranger = d3_functor(x);\n      return histogram;\n    };\n    histogram.bins = function(x) {\n      if (!arguments.length) return binner;\n      binner = typeof x === \"number\" ? function(range) {\n        return d3_layout_histogramBinFixed(range, x);\n      } : d3_functor(x);\n      return histogram;\n    };\n    histogram.frequency = function(x) {\n      if (!arguments.length) return frequency;\n      frequency = !!x;\n      return histogram;\n    };\n    return histogram;\n  };\n  function d3_layout_histogramBinSturges(range, values) {\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n  }\n  function d3_layout_histogramBinFixed(range, n) {\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\n    while (++x <= n) f[x] = m * x + b;\n    return f;\n  }\n  function d3_layout_histogramRange(values) {\n    return [ d3.min(values), d3.max(values) ];\n  }\n  d3.layout.pack = function() {\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;\n    function pack(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === \"function\" ? radius : function() {\n        return radius;\n      };\n      root.x = root.y = 0;\n      d3_layout_hierarchyVisitAfter(root, function(d) {\n        d.r = +r(d.value);\n      });\n      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n      if (padding) {\n        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r += dr;\n        });\n        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r -= dr;\n        });\n      }\n      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\n      return nodes;\n    }\n    pack.size = function(_) {\n      if (!arguments.length) return size;\n      size = _;\n      return pack;\n    };\n    pack.radius = function(_) {\n      if (!arguments.length) return radius;\n      radius = _ == null || typeof _ === \"function\" ? _ : +_;\n      return pack;\n    };\n    pack.padding = function(_) {\n      if (!arguments.length) return padding;\n      padding = +_;\n      return pack;\n    };\n    return d3_layout_hierarchyRebind(pack, hierarchy);\n  };\n  function d3_layout_packSort(a, b) {\n    return a.value - b.value;\n  }\n  function d3_layout_packInsert(a, b) {\n    var c = a._pack_next;\n    a._pack_next = b;\n    b._pack_prev = a;\n    b._pack_next = c;\n    c._pack_prev = b;\n  }\n  function d3_layout_packSplice(a, b) {\n    a._pack_next = b;\n    b._pack_prev = a;\n  }\n  function d3_layout_packIntersects(a, b) {\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\n    return .999 * dr * dr > dx * dx + dy * dy;\n  }\n  function d3_layout_packSiblings(node) {\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\n    function bound(node) {\n      xMin = Math.min(node.x - node.r, xMin);\n      xMax = Math.max(node.x + node.r, xMax);\n      yMin = Math.min(node.y - node.r, yMin);\n      yMax = Math.max(node.y + node.r, yMax);\n    }\n    nodes.forEach(d3_layout_packLink);\n    a = nodes[0];\n    a.x = -a.r;\n    a.y = 0;\n    bound(a);\n    if (n > 1) {\n      b = nodes[1];\n      b.x = b.r;\n      b.y = 0;\n      bound(b);\n      if (n > 2) {\n        c = nodes[2];\n        d3_layout_packPlace(a, b, c);\n        bound(c);\n        d3_layout_packInsert(a, c);\n        a._pack_prev = c;\n        d3_layout_packInsert(c, b);\n        b = a._pack_next;\n        for (i = 3; i < n; i++) {\n          d3_layout_packPlace(a, b, c = nodes[i]);\n          var isect = 0, s1 = 1, s2 = 1;\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n            if (d3_layout_packIntersects(j, c)) {\n              isect = 1;\n              break;\n            }\n          }\n          if (isect == 1) {\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n              if (d3_layout_packIntersects(k, c)) {\n                break;\n              }\n            }\n          }\n          if (isect) {\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\n            i--;\n          } else {\n            d3_layout_packInsert(a, c);\n            b = c;\n            bound(c);\n          }\n        }\n      }\n    }\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\n    for (i = 0; i < n; i++) {\n      c = nodes[i];\n      c.x -= cx;\n      c.y -= cy;\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n    }\n    node.r = cr;\n    nodes.forEach(d3_layout_packUnlink);\n  }\n  function d3_layout_packLink(node) {\n    node._pack_next = node._pack_prev = node;\n  }\n  function d3_layout_packUnlink(node) {\n    delete node._pack_next;\n    delete node._pack_prev;\n  }\n  function d3_layout_packTransform(node, x, y, k) {\n    var children = node.children;\n    node.x = x += k * node.x;\n    node.y = y += k * node.y;\n    node.r *= k;\n    if (children) {\n      var i = -1, n = children.length;\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n    }\n  }\n  function d3_layout_packPlace(a, b, c) {\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\n    if (db && (dx || dy)) {\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\n      da *= da;\n      db *= db;\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n      c.x = a.x + x * dx + y * dy;\n      c.y = a.y + x * dy - y * dx;\n    } else {\n      c.x = a.x + db;\n      c.y = a.y;\n    }\n  }\n  d3.layout.tree = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\n    function tree(d, i) {\n      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);\n      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\n      d3_layout_hierarchyVisitBefore(root1, secondWalk);\n      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {\n        var left = root0, right = root0, bottom = root0;\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n      return nodes;\n    }\n    function wrapTree(root0) {\n      var root1 = {\n        A: null,\n        children: [ root0 ]\n      }, queue = [ root1 ], node1;\n      while ((node1 = queue.pop()) != null) {\n        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\n          queue.push((children[i] = child = {\n            _: children[i],\n            parent: node1,\n            children: (child = children[i].children) && child.slice() || [],\n            A: null,\n            a: null,\n            z: 0,\n            m: 0,\n            c: 0,\n            s: 0,\n            t: null,\n            i: i\n          }).a = child);\n        }\n      }\n      return root1.children[0];\n    }\n    function firstWalk(v) {\n      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n      if (children.length) {\n        d3_layout_treeShift(v);\n        var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n        if (w) {\n          v.z = w.z + separation(v._, w._);\n          v.m = v.z - midpoint;\n        } else {\n          v.z = midpoint;\n        }\n      } else if (w) {\n        v.z = w.z + separation(v._, w._);\n      }\n      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n    }\n    function secondWalk(v) {\n      v._.x = v.z + v.parent.m;\n      v.m += v.parent.m;\n    }\n    function apportion(v, w, ancestor) {\n      if (w) {\n        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop.a = v;\n          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim.m;\n          sip += vip.m;\n          som += vom.m;\n          sop += vop.m;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop.t = vim;\n          vop.m += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom.t = vip;\n          vom.m += sip - som;\n          ancestor = v;\n        }\n      }\n      return ancestor;\n    }\n    function sizeNode(node) {\n      node.x *= size[0];\n      node.y = node.depth * size[1];\n    }\n    tree.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return tree;\n    };\n    tree.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null ? sizeNode : null;\n      return tree;\n    };\n    tree.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) == null ? null : sizeNode;\n      return tree;\n    };\n    return d3_layout_hierarchyRebind(tree, hierarchy);\n  };\n  function d3_layout_treeSeparation(a, b) {\n    return a.parent == b.parent ? 1 : 2;\n  }\n  function d3_layout_treeLeft(v) {\n    var children = v.children;\n    return children.length ? children[0] : v.t;\n  }\n  function d3_layout_treeRight(v) {\n    var children = v.children, n;\n    return (n = children.length) ? children[n - 1] : v.t;\n  }\n  function d3_layout_treeMove(wm, wp, shift) {\n    var change = shift / (wp.i - wm.i);\n    wp.c -= change;\n    wp.s += shift;\n    wm.c += change;\n    wp.z += shift;\n    wp.m += shift;\n  }\n  function d3_layout_treeShift(v) {\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\n    while (--i >= 0) {\n      w = children[i];\n      w.z += shift;\n      w.m += shift;\n      shift += w.s + (change += w.c);\n    }\n  }\n  function d3_layout_treeAncestor(vim, v, ancestor) {\n    return vim.a.parent === v.parent ? vim.a : ancestor;\n  }\n  d3.layout.cluster = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\n    function cluster(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var children = node.children;\n        if (children && children.length) {\n          node.x = d3_layout_clusterX(children);\n          node.y = d3_layout_clusterY(children);\n        } else {\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\n          node.y = 0;\n          previousNode = node;\n        }\n      });\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {\n        node.x = (node.x - root.x) * size[0];\n        node.y = (root.y - node.y) * size[1];\n      } : function(node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n      });\n      return nodes;\n    }\n    cluster.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return cluster;\n    };\n    cluster.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null;\n      return cluster;\n    };\n    cluster.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) != null;\n      return cluster;\n    };\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\n  };\n  function d3_layout_clusterY(children) {\n    return 1 + d3.max(children, function(child) {\n      return child.y;\n    });\n  }\n  function d3_layout_clusterX(children) {\n    return children.reduce(function(x, child) {\n      return x + child.x;\n    }, 0) / children.length;\n  }\n  function d3_layout_clusterLeft(node) {\n    var children = node.children;\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n  }\n  function d3_layout_clusterRight(node) {\n    var children = node.children, n;\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n  }\n  d3.layout.treemap = function() {\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \"squarify\", ratio = .5 * (1 + Math.sqrt(5));\n    function scale(children, k) {\n      var i = -1, n = children.length, child, area;\n      while (++i < n) {\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\n      }\n    }\n    function squarify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \"slice\" ? rect.dx : mode === \"dice\" ? rect.dy : mode === \"slice-dice\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while ((n = remaining.length) > 0) {\n          row.push(child = remaining[n - 1]);\n          row.area += child.area;\n          if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\n            remaining.pop();\n            best = score;\n          } else {\n            row.area -= row.pop().area;\n            position(row, u, rect, false);\n            u = Math.min(rect.dx, rect.dy);\n            row.length = row.area = 0;\n            best = Infinity;\n          }\n        }\n        if (row.length) {\n          position(row, u, rect, true);\n          row.length = row.area = 0;\n        }\n        children.forEach(squarify);\n      }\n    }\n    function stickify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), remaining = children.slice(), child, row = [];\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while (child = remaining.pop()) {\n          row.push(child);\n          row.area += child.area;\n          if (child.z != null) {\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n            row.length = row.area = 0;\n          }\n        }\n        children.forEach(stickify);\n      }\n    }\n    function worst(row, u) {\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\n      while (++i < n) {\n        if (!(r = row[i].area)) continue;\n        if (r < rmin) rmin = r;\n        if (r > rmax) rmax = r;\n      }\n      s *= s;\n      u *= u;\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n    }\n    function position(row, u, rect, flush) {\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\n      if (u == rect.dx) {\n        if (flush || v > rect.dy) v = rect.dy;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dy = v;\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n        }\n        o.z = true;\n        o.dx += rect.x + rect.dx - x;\n        rect.y += v;\n        rect.dy -= v;\n      } else {\n        if (flush || v > rect.dx) v = rect.dx;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dx = v;\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n        }\n        o.z = false;\n        o.dy += rect.y + rect.dy - y;\n        rect.x += v;\n        rect.dx -= v;\n      }\n    }\n    function treemap(d) {\n      var nodes = stickies || hierarchy(d), root = nodes[0];\n      root.x = root.y = 0;\n      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\n      if (stickies) hierarchy.revalue(root);\n      scale([ root ], root.dx * root.dy / root.value);\n      (stickies ? stickify : squarify)(root);\n      if (sticky) stickies = nodes;\n      return nodes;\n    }\n    treemap.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return treemap;\n    };\n    treemap.padding = function(x) {\n      if (!arguments.length) return padding;\n      function padFunction(node) {\n        var p = x.call(treemap, node, node.depth);\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [ p, p, p, p ] : p);\n      }\n      function padConstant(node) {\n        return d3_layout_treemapPad(node, x);\n      }\n      var type;\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [ x, x, x, x ], \n      padConstant) : padConstant;\n      return treemap;\n    };\n    treemap.round = function(x) {\n      if (!arguments.length) return round != Number;\n      round = x ? Math.round : Number;\n      return treemap;\n    };\n    treemap.sticky = function(x) {\n      if (!arguments.length) return sticky;\n      sticky = x;\n      stickies = null;\n      return treemap;\n    };\n    treemap.ratio = function(x) {\n      if (!arguments.length) return ratio;\n      ratio = x;\n      return treemap;\n    };\n    treemap.mode = function(x) {\n      if (!arguments.length) return mode;\n      mode = x + \"\";\n      return treemap;\n    };\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\n  };\n  function d3_layout_treemapPadNull(node) {\n    return {\n      x: node.x,\n      y: node.y,\n      dx: node.dx,\n      dy: node.dy\n    };\n  }\n  function d3_layout_treemapPad(node, padding) {\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\n    if (dx < 0) {\n      x += dx / 2;\n      dx = 0;\n    }\n    if (dy < 0) {\n      y += dy / 2;\n      dy = 0;\n    }\n    return {\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy\n    };\n  }\n  d3.random = {\n    normal: function(µ, σ) {\n      var n = arguments.length;\n      if (n < 2) σ = 1;\n      if (n < 1) µ = 0;\n      return function() {\n        var x, y, r;\n        do {\n          x = Math.random() * 2 - 1;\n          y = Math.random() * 2 - 1;\n          r = x * x + y * y;\n        } while (!r || r > 1);\n        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\n      };\n    },\n    logNormal: function() {\n      var random = d3.random.normal.apply(d3, arguments);\n      return function() {\n        return Math.exp(random());\n      };\n    },\n    bates: function(m) {\n      var random = d3.random.irwinHall(m);\n      return function() {\n        return random() / m;\n      };\n    },\n    irwinHall: function(m) {\n      return function() {\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\n        return s;\n      };\n    }\n  };\n  d3.scale = {};\n  function d3_scaleExtent(domain) {\n    var start = domain[0], stop = domain[domain.length - 1];\n    return start < stop ? [ start, stop ] : [ stop, start ];\n  }\n  function d3_scaleRange(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n  }\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\n    return function(x) {\n      return i(u(x));\n    };\n  }\n  function d3_scale_nice(domain, nice) {\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\n    if (x1 < x0) {\n      dx = i0, i0 = i1, i1 = dx;\n      dx = x0, x0 = x1, x1 = dx;\n    }\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n    return domain;\n  }\n  function d3_scale_niceStep(step) {\n    return step ? {\n      floor: function(x) {\n        return Math.floor(x / step) * step;\n      },\n      ceil: function(x) {\n        return Math.ceil(x / step) * step;\n      }\n    } : d3_scale_niceIdentity;\n  }\n  var d3_scale_niceIdentity = {\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\n    if (domain[k] < domain[0]) {\n      domain = domain.slice().reverse();\n      range = range.slice().reverse();\n    }\n    while (++j <= k) {\n      u.push(uninterpolate(domain[j - 1], domain[j]));\n      i.push(interpolate(range[j - 1], range[j]));\n    }\n    return function(x) {\n      var j = d3.bisect(domain, x, 1, k) - 1;\n      return i[j](u[j](x));\n    };\n  }\n  d3.scale.linear = function() {\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);\n  };\n  function d3_scale_linear(domain, range, interpolate, clamp) {\n    var output, input;\n    function rescale() {\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n      output = linear(domain, range, uninterpolate, interpolate);\n      input = linear(range, domain, uninterpolate, d3_interpolate);\n      return scale;\n    }\n    function scale(x) {\n      return output(x);\n    }\n    scale.invert = function(y) {\n      return input(y);\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(Number);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.rangeRound = function(x) {\n      return scale.range(x).interpolate(d3_interpolateRound);\n    };\n    scale.clamp = function(x) {\n      if (!arguments.length) return clamp;\n      clamp = x;\n      return rescale();\n    };\n    scale.interpolate = function(x) {\n      if (!arguments.length) return interpolate;\n      interpolate = x;\n      return rescale();\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      d3_scale_linearNice(domain, m);\n      return rescale();\n    };\n    scale.copy = function() {\n      return d3_scale_linear(domain, range, interpolate, clamp);\n    };\n    return rescale();\n  }\n  function d3_scale_linearRebind(scale, linear) {\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n  }\n  function d3_scale_linearNice(domain, m) {\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    return domain;\n  }\n  function d3_scale_linearTickRange(domain, m) {\n    if (m == null) m = 10;\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\n    extent[0] = Math.ceil(extent[0] / step) * step;\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n    extent[2] = step;\n    return extent;\n  }\n  function d3_scale_linearTicks(domain, m) {\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n  }\n  function d3_scale_linearTickFormat(domain, m, format) {\n    var range = d3_scale_linearTickRange(domain, m);\n    if (format) {\n      var match = d3_format_re.exec(format);\n      match.shift();\n      if (match[8] === \"s\") {\n        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\n        if (!match[7]) match[7] = \".\" + d3_scale_linearPrecision(prefix.scale(range[2]));\n        match[8] = \"f\";\n        format = d3.format(match.join(\"\"));\n        return function(d) {\n          return format(prefix.scale(d)) + prefix.symbol;\n        };\n      }\n      if (!match[7]) match[7] = \".\" + d3_scale_linearFormatPrecision(match[8], range);\n      format = match.join(\"\");\n    } else {\n      format = \",.\" + d3_scale_linearPrecision(range[2]) + \"f\";\n    }\n    return d3.format(format);\n  }\n  var d3_scale_linearFormatSignificant = {\n    s: 1,\n    g: 1,\n    p: 1,\n    r: 1,\n    e: 1\n  };\n  function d3_scale_linearPrecision(value) {\n    return -Math.floor(Math.log(value) / Math.LN10 + .01);\n  }\n  function d3_scale_linearFormatPrecision(type, range) {\n    var p = d3_scale_linearPrecision(range[2]);\n    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== \"e\") : p - (type === \"%\") * 2;\n  }\n  d3.scale.log = function() {\n    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);\n  };\n  function d3_scale_log(linear, base, positive, domain) {\n    function log(x) {\n      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\n    }\n    function pow(x) {\n      return positive ? Math.pow(base, x) : -Math.pow(base, -x);\n    }\n    function scale(x) {\n      return linear(log(x));\n    }\n    scale.invert = function(x) {\n      return pow(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      positive = x[0] >= 0;\n      linear.domain((domain = x.map(Number)).map(log));\n      return scale;\n    };\n    scale.base = function(_) {\n      if (!arguments.length) return base;\n      base = +_;\n      linear.domain(domain.map(log));\n      return scale;\n    };\n    scale.nice = function() {\n      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\n      linear.domain(niced);\n      domain = niced.map(pow);\n      return scale;\n    };\n    scale.ticks = function() {\n      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;\n      if (isFinite(j - i)) {\n        if (positive) {\n          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\n          ticks.push(pow(i));\n        } else {\n          ticks.push(pow(i));\n          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\n        }\n        for (i = 0; ticks[i] < u; i++) {}\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\n        ticks = ticks.slice(i, j);\n      }\n      return ticks;\n    };\n    scale.tickFormat = function(n, format) {\n      if (!arguments.length) return d3_scale_logFormat;\n      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== \"function\") format = d3.format(format);\n      var k = Math.max(1, base * n / scale.ticks().length);\n      return function(d) {\n        var i = d / pow(Math.round(log(d)));\n        if (i * base < base - .5) i *= base;\n        return i <= k ? format(d) : \"\";\n      };\n    };\n    scale.copy = function() {\n      return d3_scale_log(linear.copy(), base, positive, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  var d3_scale_logFormat = d3.format(\".0e\"), d3_scale_logNiceNegative = {\n    floor: function(x) {\n      return -Math.ceil(-x);\n    },\n    ceil: function(x) {\n      return -Math.floor(-x);\n    }\n  };\n  d3.scale.pow = function() {\n    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);\n  };\n  function d3_scale_pow(linear, exponent, domain) {\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\n    function scale(x) {\n      return linear(powp(x));\n    }\n    scale.invert = function(x) {\n      return powb(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      linear.domain((domain = x.map(Number)).map(powp));\n      return scale;\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      return scale.domain(d3_scale_linearNice(domain, m));\n    };\n    scale.exponent = function(x) {\n      if (!arguments.length) return exponent;\n      powp = d3_scale_powPow(exponent = x);\n      powb = d3_scale_powPow(1 / exponent);\n      linear.domain(domain.map(powp));\n      return scale;\n    };\n    scale.copy = function() {\n      return d3_scale_pow(linear.copy(), exponent, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_scale_powPow(e) {\n    return function(x) {\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n    };\n  }\n  d3.scale.sqrt = function() {\n    return d3.scale.pow().exponent(.5);\n  };\n  d3.scale.ordinal = function() {\n    return d3_scale_ordinal([], {\n      t: \"range\",\n      a: [ [] ]\n    });\n  };\n  function d3_scale_ordinal(domain, ranger) {\n    var index, range, rangeBand;\n    function scale(x) {\n      return range[((index.get(x) || (ranger.t === \"range\" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\n    }\n    function steps(start, step) {\n      return d3.range(domain.length).map(function(i) {\n        return start + step * i;\n      });\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = [];\n      index = new d3_Map();\n      var i = -1, n = x.length, xi;\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n      return scale[ranger.t].apply(scale, ranger.a);\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      rangeBand = 0;\n      ranger = {\n        t: \"range\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangePoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, \n      0) : (stop - start) / (domain.length - 1 + padding);\n      range = steps(start + step * padding / 2, step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangePoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundPoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), \n      0) : (stop - start) / (domain.length - 1 + padding) | 0;\n      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangeRoundPoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n      range = steps(start + step * outerPadding, step);\n      if (reverse) range.reverse();\n      rangeBand = step * (1 - padding);\n      ranger = {\n        t: \"rangeBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\n      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\n      if (reverse) range.reverse();\n      rangeBand = Math.round(step * (1 - padding));\n      ranger = {\n        t: \"rangeRoundBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBand = function() {\n      return rangeBand;\n    };\n    scale.rangeExtent = function() {\n      return d3_scaleExtent(ranger.a[0]);\n    };\n    scale.copy = function() {\n      return d3_scale_ordinal(domain, ranger);\n    };\n    return scale.domain(domain);\n  }\n  d3.scale.category10 = function() {\n    return d3.scale.ordinal().range(d3_category10);\n  };\n  d3.scale.category20 = function() {\n    return d3.scale.ordinal().range(d3_category20);\n  };\n  d3.scale.category20b = function() {\n    return d3.scale.ordinal().range(d3_category20b);\n  };\n  d3.scale.category20c = function() {\n    return d3.scale.ordinal().range(d3_category20c);\n  };\n  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);\n  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);\n  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);\n  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);\n  d3.scale.quantile = function() {\n    return d3_scale_quantile([], []);\n  };\n  function d3_scale_quantile(domain, range) {\n    var thresholds;\n    function rescale() {\n      var k = 0, q = range.length;\n      thresholds = [];\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n      return scale;\n    }\n    function scale(x) {\n      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.quantiles = function() {\n      return thresholds;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantile(domain, range);\n    };\n    return rescale();\n  }\n  d3.scale.quantize = function() {\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\n  };\n  function d3_scale_quantize(x0, x1, range) {\n    var kx, i;\n    function scale(x) {\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n    }\n    function rescale() {\n      kx = range.length / (x1 - x0);\n      i = range.length - 1;\n      return scale;\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return [ x0, x1 ];\n      x0 = +x[0];\n      x1 = +x[x.length - 1];\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      y = y < 0 ? NaN : y / kx + x0;\n      return [ y, y + 1 / kx ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantize(x0, x1, range);\n    };\n    return rescale();\n  }\n  d3.scale.threshold = function() {\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\n  };\n  function d3_scale_threshold(domain, range) {\n    function scale(x) {\n      if (x <= x) return range[d3.bisect(domain, x)];\n    }\n    scale.domain = function(_) {\n      if (!arguments.length) return domain;\n      domain = _;\n      return scale;\n    };\n    scale.range = function(_) {\n      if (!arguments.length) return range;\n      range = _;\n      return scale;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return [ domain[y - 1], domain[y] ];\n    };\n    scale.copy = function() {\n      return d3_scale_threshold(domain, range);\n    };\n    return scale;\n  }\n  d3.scale.identity = function() {\n    return d3_scale_identity([ 0, 1 ]);\n  };\n  function d3_scale_identity(domain) {\n    function identity(x) {\n      return +x;\n    }\n    identity.invert = identity;\n    identity.domain = identity.range = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(identity);\n      return identity;\n    };\n    identity.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    identity.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    identity.copy = function() {\n      return d3_scale_identity(domain);\n    };\n    return identity;\n  }\n  d3.svg = {};\n  function d3_zero() {\n    return 0;\n  }\n  d3.svg.arc = function() {\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\n    function arc() {\n      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;\n      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\n      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : \"\") + \"Z\";\n      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\n      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\n        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\n        if (!cw) p1 *= -1;\n        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\n        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\n      }\n      if (r1) {\n        x0 = r1 * Math.cos(a0 + p1);\n        y0 = r1 * Math.sin(a0 + p1);\n        x1 = r1 * Math.cos(a1 - p1);\n        y1 = r1 * Math.sin(a1 - p1);\n        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;\n        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\n          var h1 = (a0 + a1) / 2;\n          x0 = r1 * Math.cos(h1);\n          y0 = r1 * Math.sin(h1);\n          x1 = y1 = null;\n        }\n      } else {\n        x0 = y0 = 0;\n      }\n      if (r0) {\n        x2 = r0 * Math.cos(a1 - p0);\n        y2 = r0 * Math.sin(a1 - p0);\n        x3 = r0 * Math.cos(a0 + p0);\n        y3 = r0 * Math.sin(a0 + p0);\n        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;\n        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\n          var h0 = (a0 + a1) / 2;\n          x2 = r0 * Math.cos(h0);\n          y2 = r0 * Math.sin(h0);\n          x3 = y3 = null;\n        }\n      } else {\n        x2 = y2 = 0;\n      }\n      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\n        cr = r0 < r1 ^ cw ? 0 : 1;\n        var rc1 = rc, rc0 = rc;\n        if (da < π) {\n          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n        }\n        if (x1 != null) {\n          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);\n          if (rc === rc1) {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t30[1], \"A\", r1, \",\", r1, \" 0 \", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), \",\", cw, \" \", t12[1], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t12[0]);\n          } else {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 1,\", cr, \" \", t12[0]);\n          }\n        } else {\n          path.push(\"M\", x0, \",\", y0);\n        }\n        if (x3 != null) {\n          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);\n          if (rc === rc0) {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t21[1], \"A\", r0, \",\", r0, \" 0 \", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), \",\", 1 - cw, \" \", t03[1], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          } else {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          }\n        } else {\n          path.push(\"L\", x2, \",\", y2);\n        }\n      } else {\n        path.push(\"M\", x0, \",\", y0);\n        if (x1 != null) path.push(\"A\", r1, \",\", r1, \" 0 \", l1, \",\", cw, \" \", x1, \",\", y1);\n        path.push(\"L\", x2, \",\", y2);\n        if (x3 != null) path.push(\"A\", r0, \",\", r0, \" 0 \", l0, \",\", 1 - cw, \" \", x3, \",\", y3);\n      }\n      path.push(\"Z\");\n      return path.join(\"\");\n    }\n    function circleSegment(r1, cw) {\n      return \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + r1;\n    }\n    arc.innerRadius = function(v) {\n      if (!arguments.length) return innerRadius;\n      innerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.outerRadius = function(v) {\n      if (!arguments.length) return outerRadius;\n      outerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.cornerRadius = function(v) {\n      if (!arguments.length) return cornerRadius;\n      cornerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.padRadius = function(v) {\n      if (!arguments.length) return padRadius;\n      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\n      return arc;\n    };\n    arc.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return arc;\n    };\n    arc.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return arc;\n    };\n    arc.padAngle = function(v) {\n      if (!arguments.length) return padAngle;\n      padAngle = d3_functor(v);\n      return arc;\n    };\n    arc.centroid = function() {\n      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\n    };\n    return arc;\n  };\n  var d3_svg_arcAuto = \"auto\";\n  function d3_svg_arcInnerRadius(d) {\n    return d.innerRadius;\n  }\n  function d3_svg_arcOuterRadius(d) {\n    return d.outerRadius;\n  }\n  function d3_svg_arcStartAngle(d) {\n    return d.startAngle;\n  }\n  function d3_svg_arcEndAngle(d) {\n    return d.endAngle;\n  }\n  function d3_svg_arcPadAngle(d) {\n    return d && d.padAngle;\n  }\n  function d3_svg_arcSweep(x0, y0, x1, y1) {\n    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\n  }\n  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\n    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\n    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\n  }\n  function d3_svg_line(projection) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\n    function line(data) {\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points), tension));\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\n        } else if (points.length) {\n          segment();\n          points = [];\n        }\n      }\n      if (points.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    line.x = function(_) {\n      if (!arguments.length) return x;\n      x = _;\n      return line;\n    };\n    line.y = function(_) {\n      if (!arguments.length) return y;\n      y = _;\n      return line;\n    };\n    line.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return line;\n    };\n    line.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      return line;\n    };\n    line.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return line;\n    };\n    return line;\n  }\n  d3.svg.line = function() {\n    return d3_svg_line(d3_identity);\n  };\n  var d3_svg_lineInterpolators = d3.map({\n    linear: d3_svg_lineLinear,\n    \"linear-closed\": d3_svg_lineLinearClosed,\n    step: d3_svg_lineStep,\n    \"step-before\": d3_svg_lineStepBefore,\n    \"step-after\": d3_svg_lineStepAfter,\n    basis: d3_svg_lineBasis,\n    \"basis-open\": d3_svg_lineBasisOpen,\n    \"basis-closed\": d3_svg_lineBasisClosed,\n    bundle: d3_svg_lineBundle,\n    cardinal: d3_svg_lineCardinal,\n    \"cardinal-open\": d3_svg_lineCardinalOpen,\n    \"cardinal-closed\": d3_svg_lineCardinalClosed,\n    monotone: d3_svg_lineMonotone\n  });\n  d3_svg_lineInterpolators.forEach(function(key, value) {\n    value.key = key;\n    value.closed = /-closed$/.test(key);\n  });\n  function d3_svg_lineLinear(points) {\n    return points.length > 1 ? points.join(\"L\") : points + \"Z\";\n  }\n  function d3_svg_lineLinearClosed(points) {\n    return points.join(\"L\") + \"Z\";\n  }\n  function d3_svg_lineStep(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p[0] + (p = points[i])[0]) / 2, \"V\", p[1]);\n    if (n > 1) path.push(\"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepBefore(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepAfter(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineCardinalOpen(points, tension) {\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineCardinalClosed(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\n  }\n  function d3_svg_lineCardinal(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineHermite(points, tangents) {\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n      return d3_svg_lineLinear(points);\n    }\n    var quad = points.length != tangents.length, path = \"\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\n    if (quad) {\n      path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\n      p0 = points[1];\n      pi = 2;\n    }\n    if (tangents.length > 1) {\n      t = tangents[1];\n      p = points[pi];\n      pi++;\n      path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      for (var i = 2; i < tangents.length; i++, pi++) {\n        p = points[pi];\n        t = tangents[i];\n        path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      }\n    }\n    if (quad) {\n      var lp = points[pi];\n      path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\n    }\n    return path;\n  }\n  function d3_svg_lineCardinalTangents(points, tension) {\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\n    while (++i < n) {\n      p0 = p1;\n      p1 = p2;\n      p2 = points[i];\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineBasis(points) {\n    if (points.length < 3) return d3_svg_lineLinear(points);\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \",\", y0, \"L\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    points.push(points[n - 1]);\n    while (++i <= n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    points.pop();\n    path.push(\"L\", pi);\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisOpen(points) {\n    if (points.length < 4) return d3_svg_lineLinear(points);\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\n    while (++i < 3) {\n      pi = points[i];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n    --i;\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisClosed(points) {\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\n    while (++i < 4) {\n      pi = points[i % n];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    --i;\n    while (++i < m) {\n      pi = points[i % n];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBundle(points, tension) {\n    var n = points.length - 1;\n    if (n) {\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\n      while (++i <= n) {\n        p = points[i];\n        t = i / n;\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n      }\n    }\n    return d3_svg_lineBasis(points);\n  }\n  function d3_svg_lineDot4(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n  }\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\n  function d3_svg_lineBasisBezier(path, x, y) {\n    path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n  }\n  function d3_svg_lineSlope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n  function d3_svg_lineFiniteDifferences(points) {\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\n    while (++i < j) {\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n    }\n    m[i] = d;\n    return m;\n  }\n  function d3_svg_lineMonotoneTangents(points) {\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\n    while (++i < j) {\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\n      if (abs(d) < ε) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n    i = -1;\n    while (++i <= j) {\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n      tangents.push([ s || 0, m[i] * s || 0 ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineMonotone(points) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n  }\n  d3.svg.line.radial = function() {\n    var line = d3_svg_line(d3_svg_lineRadial);\n    line.radius = line.x, delete line.x;\n    line.angle = line.y, delete line.y;\n    return line;\n  };\n  function d3_svg_lineRadial(points) {\n    var point, i = -1, n = points.length, r, a;\n    while (++i < n) {\n      point = points[i];\n      r = point[0];\n      a = point[1] - halfπ;\n      point[0] = r * Math.cos(a);\n      point[1] = r * Math.sin(a);\n    }\n    return points;\n  }\n  function d3_svg_area(projection) {\n    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \"L\", tension = .7;\n    function area(data) {\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\n        return x;\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\n        return y;\n      } : d3_functor(y1), x, y;\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\n        } else if (points0.length) {\n          segment();\n          points0 = [];\n          points1 = [];\n        }\n      }\n      if (points0.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    area.x = function(_) {\n      if (!arguments.length) return x1;\n      x0 = x1 = _;\n      return area;\n    };\n    area.x0 = function(_) {\n      if (!arguments.length) return x0;\n      x0 = _;\n      return area;\n    };\n    area.x1 = function(_) {\n      if (!arguments.length) return x1;\n      x1 = _;\n      return area;\n    };\n    area.y = function(_) {\n      if (!arguments.length) return y1;\n      y0 = y1 = _;\n      return area;\n    };\n    area.y0 = function(_) {\n      if (!arguments.length) return y0;\n      y0 = _;\n      return area;\n    };\n    area.y1 = function(_) {\n      if (!arguments.length) return y1;\n      y1 = _;\n      return area;\n    };\n    area.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return area;\n    };\n    area.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      interpolateReverse = interpolate.reverse || interpolate;\n      L = interpolate.closed ? \"M\" : \"L\";\n      return area;\n    };\n    area.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return area;\n    };\n    return area;\n  }\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n  d3.svg.area = function() {\n    return d3_svg_area(d3_identity);\n  };\n  d3.svg.area.radial = function() {\n    var area = d3_svg_area(d3_svg_lineRadial);\n    area.radius = area.x, delete area.x;\n    area.innerRadius = area.x0, delete area.x0;\n    area.outerRadius = area.x1, delete area.x1;\n    area.angle = area.y, delete area.y;\n    area.startAngle = area.y0, delete area.y0;\n    area.endAngle = area.y1, delete area.y1;\n    return area;\n  };\n  d3.svg.chord = function() {\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\n    function chord(d, i) {\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\n      return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\n    }\n    function subgroup(self, f, d, i) {\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;\n      return {\n        r: r,\n        a0: a0,\n        a1: a1,\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\n      };\n    }\n    function equals(a, b) {\n      return a.a0 == b.a0 && a.a1 == b.a1;\n    }\n    function arc(r, p, a) {\n      return \"A\" + r + \",\" + r + \" 0 \" + +(a > π) + \",1 \" + p;\n    }\n    function curve(r0, p0, r1, p1) {\n      return \"Q 0,0 \" + p1;\n    }\n    chord.radius = function(v) {\n      if (!arguments.length) return radius;\n      radius = d3_functor(v);\n      return chord;\n    };\n    chord.source = function(v) {\n      if (!arguments.length) return source;\n      source = d3_functor(v);\n      return chord;\n    };\n    chord.target = function(v) {\n      if (!arguments.length) return target;\n      target = d3_functor(v);\n      return chord;\n    };\n    chord.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return chord;\n    };\n    chord.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return chord;\n    };\n    return chord;\n  };\n  function d3_svg_chordRadius(d) {\n    return d.radius;\n  }\n  d3.svg.diagonal = function() {\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\n    function diagonal(d, i) {\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\n        x: p0.x,\n        y: m\n      }, {\n        x: p3.x,\n        y: m\n      }, p3 ];\n      p = p.map(projection);\n      return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n    }\n    diagonal.source = function(x) {\n      if (!arguments.length) return source;\n      source = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.target = function(x) {\n      if (!arguments.length) return target;\n      target = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.projection = function(x) {\n      if (!arguments.length) return projection;\n      projection = x;\n      return diagonal;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalProjection(d) {\n    return [ d.x, d.y ];\n  }\n  d3.svg.diagonal.radial = function() {\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\n    diagonal.projection = function(x) {\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalRadialProjection(projection) {\n    return function() {\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;\n      return [ r * Math.cos(a), r * Math.sin(a) ];\n    };\n  }\n  d3.svg.symbol = function() {\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\n    function symbol(d, i) {\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n    }\n    symbol.type = function(x) {\n      if (!arguments.length) return type;\n      type = d3_functor(x);\n      return symbol;\n    };\n    symbol.size = function(x) {\n      if (!arguments.length) return size;\n      size = d3_functor(x);\n      return symbol;\n    };\n    return symbol;\n  };\n  function d3_svg_symbolSize() {\n    return 64;\n  }\n  function d3_svg_symbolType() {\n    return \"circle\";\n  }\n  function d3_svg_symbolCircle(size) {\n    var r = Math.sqrt(size / π);\n    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n  }\n  var d3_svg_symbols = d3.map({\n    circle: d3_svg_symbolCircle,\n    cross: function(size) {\n      var r = Math.sqrt(size / 5) / 2;\n      return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n    },\n    diamond: function(size) {\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\n      return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\n    },\n    square: function(size) {\n      var r = Math.sqrt(size) / 2;\n      return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\n    },\n    \"triangle-down\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n    },\n    \"triangle-up\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n    }\n  });\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n  d3_selectionPrototype.transition = function(name) {\n    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\n      time: Date.now(),\n      ease: d3_ease_cubicInOut,\n      delay: 0,\n      duration: 250\n    };\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_selectionPrototype.interrupt = function(name) {\n    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\n  };\n  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\n  function d3_selection_interruptNS(ns) {\n    return function() {\n      var lock, activeId, active;\n      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        if (--lock.count) delete lock[activeId]; else delete this[ns];\n        lock.active += .5;\n        active.event && active.event.interrupt.call(this, this.__data__, active.index);\n      }\n    };\n  }\n  function d3_transition(groups, ns, id) {\n    d3_subclass(groups, d3_transitionPrototype);\n    groups.namespace = ns;\n    groups.id = id;\n    return groups;\n  }\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\n  d3.transition = function(selection, name) {\n    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\n  };\n  d3.transition.prototype = d3_transitionPrototype;\n  d3_transitionPrototype.select = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, ns, id, node[ns][id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.selectAll = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          transition = node[ns][id];\n          subnodes = selector.call(node, node.__data__, i, j);\n          subgroups.push(subgroup = []);\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_transition(subgroups, this.namespace, this.id);\n  };\n  d3_transitionPrototype.tween = function(name, tween) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function(node) {\n      node[ns][id].tween.remove(name);\n    } : function(node) {\n      node[ns][id].tween.set(name, tween);\n    });\n  };\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id, ns = groups.namespace;\n    return d3_selection_each(groups, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function(node) {\n      node[ns][id].tween.set(name, value);\n    }));\n  }\n  d3_transitionPrototype.attr = function(nameNS, value) {\n    if (arguments.length < 2) {\n      for (value in nameNS) this.attr(value, nameNS[value]);\n      return this;\n    }\n    var interpolate = nameNS == \"transform\" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrTween(b) {\n      return b == null ? attrNull : (b += \"\", function() {\n        var a = this.getAttribute(name), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttribute(name, i(t));\n        });\n      });\n    }\n    function attrTweenNS(b) {\n      return b == null ? attrNullNS : (b += \"\", function() {\n        var a = this.getAttributeNS(name.space, name.local), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      });\n    }\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function(t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function(t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.style(priority, name[priority], value);\n        return this;\n      }\n      priority = \"\";\n    }\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleString(b) {\n      return b == null ? styleNull : (b += \"\", function() {\n        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;\n        return a !== b && (i = d3_interpolate(a, b), function(t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      });\n    }\n    return d3_transition_tween(this, \"style.\" + name, value, styleString);\n  };\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\n    if (arguments.length < 3) priority = \"\";\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\n      return f && function(t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n    return this.tween(\"style.\" + name, styleTween);\n  };\n  d3_transitionPrototype.text = function(value) {\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\n  };\n  function d3_transition_text(b) {\n    if (b == null) b = \"\";\n    return function() {\n      this.textContent = b;\n    };\n  }\n  d3_transitionPrototype.remove = function() {\n    var ns = this.namespace;\n    return this.each(\"end.transition\", function() {\n      var p;\n      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n  d3_transitionPrototype.ease = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].ease;\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function(node) {\n      node[ns][id].ease = value;\n    });\n  };\n  d3_transitionPrototype.delay = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].delay;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].delay = +value.call(node, node.__data__, i, j);\n    } : (value = +value, function(node) {\n      node[ns][id].delay = value;\n    }));\n  };\n  d3_transitionPrototype.duration = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].duration;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n    } : (value = Math.max(1, value), function(node) {\n      node[ns][id].duration = value;\n    }));\n  };\n  d3_transitionPrototype.each = function(type, listener) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\n      try {\n        d3_transitionInheritId = id;\n        d3_selection_each(this, function(node, i, j) {\n          d3_transitionInherit = node[ns][id];\n          type.call(node, node.__data__, i, j);\n        });\n      } finally {\n        d3_transitionInherit = inherit;\n        d3_transitionInheritId = inheritId;\n      }\n    } else {\n      d3_selection_each(this, function(node) {\n        var transition = node[ns][id];\n        (transition.event || (transition.event = d3.dispatch(\"start\", \"end\", \"interrupt\"))).on(type, listener);\n      });\n    }\n    return this;\n  };\n  d3_transitionPrototype.transition = function() {\n    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = node[ns][id0];\n          d3_transitionNode(node, i, ns, id1, {\n            time: transition.time,\n            ease: transition.ease,\n            delay: transition.delay + transition.duration,\n            duration: transition.duration\n          });\n        }\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id1);\n  };\n  function d3_transitionNamespace(name) {\n    return name == null ? \"__transition__\" : \"__transition_\" + name + \"__\";\n  }\n  function d3_transitionNode(node, i, ns, id, inherit) {\n    var lock = node[ns] || (node[ns] = {\n      active: 0,\n      count: 0\n    }), transition = lock[id], time, timer, duration, ease, tweens;\n    function schedule(elapsed) {\n      var delay = transition.delay;\n      timer.t = delay + time;\n      if (delay <= elapsed) return start(elapsed - delay);\n      timer.c = start;\n    }\n    function start(elapsed) {\n      var activeId = lock.active, active = lock[activeId];\n      if (active) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        --lock.count;\n        delete lock[activeId];\n        active.event && active.event.interrupt.call(node, node.__data__, active.index);\n      }\n      for (var cancelId in lock) {\n        if (+cancelId < id) {\n          var cancel = lock[cancelId];\n          cancel.timer.c = null;\n          cancel.timer.t = NaN;\n          --lock.count;\n          delete lock[cancelId];\n        }\n      }\n      timer.c = tick;\n      d3_timer(function() {\n        if (timer.c && tick(elapsed || 1)) {\n          timer.c = null;\n          timer.t = NaN;\n        }\n        return 1;\n      }, 0, time);\n      lock.active = id;\n      transition.event && transition.event.start.call(node, node.__data__, i);\n      tweens = [];\n      transition.tween.forEach(function(key, value) {\n        if (value = value.call(node, node.__data__, i)) {\n          tweens.push(value);\n        }\n      });\n      ease = transition.ease;\n      duration = transition.duration;\n    }\n    function tick(elapsed) {\n      var t = elapsed / duration, e = ease(t), n = tweens.length;\n      while (n > 0) {\n        tweens[--n].call(node, e);\n      }\n      if (t >= 1) {\n        transition.event && transition.event.end.call(node, node.__data__, i);\n        if (--lock.count) delete lock[id]; else delete node[ns];\n        return 1;\n      }\n    }\n    if (!transition) {\n      time = inherit.time;\n      timer = d3_timer(schedule, 0, time);\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        time: time,\n        timer: timer,\n        delay: inherit.delay,\n        duration: inherit.duration,\n        ease: inherit.ease,\n        index: i\n      };\n      inherit = null;\n      ++lock.count;\n    }\n  }\n  d3.svg.axis = function() {\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\n    function axis(g) {\n      g.each(function() {\n        var g = d3.select(this);\n        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\n        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(\".tick\").data(ticks, scale1), tickEnter = tick.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", ε), tickExit = d3.transition(tick.exit()).style(\"opacity\", ε).remove(), tickUpdate = d3.transition(tick.order()).style(\"opacity\", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;\n        var range = d3_scaleRange(scale1), path = g.selectAll(\".domain\").data([ 0 ]), pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), \n        d3.transition(path));\n        tickEnter.append(\"line\");\n        tickEnter.append(\"text\");\n        var lineEnter = tickEnter.select(\"line\"), lineUpdate = tickUpdate.select(\"line\"), text = tick.select(\"text\").text(tickFormat), textEnter = tickEnter.select(\"text\"), textUpdate = tickUpdate.select(\"text\"), sign = orient === \"top\" || orient === \"left\" ? -1 : 1, x1, x2, y1, y2;\n        if (orient === \"bottom\" || orient === \"top\") {\n          tickTransform = d3_svg_axisX, x1 = \"x\", y1 = \"y\", x2 = \"x2\", y2 = \"y2\";\n          text.attr(\"dy\", sign < 0 ? \"0em\" : \".71em\").style(\"text-anchor\", \"middle\");\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + sign * outerTickSize + \"V0H\" + range[1] + \"V\" + sign * outerTickSize);\n        } else {\n          tickTransform = d3_svg_axisY, x1 = \"y\", y1 = \"x\", x2 = \"y2\", y2 = \"x2\";\n          text.attr(\"dy\", \".32em\").style(\"text-anchor\", sign < 0 ? \"end\" : \"start\");\n          pathUpdate.attr(\"d\", \"M\" + sign * outerTickSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + sign * outerTickSize);\n        }\n        lineEnter.attr(y2, sign * innerTickSize);\n        textEnter.attr(y1, sign * tickSpacing);\n        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\n        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\n        if (scale1.rangeBand) {\n          var x = scale1, dx = x.rangeBand() / 2;\n          scale0 = scale1 = function(d) {\n            return x(d) + dx;\n          };\n        } else if (scale0.rangeBand) {\n          scale0 = scale1;\n        } else {\n          tickExit.call(tickTransform, scale1, scale0);\n        }\n        tickEnter.call(tickTransform, scale0, scale1);\n        tickUpdate.call(tickTransform, scale1, scale1);\n      });\n    }\n    axis.scale = function(x) {\n      if (!arguments.length) return scale;\n      scale = x;\n      return axis;\n    };\n    axis.orient = function(x) {\n      if (!arguments.length) return orient;\n      orient = x in d3_svg_axisOrients ? x + \"\" : d3_svg_axisDefaultOrient;\n      return axis;\n    };\n    axis.ticks = function() {\n      if (!arguments.length) return tickArguments_;\n      tickArguments_ = d3_array(arguments);\n      return axis;\n    };\n    axis.tickValues = function(x) {\n      if (!arguments.length) return tickValues;\n      tickValues = x;\n      return axis;\n    };\n    axis.tickFormat = function(x) {\n      if (!arguments.length) return tickFormat_;\n      tickFormat_ = x;\n      return axis;\n    };\n    axis.tickSize = function(x) {\n      var n = arguments.length;\n      if (!n) return innerTickSize;\n      innerTickSize = +x;\n      outerTickSize = +arguments[n - 1];\n      return axis;\n    };\n    axis.innerTickSize = function(x) {\n      if (!arguments.length) return innerTickSize;\n      innerTickSize = +x;\n      return axis;\n    };\n    axis.outerTickSize = function(x) {\n      if (!arguments.length) return outerTickSize;\n      outerTickSize = +x;\n      return axis;\n    };\n    axis.tickPadding = function(x) {\n      if (!arguments.length) return tickPadding;\n      tickPadding = +x;\n      return axis;\n    };\n    axis.tickSubdivide = function() {\n      return arguments.length && axis;\n    };\n    return axis;\n  };\n  var d3_svg_axisDefaultOrient = \"bottom\", d3_svg_axisOrients = {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  };\n  function d3_svg_axisX(selection, x0, x1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = x0(d);\n      return \"translate(\" + (isFinite(v0) ? v0 : x1(d)) + \",0)\";\n    });\n  }\n  function d3_svg_axisY(selection, y0, y1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = y0(d);\n      return \"translate(0,\" + (isFinite(v0) ? v0 : y1(d)) + \")\";\n    });\n  }\n  d3.svg.brush = function() {\n    var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\n    function brush(g) {\n      g.each(function() {\n        var g = d3.select(this).style(\"pointer-events\", \"all\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\n        var background = g.selectAll(\".background\").data([ 0 ]);\n        background.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\n        g.selectAll(\".extent\").data([ 0 ]).enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\n        var resize = g.selectAll(\".resize\").data(resizes, d3_identity);\n        resize.exit().remove();\n        resize.enter().append(\"g\").attr(\"class\", function(d) {\n          return \"resize \" + d;\n        }).style(\"cursor\", function(d) {\n          return d3_svg_brushCursor[d];\n        }).append(\"rect\").attr(\"x\", function(d) {\n          return /[ew]$/.test(d) ? -3 : null;\n        }).attr(\"y\", function(d) {\n          return /^[ns]/.test(d) ? -3 : null;\n        }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\n        resize.style(\"display\", brush.empty() ? \"none\" : null);\n        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;\n        if (x) {\n          range = d3_scaleRange(x);\n          backgroundUpdate.attr(\"x\", range[0]).attr(\"width\", range[1] - range[0]);\n          redrawX(gUpdate);\n        }\n        if (y) {\n          range = d3_scaleRange(y);\n          backgroundUpdate.attr(\"y\", range[0]).attr(\"height\", range[1] - range[0]);\n          redrawY(gUpdate);\n        }\n        redraw(gUpdate);\n      });\n    }\n    brush.event = function(g) {\n      g.each(function() {\n        var event_ = event.of(this, arguments), extent1 = {\n          x: xExtent,\n          y: yExtent,\n          i: xExtentDomain,\n          j: yExtentDomain\n        }, extent0 = this.__chart__ || extent1;\n        this.__chart__ = extent1;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.brush\", function() {\n            xExtentDomain = extent0.i;\n            yExtentDomain = extent0.j;\n            xExtent = extent0.x;\n            yExtent = extent0.y;\n            event_({\n              type: \"brushstart\"\n            });\n          }).tween(\"brush:brush\", function() {\n            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);\n            xExtentDomain = yExtentDomain = null;\n            return function(t) {\n              xExtent = extent1.x = xi(t);\n              yExtent = extent1.y = yi(t);\n              event_({\n                type: \"brush\",\n                mode: \"resize\"\n              });\n            };\n          }).each(\"end.brush\", function() {\n            xExtentDomain = extent1.i;\n            yExtentDomain = extent1.j;\n            event_({\n              type: \"brush\",\n              mode: \"resize\"\n            });\n            event_({\n              type: \"brushend\"\n            });\n          });\n        } else {\n          event_({\n            type: \"brushstart\"\n          });\n          event_({\n            type: \"brush\",\n            mode: \"resize\"\n          });\n          event_({\n            type: \"brushend\"\n          });\n        }\n      });\n    };\n    function redraw(g) {\n      g.selectAll(\".resize\").attr(\"transform\", function(d) {\n        return \"translate(\" + xExtent[+/e$/.test(d)] + \",\" + yExtent[+/^s/.test(d)] + \")\";\n      });\n    }\n    function redrawX(g) {\n      g.select(\".extent\").attr(\"x\", xExtent[0]);\n      g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", xExtent[1] - xExtent[0]);\n    }\n    function redrawY(g) {\n      g.select(\".extent\").attr(\"y\", yExtent[0]);\n      g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", yExtent[1] - yExtent[0]);\n    }\n    function brushstart() {\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed(\"extent\"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;\n      var w = d3.select(d3_window(target)).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\n      if (d3.event.changedTouches) {\n        w.on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend);\n      } else {\n        w.on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend);\n      }\n      g.interrupt().selectAll(\"*\").interrupt();\n      if (dragging) {\n        origin[0] = xExtent[0] - origin[0];\n        origin[1] = yExtent[0] - origin[1];\n      } else if (resizing) {\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\n        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\n        origin[0] = xExtent[ex];\n        origin[1] = yExtent[ey];\n      } else if (d3.event.altKey) center = origin.slice();\n      g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n      d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n      event_({\n        type: \"brushstart\"\n      });\n      brushmove();\n      function keydown() {\n        if (d3.event.keyCode == 32) {\n          if (!dragging) {\n            center = null;\n            origin[0] -= xExtent[1];\n            origin[1] -= yExtent[1];\n            dragging = 2;\n          }\n          d3_eventPreventDefault();\n        }\n      }\n      function keyup() {\n        if (d3.event.keyCode == 32 && dragging == 2) {\n          origin[0] += xExtent[1];\n          origin[1] += yExtent[1];\n          dragging = 0;\n          d3_eventPreventDefault();\n        }\n      }\n      function brushmove() {\n        var point = d3.mouse(target), moved = false;\n        if (offset) {\n          point[0] += offset[0];\n          point[1] += offset[1];\n        }\n        if (!dragging) {\n          if (d3.event.altKey) {\n            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];\n            origin[0] = xExtent[+(point[0] < center[0])];\n            origin[1] = yExtent[+(point[1] < center[1])];\n          } else center = null;\n        }\n        if (resizingX && move1(point, x, 0)) {\n          redrawX(g);\n          moved = true;\n        }\n        if (resizingY && move1(point, y, 1)) {\n          redrawY(g);\n          moved = true;\n        }\n        if (moved) {\n          redraw(g);\n          event_({\n            type: \"brush\",\n            mode: dragging ? \"move\" : \"resize\"\n          });\n        }\n      }\n      function move1(point, scale, i) {\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\n        if (dragging) {\n          r0 -= position;\n          r1 -= size + position;\n        }\n        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\n        if (dragging) {\n          max = (min += position) + size;\n        } else {\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n          if (position < min) {\n            max = min;\n            min = position;\n          } else {\n            max = position;\n          }\n        }\n        if (extent[0] != min || extent[1] != max) {\n          if (i) yExtentDomain = null; else xExtentDomain = null;\n          extent[0] = min;\n          extent[1] = max;\n          return true;\n        }\n      }\n      function brushend() {\n        brushmove();\n        g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n        d3.select(\"body\").style(\"cursor\", null);\n        w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\n        dragRestore();\n        event_({\n          type: \"brushend\"\n        });\n      }\n    }\n    brush.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.clamp = function(z) {\n      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\n      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;\n      return brush;\n    };\n    brush.extent = function(z) {\n      var x0, x1, y0, y1, t;\n      if (!arguments.length) {\n        if (x) {\n          if (xExtentDomain) {\n            x0 = xExtentDomain[0], x1 = xExtentDomain[1];\n          } else {\n            x0 = xExtent[0], x1 = xExtent[1];\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\n          }\n        }\n        if (y) {\n          if (yExtentDomain) {\n            y0 = yExtentDomain[0], y1 = yExtentDomain[1];\n          } else {\n            y0 = yExtent[0], y1 = yExtent[1];\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\n          }\n        }\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\n      }\n      if (x) {\n        x0 = z[0], x1 = z[1];\n        if (y) x0 = x0[0], x1 = x1[0];\n        xExtentDomain = [ x0, x1 ];\n        if (x.invert) x0 = x(x0), x1 = x(x1);\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];\n      }\n      if (y) {\n        y0 = z[0], y1 = z[1];\n        if (x) y0 = y0[1], y1 = y1[1];\n        yExtentDomain = [ y0, y1 ];\n        if (y.invert) y0 = y(y0), y1 = y(y1);\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];\n      }\n      return brush;\n    };\n    brush.clear = function() {\n      if (!brush.empty()) {\n        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\n        xExtentDomain = yExtentDomain = null;\n      }\n      return brush;\n    };\n    brush.empty = function() {\n      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\n    };\n    return d3.rebind(brush, event, \"on\");\n  };\n  var d3_svg_brushCursor = {\n    n: \"ns-resize\",\n    e: \"ew-resize\",\n    s: \"ns-resize\",\n    w: \"ew-resize\",\n    nw: \"nwse-resize\",\n    ne: \"nesw-resize\",\n    se: \"nwse-resize\",\n    sw: \"nesw-resize\"\n  };\n  var d3_svg_brushResizes = [ [ \"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\" ], [ \"e\", \"w\" ], [ \"n\", \"s\" ], [] ];\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n  var d3_time_formatUtc = d3_time_format.utc;\n  var d3_time_formatIso = d3_time_formatUtc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n  d3_time_format.iso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\") ? d3_time_formatIsoNative : d3_time_formatIso;\n  function d3_time_formatIsoNative(date) {\n    return date.toISOString();\n  }\n  d3_time_formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n  d3_time.second = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 1e3) * 1e3);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n  }, function(date) {\n    return date.getSeconds();\n  });\n  d3_time.seconds = d3_time.second.range;\n  d3_time.seconds.utc = d3_time.second.utc.range;\n  d3_time.minute = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 6e4) * 6e4);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n  }, function(date) {\n    return date.getMinutes();\n  });\n  d3_time.minutes = d3_time.minute.range;\n  d3_time.minutes.utc = d3_time.minute.utc.range;\n  d3_time.hour = d3_time_interval(function(date) {\n    var timezone = date.getTimezoneOffset() / 60;\n    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n  }, function(date) {\n    return date.getHours();\n  });\n  d3_time.hours = d3_time.hour.range;\n  d3_time.hours.utc = d3_time.hour.utc.range;\n  d3_time.month = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setDate(1);\n    return date;\n  }, function(date, offset) {\n    date.setMonth(date.getMonth() + offset);\n  }, function(date) {\n    return date.getMonth();\n  });\n  d3_time.months = d3_time.month.range;\n  d3_time.months.utc = d3_time.month.utc.range;\n  function d3_time_scale(linear, methods, format) {\n    function scale(x) {\n      return linear(x);\n    }\n    scale.invert = function(x) {\n      return d3_time_scaleDate(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n      linear.domain(x);\n      return scale;\n    };\n    function tickMethod(extent, count) {\n      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);\n      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {\n        return d / 31536e6;\n      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\n    }\n    scale.nice = function(interval, skip) {\n      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" && tickMethod(extent, interval);\n      if (method) interval = method[0], skip = method[1];\n      function skipped(date) {\n        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\n      }\n      return scale.domain(d3_scale_nice(domain, skip > 1 ? {\n        floor: function(date) {\n          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\n          return date;\n        },\n        ceil: function(date) {\n          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\n          return date;\n        }\n      } : interval));\n    };\n    scale.ticks = function(interval, skip) {\n      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" ? tickMethod(extent, interval) : !interval.range && [ {\n        range: interval\n      }, skip ];\n      if (method) interval = method[0], skip = method[1];\n      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\n    };\n    scale.tickFormat = function() {\n      return format;\n    };\n    scale.copy = function() {\n      return d3_time_scale(linear.copy(), methods, format);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_time_scaleDate(t) {\n    return new Date(t);\n  }\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\n  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\n  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ \".%L\", function(d) {\n    return d.getMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getDay() && d.getDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  var d3_time_scaleMilliseconds = {\n    range: function(start, stop, step) {\n      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\n    },\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  d3_time_scaleLocalMethods.year = d3_time.year;\n  d3_time.scale = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n  };\n  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {\n    return [ m[0].utc, m[1] ];\n  });\n  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ \".%L\", function(d) {\n    return d.getUTCMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getUTCSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getUTCMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getUTCHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getUTCDay() && d.getUTCDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getUTCDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getUTCMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  d3_time_scaleUtcMethods.year = d3_time.year.utc;\n  d3_time.scale.utc = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\n  };\n  d3.text = d3_xhrType(function(request) {\n    return request.responseText;\n  });\n  d3.json = function(url, callback) {\n    return d3_xhr(url, \"application/json\", d3_json, callback);\n  };\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n  d3.html = function(url, callback) {\n    return d3_xhr(url, \"text/html\", d3_html, callback);\n  };\n  function d3_html(request) {\n    var range = d3_document.createRange();\n    range.selectNode(d3_document.body);\n    return range.createContextualFragment(request.responseText);\n  }\n  d3.xml = d3_xhrType(function(request) {\n    return request.responseXML;\n  });\n  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === \"object\" && module.exports) module.exports = d3; else this.d3 = d3;\n}();\n\n/***/ }),\n\n/***/ 272:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(273).crossfilter;\n\n\n/***/ }),\n\n/***/ 273:\n/***/ (function(module, exports) {\n\n(function(exports){\ncrossfilter.version = \"1.3.14\";\nfunction crossfilter_identity(d) {\n  return d;\n}\ncrossfilter.permute = permute;\n\nfunction permute(array, index) {\n  for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\nvar bisect = crossfilter.bisect = bisect_by(crossfilter_identity);\n\nbisect.by = bisect_by;\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\nvar heap = crossfilter.heap = heap_by(crossfilter_identity);\n\nheap.by = heap_by;\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\nvar heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);\n\nheapselect.by = heapselect_by;\n\nfunction heapselect_by(f) {\n  var heap = heap_by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        x,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (x = f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\nvar insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);\n\ninsertionsort.by = insertionsort_by;\n\nfunction insertionsort_by(f) {\n\n  function insertionsort(a, lo, hi) {\n    for (var i = lo + 1; i < hi; ++i) {\n      for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n        a[j] = a[j - 1];\n      }\n      a[j] = t;\n    }\n    return a;\n  }\n\n  return insertionsort;\n}\n// Algorithm designed by Vladimir Yaroslavskiy.\n// Implementation based on the Dart project; see lib/dart/LICENSE for details.\n\nvar quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);\n\nquicksort.by = quicksort_by;\n\nfunction quicksort_by(f) {\n  var insertionsort = insertionsort_by(f);\n\n  function sort(a, lo, hi) {\n    return (hi - lo < quicksort_sizeThreshold\n        ? insertionsort\n        : quicksort)(a, lo, hi);\n  }\n\n  function quicksort(a, lo, hi) {\n    // Compute the two pivots by looking at 5 elements.\n    var sixth = (hi - lo) / 6 | 0,\n        i1 = lo + sixth,\n        i5 = hi - 1 - sixth,\n        i3 = lo + hi - 1 >> 1,  // The midpoint.\n        i2 = i3 - sixth,\n        i4 = i3 + sixth;\n\n    var e1 = a[i1], x1 = f(e1),\n        e2 = a[i2], x2 = f(e2),\n        e3 = a[i3], x3 = f(e3),\n        e4 = a[i4], x4 = f(e4),\n        e5 = a[i5], x5 = f(e5);\n\n    var t;\n\n    // Sort the selected 5 elements using a sorting network.\n    if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n    if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n    if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n    if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n\n    var pivot1 = e2, pivotValue1 = x2,\n        pivot2 = e4, pivotValue2 = x4;\n\n    // e2 and e4 have been saved in the pivot variables. They will be written\n    // back, once the partitioning is finished.\n    a[i1] = e1;\n    a[i2] = a[lo];\n    a[i3] = e3;\n    a[i4] = a[hi - 1];\n    a[i5] = e5;\n\n    var less = lo + 1,   // First element in the middle partition.\n        great = hi - 2;  // Last element in the middle partition.\n\n    // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n    // Object.prototype.valueOf; == and === do not, so in order to be consistent\n    // with natural order (such as for Date objects), we must do two compares.\n    var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n    if (pivotsEqual) {\n\n      // Degenerated case where the partitioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (var k = less; k <= great; ++k) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else if (xk > pivotValue1) {\n\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ek:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          while (true) {\n            var greatValue = f(a[great]);\n            if (greatValue > pivotValue1) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (greatValue < pivotValue1) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ek;\n              break;\n            } else {\n              a[k] = a[great];\n              a[great--] = ek;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else {\n          if (xk > pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue > pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[lo] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[hi - 1] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don't include the pivot values.)\n    sort(a, lo, less - 1);\n    sort(a, great + 2, hi);\n\n    if (pivotsEqual) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return a;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < i1 && great > i5) {\n      var lessValue, greatValue;\n      while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) ++less;\n      while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) --great;\n\n      // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk <= pivotValue1 && xk >= pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          less++;\n        } else {\n          if (xk <= pivotValue2 && xk >= pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // The second partition has now been cleared of pivot elements and looks\n    // as follows:\n    // [  *  |  > pivot1 && < pivot2  | * ]\n    //        ^                      ^\n    //       less                  great\n    // Sort the second partition using recursive descent.\n\n    // The second partition looks as follows:\n    // [  *  |  >= pivot1 && <= pivot2  | * ]\n    //        ^                        ^\n    //       less                    great\n    // Simply sort it by recursive descent.\n\n    return sort(a, less, great + 1);\n  }\n\n  return sort;\n}\n\nvar quicksort_sizeThreshold = 32;\nvar crossfilter_array8 = crossfilter_arrayUntyped,\n    crossfilter_array16 = crossfilter_arrayUntyped,\n    crossfilter_array32 = crossfilter_arrayUntyped,\n    crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped,\n    crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;\n\nif (typeof Uint8Array !== \"undefined\") {\n  crossfilter_array8 = function(n) { return new Uint8Array(n); };\n  crossfilter_array16 = function(n) { return new Uint16Array(n); };\n  crossfilter_array32 = function(n) { return new Uint32Array(n); };\n\n  crossfilter_arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  crossfilter_arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = crossfilter_array16(array.length); break;\n      case 32: copy = crossfilter_array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction crossfilter_arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\nfunction crossfilter_filterExact(bisect, value) {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nfunction crossfilter_filterRange(bisect, range) {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nfunction crossfilter_filterAll(values) {\n  return [0, values.length];\n}\nfunction crossfilter_null() {\n  return null;\n}\nfunction crossfilter_zero() {\n  return 0;\n}\nfunction crossfilter_reduceIncrement(p) {\n  return p + 1;\n}\n\nfunction crossfilter_reduceDecrement(p) {\n  return p - 1;\n}\n\nfunction crossfilter_reduceAdd(f) {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nfunction crossfilter_reduceSubtract(f) {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\nexports.crossfilter = crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      m = 0, // a bit mask representing which dimensions are in use\n      M = 8, // number of dimensions that can fit in `filters`\n      filters = crossfilter_array8(0), // M bits per record; 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = []; // when data is removed\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters = crossfilter_arrayLengthen(filters, n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters.\n  function removeData() {\n    var newIndex = crossfilter_index(n, n),\n        removed = [];\n    for (var i = 0, j = 0; i < n; ++i) {\n      if (filters[i]) newIndex[i] = j++;\n      else removed.push(i);\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(0, [], removed); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var i = 0, j = 0, k; i < n; ++i) {\n      if (k = filters[i]) {\n        if (i !== j) filters[j] = k, data[j] = data[i];\n        ++j;\n      }\n    }\n    data.length = j;\n    while (n > j) filters[--n] = 0;\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value) {\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var one = ~m & -~m, // lowest unset bit as mask, e.g., 00001000\n        zero = ~one, // inverted one, e.g., 11110111\n        values, // sorted, cached array\n        index, // value rank ↦ object id\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        sort = quicksort_by(function(i) { return newValues[i]; }),\n        refilter = crossfilter_filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Incorporate any existing data into this dimension, and make sure that the\n    // filter bitset is wide enough to handle the new dimension.\n    m |= one;\n    if (M >= 32 ? !one : m & -(1 << M)) {\n      filters = crossfilter_arrayWiden(filters, M <<= 1);\n    }\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n\n      // Permute new values into natural order using a sorted index.\n      newValues = newData.map(value);\n      newIndex = sort(crossfilter_range(n1), 0, n1);\n      newValues = permute(newValues, newIndex);\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1], i;\n      if (refilterFunction) {\n        for (i = 0; i < n1; ++i) {\n          if (!refilterFunction(newValues[i], i)) filters[newIndex[i] + n0] |= one;\n        }\n      } else {\n        for (i = 0; i < lo1; ++i) filters[newIndex[i] + n0] |= one;\n        for (i = hi1; i < n1; ++i) filters[newIndex[i] + n0] |= one;\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n      var oldValues = values,\n          oldIndex = index,\n          i0 = 0,\n          i1 = 0;\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = new Array(n);\n      index = crossfilter_index(n, n);\n\n      // Merge the old and new sorted values, and old and new index.\n      for (i = 0; i0 < n0 && i1 < n1; ++i) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[i] = oldValues[i0];\n          index[i] = oldIndex[i0++];\n        } else {\n          values[i] = newValues[i1];\n          index[i] = newIndex[i1++] + n0;\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++i) {\n        values[i] = oldValues[i0];\n        index[i] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++i) {\n        values[i] = newValues[i1];\n        index[i] = newIndex[i1] + n0;\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      for (var i = 0, j = 0, k; i < n; ++i) {\n        if (filters[k = index[i]]) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[k];\n          ++j;\n        }\n      }\n      values.length = j;\n      while (j < n) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; });\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [];\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, added, removed); });\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      return filterIndexBounds((refilter = crossfilter_filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      refilter = crossfilter_filterAll;\n\n      filterIndexFunction(refilterFunction = f);\n\n      lo0 = 0;\n      hi0 = n;\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [];\n\n      for (i = 0; i < n; ++i) {\n        if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n          if (x) filters[k] &= zero, added.push(k);\n          else filters[k] |= one, removed.push(k);\n        }\n      }\n      filterListeners.forEach(function(l) { l(one, added, removed); });\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k) {\n      var array = [],\n          i = hi0,\n          j;\n\n      while (--i >= lo0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k) {\n      var array = [],\n          i = lo0,\n          j;\n\n      while (i < hi0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = crossfilter_capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = crossfilter_null,\n          reset = crossfilter_null,\n          resetNeeded = true,\n          groupAll = key === crossfilter_null;\n\n      if (arguments.length < 1) key = crossfilter_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n        var oldGroups = groups,\n            reIndex = crossfilter_index(k, groupCapacity),\n            add = reduceAdd,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = crossfilter_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            if (g0 = oldGroups[++i0]) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n          while (!(x1 > x)) {\n            groupIndex[j = newIndex[i1] + n0] = k;\n            if (!(filters[j] & zero)) g.value = add(g.value, data[j]);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater than all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if (k > i0) for (i0 = 0; i0 < n0; ++i0) {\n          groupIndex[i0] = reIndex[groupIndex[i0]];\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = crossfilter_null;\n            reset = crossfilter_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if (++k === groupCapacity) {\n            reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);\n            groupCapacity = crossfilter_capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData() {\n        if (k > 1) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = crossfilter_index(oldK, oldK);\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          for (var i = 0, j = 0; i < n; ++i) {\n            if (filters[i]) {\n              seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n              ++j;\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1) {\n            // Reindex the group index using seenGroups to find the new index.\n            for (var i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = crossfilter_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var i = 0; i < n; ++i) if (filters[i]) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = crossfilter_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      function updateMany(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g;\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      function updateOne(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = heapselect_by(valueOf);\n        heap = heap_by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(crossfilter_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(crossfilter_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      m &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = n0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, added, removed) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (!filters[k = added[i]]) {\n          reduceValue = reduceAdd(reduceValue, data[k]);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters[k = removed[i]] === filterOne) {\n          reduceValue = reduceRemove(reduceValue, data[k]);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      for (i = 0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction crossfilter_index(n, m) {\n  return (m < 0x101\n      ? crossfilter_array8 : m < 0x10001\n      ? crossfilter_array16\n      : crossfilter_array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction crossfilter_range(n) {\n  var range = crossfilter_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction crossfilter_capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n})(typeof exports !== 'undefined' && exports || this);\n\n\n/***/ }),\n\n/***/ 293:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_dom__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_reactstrap__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_dc__ = __webpack_require__(270);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_dc___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_dc__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Chart=function(_PureComponent){_inherits(Chart,_PureComponent);function Chart(props){_classCallCheck(this,Chart);var _this=_possibleConstructorReturn(this,(Chart.__proto__||Object.getPrototypeOf(Chart)).call(this,props));_this.reset=_this.reset.bind(_this);return _this;}_createClass(Chart,[{key:\"componentDidMount\",value:function componentDidMount(){var _this2=this;var dim=this.context.ndx.dimension(function(d){var output=d[_this2.props.field];if(output===null||output.length===0){return _this2.props.nullValue;}else return output;});var group=dim.group();var chart=__WEBPACK_IMPORTED_MODULE_4_dc___default.a[this.props.type+\"Chart\"](Object(__WEBPACK_IMPORTED_MODULE_1_react_dom__[\"findDOMNode\"])(this.refs.el)).dimension(dim).group(group);if(this.props.chartOptions){chart.options(this.props.chartOptions);}chart.render();this.chart=chart;}},{key:\"reset\",value:function reset(){this.chart.filterAll().redrawGroup();}},{key:\"render\",value:function render(){var _props=this.props,field=_props.field,legend=_props.legend,wrapperProps=_props.wrapperProps;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2_reactstrap__[\"b\" /* Col */],wrapperProps,__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"div\",{ref:\"el\"},legend&&__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(\"legend\",null,field,\" \",__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2_reactstrap__[\"a\" /* Button */],{size:\"sm\",onClick:this.reset,className:\"reset\",style:{display:\"none\"}},\"reset\"))));}}]);return Chart;}(__WEBPACK_IMPORTED_MODULE_0_react__[\"PureComponent\"]);Chart.contextTypes={ndx:__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired};Chart.defaultProps={type:\"row\",nullValue:\"\",legend:true};Chart.propTypes={type:__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,nullValue:__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,legend:__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,field:__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string.isRequired,chartOptions:__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object,wrapperProps:__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object};/* harmony default export */ __webpack_exports__[\"a\"] = (Chart);\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/1.c49891a7.chunk.js","import React from \"react\";\r\nimport { Container, Jumbotron, Row } from \"reactstrap\";\r\nimport Chart from \"../../components/Chart\";\r\n\r\nconst HCIM = props => (\r\n  <Container fluid>\r\n    <Jumbotron style={{ marginBottom: \"1rem\" }}>\r\n      <h2>WIP: Explore Hardcore Ironman Deaths (from Runescape)</h2>\r\n      <p className=\"lead\">\r\n        The data this is based on is pulled from the spreadsheet{\" \"}\r\n        <a\r\n          href=\"https://www.reddit.com/user/CaptainP\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          CaptainP\r\n        </a>{\" \"}\r\n        provided on reddit after his own analyis of his scraped data.\r\n      </p>\r\n      <p>\r\n        This includes over 10.5 thousand HCIM deaths from 18/11/2014 to\r\n        2/09/2017.<br />\r\n        If you're interested, you can view the reddit post and comments {}\r\n        <a\r\n          href=\"https://www.reddit.com/r/runescape/comments/6y0oit/i_used_an_html_parser_to_pull_all_105k_hcim/\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          here\r\n        </a>.\r\n      </p>\r\n    </Jumbotron>\r\n    <Row>\r\n      <Chart\r\n        field=\"Location\"\r\n        nullValue=\"Unknown\"\r\n        chartOptions={{ cap: 10, height: 400 }}\r\n      />\r\n      <Chart\r\n        field=\"Death\"\r\n        nullValue=\"Unknown\"\r\n        chartOptions={{ cap: 10, height: 400 }}\r\n      />\r\n    </Row>\r\n  </Container>\r\n);\r\n\r\nexport default HCIM;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/vis/HCIM.jsx","/*!\n *  dc 2.1.8\n *  http://dc-js.github.io/dc.js/\n *  Copyright 2012-2016 Nick Zhu & the dc.js Developers\n *  https://github.com/dc-js/dc.js/blob/master/AUTHORS\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n(function() { function _dc(d3, crossfilter) {\n'use strict';\n\n/**\n * The entire dc.js library is scoped under the **dc** name space. It does not introduce\n * anything else into the global name space.\n *\n * Most `dc` functions are designed to allow function chaining, meaning they return the current chart\n * instance whenever it is appropriate.  The getter forms of functions do not participate in function\n * chaining because they return values that are not the chart, although some,\n * such as {@link dc.baseMixin#svg .svg} and {@link dc.coordinateGridMixin#xAxis .xAxis},\n * return values that are themselves chainable d3 objects.\n * @namespace dc\n * @version 2.1.8\n * @example\n * // Example chaining\n * chart.width(300)\n *      .height(300)\n *      .filter('sunday');\n */\n/*jshint -W079*/\nvar dc = {\n    version: '2.1.8',\n    constants: {\n        CHART_CLASS: 'dc-chart',\n        DEBUG_GROUP_CLASS: 'debug',\n        STACK_CLASS: 'stack',\n        DESELECTED_CLASS: 'deselected',\n        SELECTED_CLASS: 'selected',\n        NODE_INDEX_NAME: '__index__',\n        GROUP_INDEX_NAME: '__group_index__',\n        DEFAULT_CHART_GROUP: '__default_chart_group__',\n        EVENT_DELAY: 40,\n        NEGLIGIBLE_NUMBER: 1e-10\n    },\n    _renderlet: null\n};\n/*jshint +W079*/\n\n/**\n * The dc.chartRegistry object maintains sets of all instantiated dc.js charts under named groups\n * and the default group.\n *\n * A chart group often corresponds to a crossfilter instance. It specifies\n * the set of charts which should be updated when a filter changes on one of the charts or when the\n * global functions {@link dc.filterAll dc.filterAll}, {@link dc.refocusAll dc.refocusAll},\n * {@link dc.renderAll dc.renderAll}, {@link dc.redrawAll dc.redrawAll}, or chart functions\n * {@link dc.baseMixin#renderGroup baseMixin.renderGroup},\n * {@link dc.baseMixin#redrawGroup baseMixin.redrawGroup} are called.\n *\n * @namespace chartRegistry\n * @memberof dc\n * @type {{has, register, deregister, clear, list}}\n */\ndc.chartRegistry = (function () {\n    // chartGroup:string => charts:array\n    var _chartMap = {};\n\n    function initializeChartGroup (group) {\n        if (!group) {\n            group = dc.constants.DEFAULT_CHART_GROUP;\n        }\n\n        if (!_chartMap[group]) {\n            _chartMap[group] = [];\n        }\n\n        return group;\n    }\n\n    return {\n        /**\n         * Determine if a given chart instance resides in any group in the registry.\n         * @method has\n         * @memberof dc.chartRegistry\n         * @param {Object} chart dc.js chart instance\n         * @returns {Boolean}\n         */\n        has: function (chart) {\n            for (var e in _chartMap) {\n                if (_chartMap[e].indexOf(chart) >= 0) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /**\n         * Add given chart instance to the given group, creating the group if necessary.\n         * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n         * @method register\n         * @memberof dc.chartRegistry\n         * @param {Object} chart dc.js chart instance\n         * @param {String} [group] Group name\n         */\n        register: function (chart, group) {\n            group = initializeChartGroup(group);\n            _chartMap[group].push(chart);\n        },\n\n        /**\n         * Remove given chart instance from the given group, creating the group if necessary.\n         * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n         * @method deregister\n         * @memberof dc.chartRegistry\n         * @param {Object} chart dc.js chart instance\n         * @param {String} [group] Group name\n         */\n        deregister: function (chart, group) {\n            group = initializeChartGroup(group);\n            for (var i = 0; i < _chartMap[group].length; i++) {\n                if (_chartMap[group][i].anchorName() === chart.anchorName()) {\n                    _chartMap[group].splice(i, 1);\n                    break;\n                }\n            }\n        },\n\n        /**\n         * Clear given group if one is provided, otherwise clears all groups.\n         * @method clear\n         * @memberof dc.chartRegistry\n         * @param {String} group Group name\n         */\n        clear: function (group) {\n            if (group) {\n                delete _chartMap[group];\n            } else {\n                _chartMap = {};\n            }\n        },\n\n        /**\n         * Get an array of each chart instance in the given group.\n         * If no group is provided, the charts in the default group are returned.\n         * @method list\n         * @memberof dc.chartRegistry\n         * @param {String} [group] Group name\n         * @returns {Array<Object>}\n         */\n        list: function (group) {\n            group = initializeChartGroup(group);\n            return _chartMap[group];\n        }\n    };\n})();\n\n/**\n * Add given chart instance to the given group, creating the group if necessary.\n * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n * @memberof dc\n * @method registerChart\n * @param {Object} chart dc.js chart instance\n * @param {String} [group] Group name\n */\ndc.registerChart = function (chart, group) {\n    dc.chartRegistry.register(chart, group);\n};\n\n/**\n * Remove given chart instance from the given group, creating the group if necessary.\n * If no group is provided, the default group `dc.constants.DEFAULT_CHART_GROUP` will be used.\n * @memberof dc\n * @method deregisterChart\n * @param {Object} chart dc.js chart instance\n * @param {String} [group] Group name\n */\ndc.deregisterChart = function (chart, group) {\n    dc.chartRegistry.deregister(chart, group);\n};\n\n/**\n * Determine if a given chart instance resides in any group in the registry.\n * @memberof dc\n * @method hasChart\n * @param {Object} chart dc.js chart instance\n * @returns {Boolean}\n */\ndc.hasChart = function (chart) {\n    return dc.chartRegistry.has(chart);\n};\n\n/**\n * Clear given group if one is provided, otherwise clears all groups.\n * @memberof dc\n * @method deregisterAllCharts\n * @param {String} group Group name\n */\ndc.deregisterAllCharts = function (group) {\n    dc.chartRegistry.clear(group);\n};\n\n/**\n * Clear all filters on all charts within the given chart group. If the chart group is not given then\n * only charts that belong to the default chart group will be reset.\n * @memberof dc\n * @method filterAll\n * @param {String} [group]\n */\ndc.filterAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].filterAll();\n    }\n};\n\n/**\n * Reset zoom level / focus on all charts that belong to the given chart group. If the chart group is\n * not given then only charts that belong to the default chart group will be reset.\n * @memberof dc\n * @method refocusAll\n * @param {String} [group]\n */\ndc.refocusAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        if (charts[i].focus) {\n            charts[i].focus();\n        }\n    }\n};\n\n/**\n * Re-render all charts belong to the given chart group. If the chart group is not given then only\n * charts that belong to the default chart group will be re-rendered.\n * @memberof dc\n * @method renderAll\n * @param {String} [group]\n */\ndc.renderAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].render();\n    }\n\n    if (dc._renderlet !== null) {\n        dc._renderlet(group);\n    }\n};\n\n/**\n * Redraw all charts belong to the given chart group. If the chart group is not given then only charts\n * that belong to the default chart group will be re-drawn. Redraw is different from re-render since\n * when redrawing dc tries to update the graphic incrementally, using transitions, instead of starting\n * from scratch.\n * @memberof dc\n * @method redrawAll\n * @param {String} [group]\n */\ndc.redrawAll = function (group) {\n    var charts = dc.chartRegistry.list(group);\n    for (var i = 0; i < charts.length; ++i) {\n        charts[i].redraw();\n    }\n\n    if (dc._renderlet !== null) {\n        dc._renderlet(group);\n    }\n};\n\n/**\n * If this boolean is set truthy, all transitions will be disabled, and changes to the charts will happen\n * immediately.\n * @memberof dc\n * @member disableTransitions\n * @type {Boolean}\n * @default false\n */\ndc.disableTransitions = false;\n\n/**\n * Start a transition on a selection if transitions are globally enabled\n * ({@link dc.disableTransitions} is false) and the duration is greater than zero; otherwise return\n * the selection. Since most operations are the same on a d3 selection and a d3 transition, this\n * allows a common code path for both cases.\n * @memberof dc\n * @method transition\n * @param {d3.selection} selection - the selection to be transitioned\n * @param {Number|Function} [duration=250] - the duration of the transition in milliseconds, a\n * function returning the duration, or 0 for no transition\n * @param {Number|Function} [delay] - the delay of the transition in milliseconds, or a function\n * returning the delay, or 0 for no delay\n * @param {String} [name] - the name of the transition (if concurrent transitions on the same\n * elements are needed)\n * @returns {d3.transition|d3.selection}\n */\ndc.transition = function (selection, duration, delay, name) {\n    if (dc.disableTransitions || duration <= 0) {\n        return selection;\n    }\n\n    var s = selection.transition(name);\n\n    if (duration >= 0 || duration !== undefined) {\n        s = s.duration(duration);\n    }\n    if (delay >= 0 || delay !== undefined) {\n        s = s.delay(delay);\n    }\n\n    return s;\n};\n\n/* somewhat silly, but to avoid duplicating logic */\ndc.optionalTransition = function (enable, duration, delay, name) {\n    if (enable) {\n        return function (selection) {\n            return dc.transition(selection, duration, delay, name);\n        };\n    } else {\n        return function (selection) {\n            return selection;\n        };\n    }\n};\n\n// See http://stackoverflow.com/a/20773846\ndc.afterTransition = function (transition, callback) {\n    if (transition.empty() || !transition.duration) {\n        callback.call(transition);\n    } else {\n        var n = 0;\n        transition\n            .each(function () { ++n; })\n            .each('end', function () {\n                if (!--n) {\n                    callback.call(transition);\n                }\n            });\n    }\n};\n\n/**\n * @namespace units\n * @memberof dc\n * @type {{}}\n */\ndc.units = {};\n\n/**\n * The default value for {@link dc.coordinateGridMixin#xUnits .xUnits} for the\n * {@link dc.coordinateGridMixin Coordinate Grid Chart} and should\n * be used when the x values are a sequence of integers.\n * It is a function that counts the number of integers in the range supplied in its start and end parameters.\n * @method integers\n * @memberof dc.units\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\n * @example\n * chart.xUnits(dc.units.integers) // already the default\n * @param {Number} start\n * @param {Number} end\n * @returns {Number}\n */\ndc.units.integers = function (start, end) {\n    return Math.abs(end - start);\n};\n\n/**\n * This argument can be passed to the {@link dc.coordinateGridMixin#xUnits .xUnits} function of the to\n * specify ordinal units for the x axis. Usually this parameter is used in combination with passing\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md d3.scale.ordinal} to\n * {@link dc.coordinateGridMixin#x .x}.\n * It just returns the domain passed to it, which for ordinal charts is an array of all values.\n * @method ordinal\n * @memberof dc.units\n * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md d3.scale.ordinal}\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\n * @see {@link dc.coordinateGridMixin#x coordinateGridMixin.x}\n * @example\n * chart.xUnits(dc.units.ordinal)\n *      .x(d3.scale.ordinal())\n * @param {*} start\n * @param {*} end\n * @param {Array<String>} domain\n * @returns {Array<String>}\n */\ndc.units.ordinal = function (start, end, domain) {\n    return domain;\n};\n\n/**\n * @namespace fp\n * @memberof dc.units\n * @type {{}}\n */\ndc.units.fp = {};\n/**\n * This function generates an argument for the {@link dc.coordinateGridMixin Coordinate Grid Chart}\n * {@link dc.coordinateGridMixin#xUnits .xUnits} function specifying that the x values are floating-point\n * numbers with the given precision.\n * The returned function determines how many values at the given precision will fit into the range\n * supplied in its start and end parameters.\n * @method precision\n * @memberof dc.units.fp\n * @see {@link dc.coordinateGridMixin#xUnits coordinateGridMixin.xUnits}\n * @example\n * // specify values (and ticks) every 0.1 units\n * chart.xUnits(dc.units.fp.precision(0.1)\n * // there are 500 units between 0.5 and 1 if the precision is 0.001\n * var thousandths = dc.units.fp.precision(0.001);\n * thousandths(0.5, 1.0) // returns 500\n * @param {Number} precision\n * @returns {Function} start-end unit function\n */\ndc.units.fp.precision = function (precision) {\n    var _f = function (s, e) {\n        var d = Math.abs((e - s) / _f.resolution);\n        if (dc.utils.isNegligible(d - Math.floor(d))) {\n            return Math.floor(d);\n        } else {\n            return Math.ceil(d);\n        }\n    };\n    _f.resolution = precision;\n    return _f;\n};\n\ndc.round = {};\ndc.round.floor = function (n) {\n    return Math.floor(n);\n};\ndc.round.ceil = function (n) {\n    return Math.ceil(n);\n};\ndc.round.round = function (n) {\n    return Math.round(n);\n};\n\ndc.override = function (obj, functionName, newFunction) {\n    var existingFunction = obj[functionName];\n    obj['_' + functionName] = existingFunction;\n    obj[functionName] = newFunction;\n};\n\ndc.renderlet = function (_) {\n    if (!arguments.length) {\n        return dc._renderlet;\n    }\n    dc._renderlet = _;\n    return dc;\n};\n\ndc.instanceOfChart = function (o) {\n    return o instanceof Object && o.__dcFlag__ && true;\n};\n\ndc.errors = {};\n\ndc.errors.Exception = function (msg) {\n    var _msg = msg || 'Unexpected internal error';\n\n    this.message = _msg;\n\n    this.toString = function () {\n        return _msg;\n    };\n    this.stack = (new Error()).stack;\n};\ndc.errors.Exception.prototype = Object.create(Error.prototype);\ndc.errors.Exception.prototype.constructor = dc.errors.Exception;\n\ndc.errors.InvalidStateException = function () {\n    dc.errors.Exception.apply(this, arguments);\n};\n\ndc.errors.InvalidStateException.prototype = Object.create(dc.errors.Exception.prototype);\ndc.errors.InvalidStateException.prototype.constructor = dc.errors.InvalidStateException;\n\ndc.errors.BadArgumentException = function () {\n    dc.errors.Exception.apply(this, arguments);\n};\n\ndc.errors.BadArgumentException.prototype = Object.create(dc.errors.Exception.prototype);\ndc.errors.BadArgumentException.prototype.constructor = dc.errors.BadArgumentException;\n\n/**\n * The default date format for dc.js\n * @name dateFormat\n * @memberof dc\n * @type {Function}\n * @default d3.time.format('%m/%d/%Y')\n */\ndc.dateFormat = d3.time.format('%m/%d/%Y');\n\n/**\n * @namespace printers\n * @memberof dc\n * @type {{}}\n */\ndc.printers = {};\n\n/**\n * Converts a list of filters into a readable string.\n * @method filters\n * @memberof dc.printers\n * @param {Array<dc.filters>} filters\n * @returns {String}\n */\ndc.printers.filters = function (filters) {\n    var s = '';\n\n    for (var i = 0; i < filters.length; ++i) {\n        if (i > 0) {\n            s += ', ';\n        }\n        s += dc.printers.filter(filters[i]);\n    }\n\n    return s;\n};\n\n/**\n * Converts a filter into a readable string.\n * @method filter\n * @memberof dc.printers\n * @param {dc.filters|any|Array<any>} filter\n * @returns {String}\n */\ndc.printers.filter = function (filter) {\n    var s = '';\n\n    if (typeof filter !== 'undefined' && filter !== null) {\n        if (filter instanceof Array) {\n            if (filter.length >= 2) {\n                s = '[' + dc.utils.printSingleValue(filter[0]) + ' -> ' + dc.utils.printSingleValue(filter[1]) + ']';\n            } else if (filter.length >= 1) {\n                s = dc.utils.printSingleValue(filter[0]);\n            }\n        } else {\n            s = dc.utils.printSingleValue(filter);\n        }\n    }\n\n    return s;\n};\n\n/**\n * Returns a function that given a string property name, can be used to pluck the property off an object.  A function\n * can be passed as the second argument to also alter the data being returned.\n *\n * This can be a useful shorthand method to create accessor functions.\n * @method pluck\n * @memberof dc\n * @example\n * var xPluck = dc.pluck('x');\n * var objA = {x: 1};\n * xPluck(objA) // 1\n * @example\n * var xPosition = dc.pluck('x', function (x, i) {\n *     // `this` is the original datum,\n *     // `x` is the x property of the datum,\n *     // `i` is the position in the array\n *     return this.radius + x;\n * });\n * dc.selectAll('.circle').data(...).x(xPosition);\n * @param {String} n\n * @param {Function} [f]\n * @returns {Function}\n */\ndc.pluck = function (n, f) {\n    if (!f) {\n        return function (d) { return d[n]; };\n    }\n    return function (d, i) { return f.call(d, d[n], i); };\n};\n\n/**\n * @namespace utils\n * @memberof dc\n * @type {{}}\n */\ndc.utils = {};\n\n/**\n * Print a single value filter.\n * @method printSingleValue\n * @memberof dc.utils\n * @param {any} filter\n * @returns {String}\n */\ndc.utils.printSingleValue = function (filter) {\n    var s = '' + filter;\n\n    if (filter instanceof Date) {\n        s = dc.dateFormat(filter);\n    } else if (typeof(filter) === 'string') {\n        s = filter;\n    } else if (dc.utils.isFloat(filter)) {\n        s = dc.utils.printSingleValue.fformat(filter);\n    } else if (dc.utils.isInteger(filter)) {\n        s = Math.round(filter);\n    }\n\n    return s;\n};\ndc.utils.printSingleValue.fformat = d3.format('.2f');\n\n/**\n * Arbitrary add one value to another.\n * @method add\n * @memberof dc.utils\n * @todo\n * These assume than any string r is a percentage (whether or not it includes %).\n * They also generate strange results if l is a string.\n * @param {String|Date|Number} l the value to modify\n * @param {Number} r the amount by which to modify the value\n * @param {String} [t] if `l` is a `Date`, the\n * [interval](https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#interval) in\n * the `d3.time` namespace\n * @returns {String|Date|Number}\n */\ndc.utils.add = function (l, r, t) {\n    if (typeof r === 'string') {\n        r = r.replace('%', '');\n    }\n\n    if (l instanceof Date) {\n        if (typeof r === 'string') {\n            r = +r;\n        }\n        if (t === 'millis') {\n            return new Date(l.getTime() + r);\n        }\n        t = t || 'day';\n        return d3.time[t].offset(l, r);\n    } else if (typeof r === 'string') {\n        var percentage = (+r / 100);\n        return l > 0 ? l * (1 + percentage) : l * (1 - percentage);\n    } else {\n        return l + r;\n    }\n};\n\n/**\n * Arbitrary subtract one value from another.\n * @method subtract\n * @memberof dc.utils\n * @todo\n * These assume than any string r is a percentage (whether or not it includes %).\n * They also generate strange results if l is a string.\n * @param {String|Date|Number} l the value to modify\n * @param {Number} r the amount by which to modify the value\n * @param {String} [t] if `l` is a `Date`, the\n * [interval](https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#interval) in\n * the `d3.time` namespace\n * @returns {String|Date|Number}\n */\ndc.utils.subtract = function (l, r, t) {\n    if (typeof r === 'string') {\n        r = r.replace('%', '');\n    }\n\n    if (l instanceof Date) {\n        if (typeof r === 'string') {\n            r = +r;\n        }\n        if (t === 'millis') {\n            return new Date(l.getTime() - r);\n        }\n        t = t || 'day';\n        return d3.time[t].offset(l, -r);\n    } else if (typeof r === 'string') {\n        var percentage = (+r / 100);\n        return l < 0 ? l * (1 + percentage) : l * (1 - percentage);\n    } else {\n        return l - r;\n    }\n};\n\n/**\n * Is the value a number?\n * @method isNumber\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isNumber = function (n) {\n    return n === +n;\n};\n\n/**\n * Is the value a float?\n * @method isFloat\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isFloat = function (n) {\n    return n === +n && n !== (n | 0);\n};\n\n/**\n * Is the value an integer?\n * @method isInteger\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isInteger = function (n) {\n    return n === +n && n === (n | 0);\n};\n\n/**\n * Is the value very close to zero?\n * @method isNegligible\n * @memberof dc.utils\n * @param {any} n\n * @returns {Boolean}\n */\ndc.utils.isNegligible = function (n) {\n    return !dc.utils.isNumber(n) || (n < dc.constants.NEGLIGIBLE_NUMBER && n > -dc.constants.NEGLIGIBLE_NUMBER);\n};\n\n/**\n * Ensure the value is no greater or less than the min/max values.  If it is return the boundary value.\n * @method clamp\n * @memberof dc.utils\n * @param {any} val\n * @param {any} min\n * @param {any} max\n * @returns {any}\n */\ndc.utils.clamp = function (val, min, max) {\n    return val < min ? min : (val > max ? max : val);\n};\n\n/**\n * Using a simple static counter, provide a unique integer id.\n * @method uniqueId\n * @memberof dc.utils\n * @returns {Number}\n */\nvar _idCounter = 0;\ndc.utils.uniqueId = function () {\n    return ++_idCounter;\n};\n\n/**\n * Convert a name to an ID.\n * @method nameToId\n * @memberof dc.utils\n * @param {String} name\n * @returns {String}\n */\ndc.utils.nameToId = function (name) {\n    return name.toLowerCase().replace(/[\\s]/g, '_').replace(/[\\.']/g, '');\n};\n\n/**\n * Append or select an item on a parent element.\n * @method appendOrSelect\n * @memberof dc.utils\n * @param {d3.selection} parent\n * @param {String} selector\n * @param {String} tag\n * @returns {d3.selection}\n */\ndc.utils.appendOrSelect = function (parent, selector, tag) {\n    tag = tag || selector;\n    var element = parent.select(selector);\n    if (element.empty()) {\n        element = parent.append(tag);\n    }\n    return element;\n};\n\n/**\n * Return the number if the value is a number; else 0.\n * @method safeNumber\n * @memberof dc.utils\n * @param {Number|any} n\n * @returns {Number}\n */\ndc.utils.safeNumber = function (n) { return dc.utils.isNumber(+n) ? +n : 0;};\n\ndc.logger = {};\n\ndc.logger.enableDebugLog = false;\n\ndc.logger.warn = function (msg) {\n    if (console) {\n        if (console.warn) {\n            console.warn(msg);\n        } else if (console.log) {\n            console.log(msg);\n        }\n    }\n\n    return dc.logger;\n};\n\ndc.logger.debug = function (msg) {\n    if (dc.logger.enableDebugLog && console) {\n        if (console.debug) {\n            console.debug(msg);\n        } else if (console.log) {\n            console.log(msg);\n        }\n    }\n\n    return dc.logger;\n};\n\ndc.logger.deprecate = function (fn, msg) {\n    // Allow logging of deprecation\n    var warned = false;\n    function deprecated () {\n        if (!warned) {\n            dc.logger.warn(msg);\n            warned = true;\n        }\n        return fn.apply(this, arguments);\n    }\n    return deprecated;\n};\n\ndc.events = {\n    current: null\n};\n\n/**\n * This function triggers a throttled event function with a specified delay (in milli-seconds).  Events\n * that are triggered repetitively due to user interaction such brush dragging might flood the library\n * and invoke more renders than can be executed in time. Using this function to wrap your event\n * function allows the library to smooth out the rendering by throttling events and only responding to\n * the most recent event.\n * @name events.trigger\n * @memberof dc\n * @example\n * chart.on('renderlet', function(chart) {\n *     // smooth the rendering through event throttling\n *     dc.events.trigger(function(){\n *         // focus some other chart to the range selected by user on this chart\n *         someOtherChart.focus(chart.filter());\n *     });\n * })\n * @param {Function} closure\n * @param {Number} [delay]\n */\ndc.events.trigger = function (closure, delay) {\n    if (!delay) {\n        closure();\n        return;\n    }\n\n    dc.events.current = closure;\n\n    setTimeout(function () {\n        if (closure === dc.events.current) {\n            closure();\n        }\n    }, delay);\n};\n\n/**\n * The dc.js filters are functions which are passed into crossfilter to chose which records will be\n * accumulated to produce values for the charts.  In the crossfilter model, any filters applied on one\n * dimension will affect all the other dimensions but not that one.  dc always applies a filter\n * function to the dimension; the function combines multiple filters and if any of them accept a\n * record, it is filtered in.\n *\n * These filter constructors are used as appropriate by the various charts to implement brushing.  We\n * mention below which chart uses which filter.  In some cases, many instances of a filter will be added.\n *\n * Each of the dc.js filters is an object with the following properties:\n * * `isFiltered` - a function that returns true if a value is within the filter\n * * `filterType` - a string identifying the filter, here the name of the constructor\n *\n * Currently these filter objects are also arrays, but this is not a requirement. Custom filters\n * can be used as long as they have the properties above.\n * @namespace filters\n * @memberof dc\n * @type {{}}\n */\ndc.filters = {};\n\n/**\n * RangedFilter is a filter which accepts keys between `low` and `high`.  It is used to implement X\n * axis brushing for the {@link dc.coordinateGridMixin coordinate grid charts}.\n *\n * Its `filterType` is 'RangedFilter'\n * @name RangedFilter\n * @memberof dc.filters\n * @param {Number} low\n * @param {Number} high\n * @returns {Array<Number>}\n * @constructor\n */\ndc.filters.RangedFilter = function (low, high) {\n    var range = new Array(low, high);\n    range.isFiltered = function (value) {\n        return value >= this[0] && value < this[1];\n    };\n    range.filterType = 'RangedFilter';\n\n    return range;\n};\n\n/**\n * TwoDimensionalFilter is a filter which accepts a single two-dimensional value.  It is used by the\n * {@link dc.heatMap heat map chart} to include particular cells as they are clicked.  (Rows and columns are\n * filtered by filtering all the cells in the row or column.)\n *\n * Its `filterType` is 'TwoDimensionalFilter'\n * @name TwoDimensionalFilter\n * @memberof dc.filters\n * @param {Array<Number>} filter\n * @returns {Array<Number>}\n * @constructor\n */\ndc.filters.TwoDimensionalFilter = function (filter) {\n    if (filter === null) { return null; }\n\n    var f = filter;\n    f.isFiltered = function (value) {\n        return value.length && value.length === f.length &&\n               value[0] === f[0] && value[1] === f[1];\n    };\n    f.filterType = 'TwoDimensionalFilter';\n\n    return f;\n};\n\n/**\n * The RangedTwoDimensionalFilter allows filtering all values which fit within a rectangular\n * region. It is used by the {@link dc.scatterPlot scatter plot} to implement rectangular brushing.\n *\n * It takes two two-dimensional points in the form `[[x1,y1],[x2,y2]]`, and normalizes them so that\n * `x1 <= x2` and `y1 <= y2`. It then returns a filter which accepts any points which are in the\n * rectangular range including the lower values but excluding the higher values.\n *\n * If an array of two values are given to the RangedTwoDimensionalFilter, it interprets the values as\n * two x coordinates `x1` and `x2` and returns a filter which accepts any points for which `x1 <= x <\n * x2`.\n *\n * Its `filterType` is 'RangedTwoDimensionalFilter'\n * @name RangedTwoDimensionalFilter\n * @memberof dc.filters\n * @param {Array<Array<Number>>} filter\n * @returns {Array<Array<Number>>}\n * @constructor\n */\ndc.filters.RangedTwoDimensionalFilter = function (filter) {\n    if (filter === null) { return null; }\n\n    var f = filter;\n    var fromBottomLeft;\n\n    if (f[0] instanceof Array) {\n        fromBottomLeft = [\n            [Math.min(filter[0][0], filter[1][0]), Math.min(filter[0][1], filter[1][1])],\n            [Math.max(filter[0][0], filter[1][0]), Math.max(filter[0][1], filter[1][1])]\n        ];\n    } else {\n        fromBottomLeft = [[filter[0], -Infinity], [filter[1], Infinity]];\n    }\n\n    f.isFiltered = function (value) {\n        var x, y;\n\n        if (value instanceof Array) {\n            x = value[0];\n            y = value[1];\n        } else {\n            x = value;\n            y = fromBottomLeft[0][1];\n        }\n\n        return x >= fromBottomLeft[0][0] && x < fromBottomLeft[1][0] &&\n               y >= fromBottomLeft[0][1] && y < fromBottomLeft[1][1];\n    };\n    f.filterType = 'RangedTwoDimensionalFilter';\n\n    return f;\n};\n\n/**\n * `dc.baseMixin` is an abstract functional object representing a basic `dc` chart object\n * for all chart and widget implementations. Methods from the {@link #dc.baseMixin dc.baseMixin} are inherited\n * and available on all chart implementations in the `dc` library.\n * @name baseMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.baseMixin}\n */\ndc.baseMixin = function (_chart) {\n    _chart.__dcFlag__ = dc.utils.uniqueId();\n\n    var _dimension;\n    var _group;\n\n    var _anchor;\n    var _root;\n    var _svg;\n    var _isChild;\n\n    var _minWidth = 200;\n    var _defaultWidthCalc = function (element) {\n        var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;\n        return (width && width > _minWidth) ? width : _minWidth;\n    };\n    var _widthCalc = _defaultWidthCalc;\n\n    var _minHeight = 200;\n    var _defaultHeightCalc = function (element) {\n        var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;\n        return (height && height > _minHeight) ? height : _minHeight;\n    };\n    var _heightCalc = _defaultHeightCalc;\n    var _width, _height;\n    var _useViewBoxResizing = false;\n\n    var _keyAccessor = dc.pluck('key');\n    var _valueAccessor = dc.pluck('value');\n    var _label = dc.pluck('key');\n\n    var _ordering = dc.pluck('key');\n    var _orderSort;\n\n    var _renderLabel = false;\n\n    var _title = function (d) {\n        return _chart.keyAccessor()(d) + ': ' + _chart.valueAccessor()(d);\n    };\n    var _renderTitle = true;\n    var _controlsUseVisibility = false;\n\n    var _transitionDuration = 750;\n\n    var _transitionDelay = 0;\n\n    var _filterPrinter = dc.printers.filters;\n\n    var _mandatoryAttributes = ['dimension', 'group'];\n\n    var _chartGroup = dc.constants.DEFAULT_CHART_GROUP;\n\n    var _listeners = d3.dispatch(\n        'preRender',\n        'postRender',\n        'preRedraw',\n        'postRedraw',\n        'filtered',\n        'zoomed',\n        'renderlet',\n        'pretransition');\n\n    var _legend;\n    var _commitHandler;\n\n    var _filters = [];\n    var _filterHandler = function (dimension, filters) {\n        if (filters.length === 0) {\n            dimension.filter(null);\n        } else if (filters.length === 1 && !filters[0].isFiltered) {\n            // single value and not a function-based filter\n            dimension.filterExact(filters[0]);\n        } else if (filters.length === 1 && filters[0].filterType === 'RangedFilter') {\n            // single range-based filter\n            dimension.filterRange(filters[0]);\n        } else {\n            dimension.filterFunction(function (d) {\n                for (var i = 0; i < filters.length; i++) {\n                    var filter = filters[i];\n                    if (filter.isFiltered && filter.isFiltered(d)) {\n                        return true;\n                    } else if (filter <= d && filter >= d) {\n                        return true;\n                    }\n                }\n                return false;\n            });\n        }\n        return filters;\n    };\n\n    var _data = function (group) {\n        return group.all();\n    };\n\n    /**\n     * Set or get the height attribute of a chart. The height is applied to the SVGElement generated by\n     * the chart when rendered (or re-rendered). If a value is given, then it will be used to calculate\n     * the new height and the chart returned for method chaining.  The value can either be a numeric, a\n     * function, or falsy. If no value is specified then the value of the current height attribute will\n     * be returned.\n     *\n     * By default, without an explicit height being given, the chart will select the width of its\n     * anchor element. If that isn't possible it defaults to 200 (provided by the\n     * {@link dc.baseMixin#minHeight minHeight} property). Setting the value falsy will return\n     * the chart to the default behavior.\n     * @method height\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#minHeight minHeight}\n     * @example\n     * // Default height\n     * chart.height(function (element) {\n     *     var height = element && element.getBoundingClientRect && element.getBoundingClientRect().height;\n     *     return (height && height > chart.minHeight()) ? height : chart.minHeight();\n     * });\n     *\n     * chart.height(250); // Set the chart's height to 250px;\n     * chart.height(function(anchor) { return doSomethingWith(anchor); }); // set the chart's height with a function\n     * chart.height(null); // reset the height to the default auto calculation\n     * @param {Number|Function} [height]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.height = function (height) {\n        if (!arguments.length) {\n            if (!dc.utils.isNumber(_height)) {\n                // only calculate once\n                _height = _heightCalc(_root.node());\n            }\n            return _height;\n        }\n        _heightCalc = d3.functor(height || _defaultHeightCalc);\n        _height = undefined;\n        return _chart;\n    };\n\n    /**\n     * Set or get the width attribute of a chart.\n     * @method width\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#height height}\n     * @see {@link dc.baseMixin#minWidth minWidth}\n     * @example\n     * // Default width\n     * chart.width(function (element) {\n     *     var width = element && element.getBoundingClientRect && element.getBoundingClientRect().width;\n     *     return (width && width > chart.minWidth()) ? width : chart.minWidth();\n     * });\n     * @param {Number|Function} [width]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.width = function (width) {\n        if (!arguments.length) {\n            if (!dc.utils.isNumber(_width)) {\n                // only calculate once\n                _width = _widthCalc(_root.node());\n            }\n            return _width;\n        }\n        _widthCalc = d3.functor(width || _defaultWidthCalc);\n        _width = undefined;\n        return _chart;\n    };\n\n    /**\n     * Set or get the minimum width attribute of a chart. This only has effect when used with the default\n     * {@link dc.baseMixin#width width} function.\n     * @method minWidth\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#width width}\n     * @param {Number} [minWidth=200]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.minWidth = function (minWidth) {\n        if (!arguments.length) {\n            return _minWidth;\n        }\n        _minWidth = minWidth;\n        return _chart;\n    };\n\n    /**\n     * Set or get the minimum height attribute of a chart. This only has effect when used with the default\n     * {@link dc.baseMixin#height height} function.\n     * @method minHeight\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#height height}\n     * @param {Number} [minHeight=200]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.minHeight = function (minHeight) {\n        if (!arguments.length) {\n            return _minHeight;\n        }\n        _minHeight = minHeight;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off using the SVG\n     * {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox `viewBox` attribute}.\n     * When enabled, `viewBox` will be set on the svg root element instead of `width` and `height`.\n     * Requires that the chart aspect ratio be defined using chart.width(w) and chart.height(h).\n     *\n     * This will maintain the aspect ratio while enabling the chart to resize responsively to the\n     * space given to the chart using CSS. For example, the chart can use `width: 100%; height:\n     * 100%` or absolute positioning to resize to its parent div.\n     *\n     * Since the text will be sized as if the chart is drawn according to the width and height, and\n     * will be resized if the chart is any other size, you need to set the chart width and height so\n     * that the text looks good. In practice, 600x400 seems to work pretty well for most charts.\n     *\n     * You can see examples of this resizing strategy in the [Chart Resizing\n     * Examples](http://dc-js.github.io/dc.js/resizing/); just add `?resize=viewbox` to any of the\n     * one-chart examples to enable `useViewBoxResizing`.\n     * @method useViewBoxResizing\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [useViewBoxResizing=false]\n     * @returns {Boolean|dc.baseMixin}\n     */\n    _chart.useViewBoxResizing = function (useViewBoxResizing) {\n        if (!arguments.length) {\n            return _useViewBoxResizing;\n        }\n        _useViewBoxResizing = useViewBoxResizing;\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Set or get the dimension attribute of a chart. In `dc`, a dimension can be any valid\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension crossfilter dimension}\n     *\n     * If a value is given, then it will be used as the new dimension. If no value is specified then\n     * the current dimension will be returned.\n     * @method dimension\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension crossfilter.dimension}\n     * @example\n     * var index = crossfilter([]);\n     * var dimension = index.dimension(dc.pluck('key'));\n     * chart.dimension(dimension);\n     * @param {crossfilter.dimension} [dimension]\n     * @returns {crossfilter.dimension|dc.baseMixin}\n     */\n    _chart.dimension = function (dimension) {\n        if (!arguments.length) {\n            return _dimension;\n        }\n        _dimension = dimension;\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\n     * Set the data callback or retrieve the chart's data set. The data callback is passed the chart's\n     * group and by default will return\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all}.\n     * This behavior may be modified to, for instance, return only the top 5 groups.\n     * @method data\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // Default data function\n     * chart.data(function (group) { return group.all(); });\n     *\n     * chart.data(function (group) { return group.top(5); });\n     * @param {Function} [callback]\n     * @returns {*|dc.baseMixin}\n     */\n    _chart.data = function (callback) {\n        if (!arguments.length) {\n            return _data.call(_chart, _group);\n        }\n        _data = d3.functor(callback);\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Set or get the group attribute of a chart. In `dc` a group is a\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter group}.\n     * Usually the group should be created from the particular dimension associated with the same chart. If a value is\n     * given, then it will be used as the new group.\n     *\n     * If no value specified then the current group will be returned.\n     * If `name` is specified then it will be used to generate legend label.\n     * @method group\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}\n     * @example\n     * var index = crossfilter([]);\n     * var dimension = index.dimension(dc.pluck('key'));\n     * chart.dimension(dimension);\n     * chart.group(dimension.group(crossfilter.reduceSum()));\n     * @param {crossfilter.group} [group]\n     * @param {String} [name]\n     * @returns {crossfilter.group|dc.baseMixin}\n     */\n    _chart.group = function (group, name) {\n        if (!arguments.length) {\n            return _group;\n        }\n        _group = group;\n        _chart._groupName = name;\n        _chart.expireCache();\n        return _chart;\n    };\n\n    /**\n     * Get or set an accessor to order ordinal dimensions.  The chart uses\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}\n     * to sort elements; this accessor returns the value to order on.\n     * @method ordering\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#quicksort_by crossfilter.quicksort.by}\n     * @example\n     * // Default ordering accessor\n     * _chart.ordering(dc.pluck('key'));\n     * @param {Function} [orderFunction]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.ordering = function (orderFunction) {\n        if (!arguments.length) {\n            return _ordering;\n        }\n        _ordering = orderFunction;\n        _orderSort = crossfilter.quicksort.by(_ordering);\n        _chart.expireCache();\n        return _chart;\n    };\n\n    _chart._computeOrderedGroups = function (data) {\n        var dataCopy = data.slice(0);\n\n        if (dataCopy.length <= 1) {\n            return dataCopy;\n        }\n\n        if (!_orderSort) {\n            _orderSort = crossfilter.quicksort.by(_ordering);\n        }\n\n        return _orderSort(dataCopy, 0, dataCopy.length);\n    };\n\n    /**\n     * Clear all filters associated with this chart. The same effect can be achieved by calling\n     * {@link dc.baseMixin#filter chart.filter(null)}.\n     * @method filterAll\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.filterAll = function () {\n        return _chart.filter(null);\n    };\n\n    /**\n     * Execute d3 single selection in the chart's scope using the given selector and return the d3\n     * selection.\n     *\n     * This function is **not chainable** since it does not return a chart instance; however the d3\n     * selection result can be chained to d3 function calls.\n     * @method select\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#d3_select d3.select}\n     * @example\n     * // Has the same effect as d3.select('#chart-id').select(selector)\n     * chart.select(selector)\n     * @returns {d3.selection}\n     */\n    _chart.select = function (s) {\n        return _root.select(s);\n    };\n\n    /**\n     * Execute in scope d3 selectAll using the given selector and return d3 selection result.\n     *\n     * This function is **not chainable** since it does not return a chart instance; however the d3\n     * selection result can be chained to d3 function calls.\n     * @method selectAll\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#d3_selectAll d3.selectAll}\n     * @example\n     * // Has the same effect as d3.select('#chart-id').selectAll(selector)\n     * chart.selectAll(selector)\n     * @returns {d3.selection}\n     */\n    _chart.selectAll = function (s) {\n        return _root ? _root.selectAll(s) : null;\n    };\n\n    /**\n     * Set the root SVGElement to either be an existing chart's root; or any valid [d3 single\n     * selector](https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements) specifying a dom\n     * block element such as a div; or a dom element or d3 selection. Optionally registers the chart\n     * within the chartGroup. This class is called internally on chart initialization, but be called\n     * again to relocate the chart. However, it will orphan any previously created SVGElements.\n     * @method anchor\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {anchorChart|anchorSelector|anchorNode} [parent]\n     * @param {String} [chartGroup]\n     * @returns {String|node|d3.selection|dc.baseMixin}\n     */\n    _chart.anchor = function (parent, chartGroup) {\n        if (!arguments.length) {\n            return _anchor;\n        }\n        if (dc.instanceOfChart(parent)) {\n            _anchor = parent.anchor();\n            _root = parent.root();\n            _isChild = true;\n        } else if (parent) {\n            if (parent.select && parent.classed) { // detect d3 selection\n                _anchor = parent.node();\n            } else {\n                _anchor = parent;\n            }\n            _root = d3.select(_anchor);\n            _root.classed(dc.constants.CHART_CLASS, true);\n            dc.registerChart(_chart, chartGroup);\n            _isChild = false;\n        } else {\n            throw new dc.errors.BadArgumentException('parent must be defined');\n        }\n        _chartGroup = chartGroup;\n        return _chart;\n    };\n\n    /**\n     * Returns the DOM id for the chart's anchored location.\n     * @method anchorName\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {String}\n     */\n    _chart.anchorName = function () {\n        var a = _chart.anchor();\n        if (a && a.id) {\n            return a.id;\n        }\n        if (a && a.replace) {\n            return a.replace('#', '');\n        }\n        return 'dc-chart' + _chart.chartID();\n    };\n\n    /**\n     * Returns the root element where a chart resides. Usually it will be the parent div element where\n     * the SVGElement was created. You can also pass in a new root element however this is usually handled by\n     * dc internally. Resetting the root element on a chart outside of dc internals may have\n     * unexpected consequences.\n     * @method root\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement HTMLElement}\n     * @param {HTMLElement} [rootElement]\n     * @returns {HTMLElement|dc.baseMixin}\n     */\n    _chart.root = function (rootElement) {\n        if (!arguments.length) {\n            return _root;\n        }\n        _root = rootElement;\n        return _chart;\n    };\n\n    /**\n     * Returns the top SVGElement for this specific chart. You can also pass in a new SVGElement,\n     * however this is usually handled by dc internally. Resetting the SVGElement on a chart outside\n     * of dc internals may have unexpected consequences.\n     * @method svg\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}\n     * @param {SVGElement|d3.selection} [svgElement]\n     * @returns {SVGElement|d3.selection|dc.baseMixin}\n     */\n    _chart.svg = function (svgElement) {\n        if (!arguments.length) {\n            return _svg;\n        }\n        _svg = svgElement;\n        return _chart;\n    };\n\n    /**\n     * Remove the chart's SVGElements from the dom and recreate the container SVGElement.\n     * @method resetSvg\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SVGElement SVGElement}\n     * @returns {SVGElement}\n     */\n    _chart.resetSvg = function () {\n        _chart.select('svg').remove();\n        return generateSvg();\n    };\n\n    function sizeSvg () {\n        if (_svg) {\n            if (!_useViewBoxResizing) {\n                _svg\n                    .attr('width', _chart.width())\n                    .attr('height', _chart.height());\n            } else if (!_svg.attr('viewBox')) {\n                _svg\n                    .attr('viewBox', '0 0 ' + _chart.width() + ' ' + _chart.height());\n            }\n        }\n    }\n\n    function generateSvg () {\n        _svg = _chart.root().append('svg');\n        sizeSvg();\n        return _svg;\n    }\n\n    /**\n     * Set or get the filter printer function. The filter printer function is used to generate human\n     * friendly text for filter value(s) associated with the chart instance. The text will get shown\n     * in the `.filter element; see {@link dc.baseMixin#turnOnControls turnOnControls}.\n     *\n     * By default dc charts use a default filter printer {@link dc.printers.filters dc.printers.filters}\n     * that provides simple printing support for both single value and ranged filters.\n     * @method filterPrinter\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // for a chart with an ordinal brush, print the filters in upper case\n     * chart.filterPrinter(function(filters) {\n     *   return filters.map(function(f) { return f.toUpperCase(); }).join(', ');\n     * });\n     * // for a chart with a range brush, print the filter as start and extent\n     * chart.filterPrinter(function(filters) {\n     *   return 'start ' + dc.utils.printSingleValue(filters[0][0]) +\n     *     ' extent ' + dc.utils.printSingleValue(filters[0][1] - filters[0][0]);\n     * });\n     * @param {Function} [filterPrinterFunction=dc.printers.filters]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.filterPrinter = function (filterPrinterFunction) {\n        if (!arguments.length) {\n            return _filterPrinter;\n        }\n        _filterPrinter = filterPrinterFunction;\n        return _chart;\n    };\n\n    /**\n     * If set, use the `visibility` attribute instead of the `display` attribute for showing/hiding\n     * chart reset and filter controls, for less disruption to the layout.\n     * @method controlsUseVisibility\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [controlsUseVisibility=false]\n     * @returns {Boolean|dc.baseMixin}\n     **/\n    _chart.controlsUseVisibility = function (useVisibility) {\n        if (!arguments.length) {\n            return _controlsUseVisibility;\n        }\n        _controlsUseVisibility = useVisibility;\n        return _chart;\n    };\n\n    /**\n     * Turn on optional control elements within the root element. dc currently supports the\n     * following html control elements.\n     * * root.selectAll('.reset') - elements are turned on if the chart has an active filter. This type\n     * of control element is usually used to store a reset link to allow user to reset filter on a\n     * certain chart. This element will be turned off automatically if the filter is cleared.\n     * * root.selectAll('.filter') elements are turned on if the chart has an active filter. The text\n     * content of this element is then replaced with the current filter value using the filter printer\n     * function. This type of element will be turned off automatically if the filter is cleared.\n     * @method turnOnControls\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.turnOnControls = function () {\n        if (_root) {\n            var attribute = _chart.controlsUseVisibility() ? 'visibility' : 'display';\n            _chart.selectAll('.reset').style(attribute, null);\n            _chart.selectAll('.filter').text(_filterPrinter(_chart.filters())).style(attribute, null);\n        }\n        return _chart;\n    };\n\n    /**\n     * Turn off optional control elements within the root element.\n     * @method turnOffControls\n     * @memberof dc.baseMixin\n     * @see {@link dc.baseMixin#turnOnControls turnOnControls}\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.turnOffControls = function () {\n        if (_root) {\n            var attribute = _chart.controlsUseVisibility() ? 'visibility' : 'display';\n            var value = _chart.controlsUseVisibility() ? 'hidden' : 'none';\n            _chart.selectAll('.reset').style(attribute, value);\n            _chart.selectAll('.filter').style(attribute, value).text(_chart.filter());\n        }\n        return _chart;\n    };\n\n    /**\n     * Set or get the animation transition duration (in milliseconds) for this chart instance.\n     * @method transitionDuration\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Number} [duration=750]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.transitionDuration = function (duration) {\n        if (!arguments.length) {\n            return _transitionDuration;\n        }\n        _transitionDuration = duration;\n        return _chart;\n    };\n\n    /**\n     * Set or get the animation transition delay (in milliseconds) for this chart instance.\n     * @method transitionDelay\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Number} [delay=0]\n     * @returns {Number|dc.baseMixin}\n     */\n    _chart.transitionDelay = function (delay) {\n        if (!arguments.length) {\n            return _transitionDelay;\n        }\n        _transitionDelay = delay;\n        return _chart;\n    };\n\n    _chart._mandatoryAttributes = function (_) {\n        if (!arguments.length) {\n            return _mandatoryAttributes;\n        }\n        _mandatoryAttributes = _;\n        return _chart;\n    };\n\n    function checkForMandatoryAttributes (a) {\n        if (!_chart[a] || !_chart[a]()) {\n            throw new dc.errors.InvalidStateException('Mandatory attribute chart.' + a +\n                ' is missing on chart[#' + _chart.anchorName() + ']');\n        }\n    }\n\n    /**\n     * Invoking this method will force the chart to re-render everything from scratch. Generally it\n     * should only be used to render the chart for the first time on the page or if you want to make\n     * sure everything is redrawn from scratch instead of relying on the default incremental redrawing\n     * behaviour.\n     * @method render\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.render = function () {\n        _height = _width = undefined; // force recalculate\n        _listeners.preRender(_chart);\n\n        if (_mandatoryAttributes) {\n            _mandatoryAttributes.forEach(checkForMandatoryAttributes);\n        }\n\n        var result = _chart._doRender();\n\n        if (_legend) {\n            _legend.render();\n        }\n\n        _chart._activateRenderlets('postRender');\n\n        return result;\n    };\n\n    _chart._activateRenderlets = function (event) {\n        _listeners.pretransition(_chart);\n        if (_chart.transitionDuration() > 0 && _svg) {\n            _svg.transition().duration(_chart.transitionDuration()).delay(_chart.transitionDelay())\n                .each('end', function () {\n                    _listeners.renderlet(_chart);\n                    if (event) {\n                        _listeners[event](_chart);\n                    }\n                });\n        } else {\n            _listeners.renderlet(_chart);\n            if (event) {\n                _listeners[event](_chart);\n            }\n        }\n    };\n\n    /**\n     * Calling redraw will cause the chart to re-render data changes incrementally. If there is no\n     * change in the underlying data dimension then calling this method will have no effect on the\n     * chart. Most chart interaction in dc will automatically trigger this method through internal\n     * events (in particular {@link dc.redrawAll dc.redrawAll}); therefore, you only need to\n     * manually invoke this function if data is manipulated outside of dc's control (for example if\n     * data is loaded in the background using\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}).\n     * @method redraw\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.redraw = function () {\n        sizeSvg();\n        _listeners.preRedraw(_chart);\n\n        var result = _chart._doRedraw();\n\n        if (_legend) {\n            _legend.render();\n        }\n\n        _chart._activateRenderlets('postRedraw');\n\n        return result;\n    };\n\n    /**\n     * Gets/sets the commit handler. If the chart has a commit handler, the handler will be called when\n     * the chart's filters have changed, in order to send the filter data asynchronously to a server.\n     *\n     * Unlike other functions in dc.js, the commit handler is asynchronous. It takes two arguments:\n     * a flag indicating whether this is a render (true) or a redraw (false), and a callback to be\n     * triggered once the commit is filtered. The callback has the standard node.js continuation signature\n     * with error first and result second.\n     * @method commitHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.commitHandler = function (commitHandler) {\n        if (!arguments.length) {\n            return _commitHandler;\n        }\n        _commitHandler = commitHandler;\n        return _chart;\n    };\n\n    /**\n     * Redraws all charts in the same group as this chart, typically in reaction to a filter\n     * change. If the chart has a {@link dc.baseMixin.commitFilter commitHandler}, it will\n     * be executed and waited for.\n     * @method redrawGroup\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.redrawGroup = function () {\n        if (_commitHandler) {\n            _commitHandler(false, function (error, result) {\n                if (error) {\n                    console.log(error);\n                } else {\n                    dc.redrawAll(_chart.chartGroup());\n                }\n            });\n        } else {\n            dc.redrawAll(_chart.chartGroup());\n        }\n        return _chart;\n    };\n\n    /**\n     * Renders all charts in the same group as this chart. If the chart has a\n     * {@link dc.baseMixin.commitFilter commitHandler}, it will be executed and waited for\n     * @method renderGroup\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.renderGroup = function () {\n        if (_commitHandler) {\n            _commitHandler(false, function (error, result) {\n                if (error) {\n                    console.log(error);\n                } else {\n                    dc.renderAll(_chart.chartGroup());\n                }\n            });\n        } else {\n            dc.renderAll(_chart.chartGroup());\n        }\n        return _chart;\n    };\n\n    _chart._invokeFilteredListener = function (f) {\n        if (f !== undefined) {\n            _listeners.filtered(_chart, f);\n        }\n    };\n\n    _chart._invokeZoomedListener = function () {\n        _listeners.zoomed(_chart);\n    };\n\n    var _hasFilterHandler = function (filters, filter) {\n        if (filter === null || typeof(filter) === 'undefined') {\n            return filters.length > 0;\n        }\n        return filters.some(function (f) {\n            return filter <= f && filter >= f;\n        });\n    };\n\n    /**\n     * Set or get the has-filter handler. The has-filter handler is a function that checks to see if\n     * the chart's current filters (first argument) include a specific filter (second argument).  Using a custom has-filter handler allows\n     * you to change the way filters are checked for and replaced.\n     * @method hasFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default has-filter handler\n     * chart.hasFilterHandler(function (filters, filter) {\n     *     if (filter === null || typeof(filter) === 'undefined') {\n     *         return filters.length > 0;\n     *     }\n     *     return filters.some(function (f) {\n     *         return filter <= f && filter >= f;\n     *     });\n     * });\n     *\n     * // custom filter handler (no-op)\n     * chart.hasFilterHandler(function(filters, filter) {\n     *     return false;\n     * });\n     * @param {Function} [hasFilterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.hasFilterHandler = function (hasFilterHandler) {\n        if (!arguments.length) {\n            return _hasFilterHandler;\n        }\n        _hasFilterHandler = hasFilterHandler;\n        return _chart;\n    };\n\n    /**\n     * Check whether any active filter or a specific filter is associated with particular chart instance.\n     * This function is **not chainable**.\n     * @method hasFilter\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#hasFilterHandler hasFilterHandler}\n     * @param {*} [filter]\n     * @returns {Boolean}\n     */\n    _chart.hasFilter = function (filter) {\n        return _hasFilterHandler(_filters, filter);\n    };\n\n    var _removeFilterHandler = function (filters, filter) {\n        for (var i = 0; i < filters.length; i++) {\n            if (filters[i] <= filter && filters[i] >= filter) {\n                filters.splice(i, 1);\n                break;\n            }\n        }\n        return filters;\n    };\n\n    /**\n     * Set or get the remove filter handler. The remove filter handler is a function that removes a\n     * filter from the chart's current filters. Using a custom remove filter handler allows you to\n     * change how filters are removed or perform additional work when removing a filter, e.g. when\n     * using a filter server other than crossfilter.\n     *\n     * The handler should return a new or modified array as the result.\n     * @method removeFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default remove filter handler\n     * chart.removeFilterHandler(function (filters, filter) {\n     *     for (var i = 0; i < filters.length; i++) {\n     *         if (filters[i] <= filter && filters[i] >= filter) {\n     *             filters.splice(i, 1);\n     *             break;\n     *         }\n     *     }\n     *     return filters;\n     * });\n     *\n     * // custom filter handler (no-op)\n     * chart.removeFilterHandler(function(filters, filter) {\n     *     return filters;\n     * });\n     * @param {Function} [removeFilterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.removeFilterHandler = function (removeFilterHandler) {\n        if (!arguments.length) {\n            return _removeFilterHandler;\n        }\n        _removeFilterHandler = removeFilterHandler;\n        return _chart;\n    };\n\n    var _addFilterHandler = function (filters, filter) {\n        filters.push(filter);\n        return filters;\n    };\n\n    /**\n     * Set or get the add filter handler. The add filter handler is a function that adds a filter to\n     * the chart's filter list. Using a custom add filter handler allows you to change the way filters\n     * are added or perform additional work when adding a filter, e.g. when using a filter server other\n     * than crossfilter.\n     *\n     * The handler should return a new or modified array as the result.\n     * @method addFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default add filter handler\n     * chart.addFilterHandler(function (filters, filter) {\n     *     filters.push(filter);\n     *     return filters;\n     * });\n     *\n     * // custom filter handler (no-op)\n     * chart.addFilterHandler(function(filters, filter) {\n     *     return filters;\n     * });\n     * @param {Function} [addFilterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.addFilterHandler = function (addFilterHandler) {\n        if (!arguments.length) {\n            return _addFilterHandler;\n        }\n        _addFilterHandler = addFilterHandler;\n        return _chart;\n    };\n\n    var _resetFilterHandler = function (filters) {\n        return [];\n    };\n\n    /**\n     * Set or get the reset filter handler. The reset filter handler is a function that resets the\n     * chart's filter list by returning a new list. Using a custom reset filter handler allows you to\n     * change the way filters are reset, or perform additional work when resetting the filters,\n     * e.g. when using a filter server other than crossfilter.\n     *\n     * The handler should return a new or modified array as the result.\n     * @method resetFilterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default remove filter handler\n     * function (filters) {\n     *     return [];\n     * }\n     *\n     * // custom filter handler (no-op)\n     * chart.resetFilterHandler(function(filters) {\n     *     return filters;\n     * });\n     * @param {Function} [resetFilterHandler]\n     * @returns {dc.baseMixin}\n     */\n    _chart.resetFilterHandler = function (resetFilterHandler) {\n        if (!arguments.length) {\n            return _resetFilterHandler;\n        }\n        _resetFilterHandler = resetFilterHandler;\n        return _chart;\n    };\n\n    function applyFilters (filters) {\n        if (_chart.dimension() && _chart.dimension().filter) {\n            var fs = _filterHandler(_chart.dimension(), filters);\n            if (fs) {\n                filters = fs;\n            }\n        }\n        return filters;\n    }\n\n    /**\n     * Replace the chart filter. This is equivalent to calling `chart.filter(null).filter(filter)`\n     * but more efficient because the filter is only applied once.\n     *\n     * @method replaceFilter\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {*} [filter]\n     * @returns {dc.baseMixin}\n     **/\n    _chart.replaceFilter = function (filter) {\n        _filters = _resetFilterHandler(_filters);\n        _chart.filter(filter);\n        return _chart;\n    };\n\n    /**\n     * Filter the chart by the given parameter, or return the current filter if no input parameter\n     * is given.\n     *\n     * The filter parameter can take one of these forms:\n     * * A single value: the value will be toggled (added if it is not present in the current\n     * filters, removed if it is present)\n     * * An array containing a single array of values (`[[value,value,value]]`): each value is\n     * toggled\n     * * When appropriate for the chart, a {@link dc.filters dc filter object} such as\n     *   * {@link dc.filters.RangedFilter `dc.filters.RangedFilter`} for the\n     * {@link dc.coordinateGridMixin dc.coordinateGridMixin} charts\n     *   * {@link dc.filters.TwoDimensionalFilter `dc.filters.TwoDimensionalFilter`} for the\n     * {@link dc.heatMap heat map}\n     *   * {@link dc.filters.RangedTwoDimensionalFilter `dc.filters.RangedTwoDimensionalFilter`}\n     * for the {@link dc.scatterPlot scatter plot}\n     * * `null`: the filter will be reset using the\n     * {@link dc.baseMixin#resetFilterHandler resetFilterHandler}\n     *\n     * Note that this is always a toggle (even when it doesn't make sense for the filter type). If\n     * you wish to replace the current filter, either call `chart.filter(null)` first - or it's more\n     * efficient to call {@link dc.baseMixin#replaceFilter `chart.replaceFilter(filter)`} instead.\n     *\n     * Each toggle is executed by checking if the value is already present using the\n     * {@link dc.baseMixin#hasFilterHandler hasFilterHandler}; if it is not present, it is added\n     * using the {@link dc.baseMixin#addFilterHandler addFilterHandler}; if it is already present,\n     * it is removed using the {@link dc.baseMixin#removeFilterHandler removeFilterHandler}.\n     *\n     * Once the filters array has been updated, the filters are applied to the\n     * crossfilter dimension, using the {@link dc.baseMixin#filterHandler filterHandler}.\n     *\n     * Once you have set the filters, call {@link dc.baseMixin#redrawGroup `chart.redrawGroup()`}\n     * (or {@link dc.redrawAll `dc.redrawAll()`}) to redraw the chart's group.\n     * @method filter\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link dc.baseMixin#addFilterHandler addFilterHandler}\n     * @see {@link dc.baseMixin#removeFilterHandler removeFilterHandler}\n     * @see {@link dc.baseMixin#resetFilterHandler resetFilterHandler}\n     * @see {@link dc.baseMixin#filterHandler filterHandler}\n     * @example\n     * // filter by a single string\n     * chart.filter('Sunday');\n     * // filter by a single age\n     * chart.filter(18);\n     * // filter by a set of states\n     * chart.filter([['MA', 'TX', 'ND', 'WA']]);\n     * // filter by range -- note the use of dc.filters.RangedFilter, which is different\n     * // from the syntax for filtering a crossfilter dimension directly, dimension.filter([15,20])\n     * chart.filter(dc.filters.RangedFilter(15,20));\n     * @param {*} [filter]\n     * @returns {dc.baseMixin}\n     */\n    _chart.filter = function (filter) {\n        if (!arguments.length) {\n            return _filters.length > 0 ? _filters[0] : null;\n        }\n        var filters = _filters;\n        if (filter instanceof Array && filter[0] instanceof Array && !filter.isFiltered) {\n            // toggle each filter\n            filter[0].forEach(function (f) {\n                if (_hasFilterHandler(filters, f)) {\n                    filters = _removeFilterHandler(filters, f);\n                } else {\n                    filters = _addFilterHandler(filters, f);\n                }\n            });\n        } else if (filter === null) {\n            filters = _resetFilterHandler(filters);\n        } else {\n            if (_hasFilterHandler(filters, filter)) {\n                filters = _removeFilterHandler(filters, filter);\n            } else {\n                filters = _addFilterHandler(filters, filter);\n            }\n        }\n        _filters = applyFilters(filters);\n        _chart._invokeFilteredListener(filter);\n\n        if (_root !== null && _chart.hasFilter()) {\n            _chart.turnOnControls();\n        } else {\n            _chart.turnOffControls();\n        }\n\n        return _chart;\n    };\n\n    /**\n     * Returns all current filters. This method does not perform defensive cloning of the internal\n     * filter array before returning, therefore any modification of the returned array will effect the\n     * chart's internal filter storage.\n     * @method filters\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {Array<*>}\n     */\n    _chart.filters = function () {\n        return _filters;\n    };\n\n    _chart.highlightSelected = function (e) {\n        d3.select(e).classed(dc.constants.SELECTED_CLASS, true);\n        d3.select(e).classed(dc.constants.DESELECTED_CLASS, false);\n    };\n\n    _chart.fadeDeselected = function (e) {\n        d3.select(e).classed(dc.constants.SELECTED_CLASS, false);\n        d3.select(e).classed(dc.constants.DESELECTED_CLASS, true);\n    };\n\n    _chart.resetHighlight = function (e) {\n        d3.select(e).classed(dc.constants.SELECTED_CLASS, false);\n        d3.select(e).classed(dc.constants.DESELECTED_CLASS, false);\n    };\n\n    /**\n     * This function is passed to d3 as the onClick handler for each chart. The default behavior is to\n     * filter on the clicked datum (passed to the callback) and redraw the chart group.\n     * @method onClick\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {*} datum\n     */\n    _chart.onClick = function (datum) {\n        var filter = _chart.keyAccessor()(datum);\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    /**\n     * Set or get the filter handler. The filter handler is a function that performs the filter action\n     * on a specific dimension. Using a custom filter handler allows you to perform additional logic\n     * before or after filtering.\n     * @method filterHandler\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension_filter crossfilter.dimension.filter}\n     * @example\n     * // the default filter handler handles all possible cases for the charts in dc.js\n     * // you can replace it with something more specialized for your own chart\n     * chart.filterHandler(function (dimension, filters) {\n     *     if (filters.length === 0) {\n     *         // the empty case (no filtering)\n     *         dimension.filter(null);\n     *     } else if (filters.length === 1 && !filters[0].isFiltered) {\n     *         // single value and not a function-based filter\n     *         dimension.filterExact(filters[0]);\n     *     } else if (filters.length === 1 && filters[0].filterType === 'RangedFilter') {\n     *         // single range-based filter\n     *         dimension.filterRange(filters[0]);\n     *     } else {\n     *         // an array of values, or an array of filter objects\n     *         dimension.filterFunction(function (d) {\n     *             for (var i = 0; i < filters.length; i++) {\n     *                 var filter = filters[i];\n     *                 if (filter.isFiltered && filter.isFiltered(d)) {\n     *                     return true;\n     *                 } else if (filter <= d && filter >= d) {\n     *                     return true;\n     *                 }\n     *             }\n     *             return false;\n     *         });\n     *     }\n     *     return filters;\n     * });\n     *\n     * // custom filter handler\n     * chart.filterHandler(function(dimension, filter){\n     *     var newFilter = filter + 10;\n     *     dimension.filter(newFilter);\n     *     return newFilter; // set the actual filter value to the new value\n     * });\n     * @param {Function} [filterHandler]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.filterHandler = function (filterHandler) {\n        if (!arguments.length) {\n            return _filterHandler;\n        }\n        _filterHandler = filterHandler;\n        return _chart;\n    };\n\n    // abstract function stub\n    _chart._doRender = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    _chart.legendables = function () {\n        // do nothing in base, should be overridden by sub-function\n        return [];\n    };\n\n    _chart.legendHighlight = function () {\n        // do nothing in base, should be overridden by sub-function\n    };\n\n    _chart.legendReset = function () {\n        // do nothing in base, should be overridden by sub-function\n    };\n\n    _chart.legendToggle = function () {\n        // do nothing in base, should be overriden by sub-function\n    };\n\n    _chart.isLegendableHidden = function () {\n        // do nothing in base, should be overridden by sub-function\n        return false;\n    };\n\n    /**\n     * Set or get the key accessor function. The key accessor function is used to retrieve the key\n     * value from the crossfilter group. Key values are used differently in different charts, for\n     * example keys correspond to slices in a pie chart and x axis positions in a grid coordinate chart.\n     * @method keyAccessor\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default key accessor\n     * chart.keyAccessor(function(d) { return d.key; });\n     * // custom key accessor for a multi-value crossfilter reduction\n     * chart.keyAccessor(function(p) { return p.value.absGain; });\n     * @param {Function} [keyAccessor]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.keyAccessor = function (keyAccessor) {\n        if (!arguments.length) {\n            return _keyAccessor;\n        }\n        _keyAccessor = keyAccessor;\n        return _chart;\n    };\n\n    /**\n     * Set or get the value accessor function. The value accessor function is used to retrieve the\n     * value from the crossfilter group. Group values are used differently in different charts, for\n     * example values correspond to slice sizes in a pie chart and y axis positions in a grid\n     * coordinate chart.\n     * @method valueAccessor\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default value accessor\n     * chart.valueAccessor(function(d) { return d.value; });\n     * // custom value accessor for a multi-value crossfilter reduction\n     * chart.valueAccessor(function(p) { return p.value.percentageGain; });\n     * @param {Function} [valueAccessor]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.valueAccessor = function (valueAccessor) {\n        if (!arguments.length) {\n            return _valueAccessor;\n        }\n        _valueAccessor = valueAccessor;\n        return _chart;\n    };\n\n    /**\n     * Set or get the label function. The chart class will use this function to render labels for each\n     * child element in the chart, e.g. slices in a pie chart or bubbles in a bubble chart. Not every\n     * chart supports the label function, for example line chart does not use this function\n     * at all. By default, enables labels; pass false for the second parameter if this is not desired.\n     * @method label\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default label function just return the key\n     * chart.label(function(d) { return d.key; });\n     * // label function has access to the standard d3 data binding and can get quite complicated\n     * chart.label(function(d) { return d.data.key + '(' + Math.floor(d.data.value / all.value() * 100) + '%)'; });\n     * @param {Function} [labelFunction]\n     * @param {Boolean} [enableLabels=true]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.label = function (labelFunction, enableLabels) {\n        if (!arguments.length) {\n            return _label;\n        }\n        _label = labelFunction;\n        if ((enableLabels === undefined) || enableLabels) {\n            _renderLabel = true;\n        }\n        return _chart;\n    };\n\n    /**\n     * Turn on/off label rendering\n     * @method renderLabel\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [renderLabel=false]\n     * @returns {Boolean|dc.baseMixin}\n     */\n    _chart.renderLabel = function (renderLabel) {\n        if (!arguments.length) {\n            return _renderLabel;\n        }\n        _renderLabel = renderLabel;\n        return _chart;\n    };\n\n    /**\n     * Set or get the title function. The chart class will use this function to render the SVGElement title\n     * (usually interpreted by browser as tooltips) for each child element in the chart, e.g. a slice\n     * in a pie chart or a bubble in a bubble chart. Almost every chart supports the title function;\n     * however in grid coordinate charts you need to turn off the brush in order to see titles, because\n     * otherwise the brush layer will block tooltip triggering.\n     * @method title\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * // default title function shows \"key: value\"\n     * chart.title(function(d) { return d.key + ': ' + d.value; });\n     * // title function has access to the standard d3 data binding and can get quite complicated\n     * chart.title(function(p) {\n     *    return p.key.getFullYear()\n     *        + '\\n'\n     *        + 'Index Gain: ' + numberFormat(p.value.absGain) + '\\n'\n     *        + 'Index Gain in Percentage: ' + numberFormat(p.value.percentageGain) + '%\\n'\n     *        + 'Fluctuation / Index Ratio: ' + numberFormat(p.value.fluctuationPercentage) + '%';\n     * });\n     * @param {Function} [titleFunction]\n     * @returns {Function|dc.baseMixin}\n     */\n    _chart.title = function (titleFunction) {\n        if (!arguments.length) {\n            return _title;\n        }\n        _title = titleFunction;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off title rendering, or return the state of the render title flag if no arguments are\n     * given.\n     * @method renderTitle\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {Boolean} [renderTitle=true]\n     * @returns {Boolean|dc.baseMixin}\n     */\n    _chart.renderTitle = function (renderTitle) {\n        if (!arguments.length) {\n            return _renderTitle;\n        }\n        _renderTitle = renderTitle;\n        return _chart;\n    };\n\n    /**\n     * A renderlet is similar to an event listener on rendering event. Multiple renderlets can be added\n     * to an individual chart.  Each time a chart is rerendered or redrawn the renderlets are invoked\n     * right after the chart finishes its transitions, giving you a way to modify the SVGElements.\n     * Renderlet functions take the chart instance as the only input parameter and you can\n     * use the dc API or use raw d3 to achieve pretty much any effect.\n     *\n     * Use {@link dc.baseMixin#on on} with a 'renderlet' prefix.\n     * Generates a random key for the renderlet, which makes it hard to remove.\n     * @method renderlet\n     * @memberof dc.baseMixin\n     * @instance\n     * @deprecated\n     * @example\n     * // do this instead of .renderlet(function(chart) { ... })\n     * chart.on(\"renderlet\", function(chart){\n     *     // mix of dc API and d3 manipulation\n     *     chart.select('g.y').style('display', 'none');\n     *     // its a closure so you can also access other chart variable available in the closure scope\n     *     moveChart.filter(chart.filter());\n     * });\n     * @param {Function} renderletFunction\n     * @returns {dc.baseMixin}\n     */\n    _chart.renderlet = dc.logger.deprecate(function (renderletFunction) {\n        _chart.on('renderlet.' + dc.utils.uniqueId(), renderletFunction);\n        return _chart;\n    }, 'chart.renderlet has been deprecated.  Please use chart.on(\"renderlet.<renderletKey>\", renderletFunction)');\n\n    /**\n     * Get or set the chart group to which this chart belongs. Chart groups are rendered or redrawn\n     * together since it is expected they share the same underlying crossfilter data set.\n     * @method chartGroup\n     * @memberof dc.baseMixin\n     * @instance\n     * @param {String} [chartGroup]\n     * @returns {String|dc.baseMixin}\n     */\n    _chart.chartGroup = function (chartGroup) {\n        if (!arguments.length) {\n            return _chartGroup;\n        }\n        if (!_isChild) {\n            dc.deregisterChart(_chart, _chartGroup);\n        }\n        _chartGroup = chartGroup;\n        if (!_isChild) {\n            dc.registerChart(_chart, _chartGroup);\n        }\n        return _chart;\n    };\n\n    /**\n     * Expire the internal chart cache. dc charts cache some data internally on a per chart basis to\n     * speed up rendering and avoid unnecessary calculation; however it might be useful to clear the\n     * cache if you have changed state which will affect rendering.  For example, if you invoke\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#crossfilter_add crossfilter.add}\n     * function or reset group or dimension after rendering, it is a good idea to\n     * clear the cache to make sure charts are rendered properly.\n     * @method expireCache\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {dc.baseMixin}\n     */\n    _chart.expireCache = function () {\n        // do nothing in base, should be overridden by sub-function\n        return _chart;\n    };\n\n    /**\n     * Attach a dc.legend widget to this chart. The legend widget will automatically draw legend labels\n     * based on the color setting and names associated with each group.\n     * @method legend\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))\n     * @param {dc.legend} [legend]\n     * @returns {dc.legend|dc.baseMixin}\n     */\n    _chart.legend = function (legend) {\n        if (!arguments.length) {\n            return _legend;\n        }\n        _legend = legend;\n        _legend.parent(_chart);\n        return _chart;\n    };\n\n    /**\n     * Returns the internal numeric ID of the chart.\n     * @method chartID\n     * @memberof dc.baseMixin\n     * @instance\n     * @returns {String}\n     */\n    _chart.chartID = function () {\n        return _chart.__dcFlag__;\n    };\n\n    /**\n     * Set chart options using a configuration object. Each key in the object will cause the method of\n     * the same name to be called with the value to set that attribute for the chart.\n     * @method options\n     * @memberof dc.baseMixin\n     * @instance\n     * @example\n     * chart.options({dimension: myDimension, group: myGroup});\n     * @param {{}} opts\n     * @returns {dc.baseMixin}\n     */\n    _chart.options = function (opts) {\n        var applyOptions = [\n            'anchor',\n            'group',\n            'xAxisLabel',\n            'yAxisLabel',\n            'stack',\n            'title',\n            'point',\n            'getColor',\n            'overlayGeoJson'\n        ];\n\n        for (var o in opts) {\n            if (typeof(_chart[o]) === 'function') {\n                if (opts[o] instanceof Array && applyOptions.indexOf(o) !== -1) {\n                    _chart[o].apply(_chart, opts[o]);\n                } else {\n                    _chart[o].call(_chart, opts[o]);\n                }\n            } else {\n                dc.logger.debug('Not a valid option setter name: ' + o);\n            }\n        }\n        return _chart;\n    };\n\n    /**\n     * All dc chart instance supports the following listeners.\n     * Supports the following events:\n     * * `renderlet` - This listener function will be invoked after transitions after redraw and render. Replaces the\n     * deprecated {@link dc.baseMixin#renderlet renderlet} method.\n     * * `pretransition` - Like `.on('renderlet', ...)` but the event is fired before transitions start.\n     * * `preRender` - This listener function will be invoked before chart rendering.\n     * * `postRender` - This listener function will be invoked after chart finish rendering including\n     * all renderlets' logic.\n     * * `preRedraw` - This listener function will be invoked before chart redrawing.\n     * * `postRedraw` - This listener function will be invoked after chart finish redrawing\n     * including all renderlets' logic.\n     * * `filtered` - This listener function will be invoked after a filter is applied, added or removed.\n     * * `zoomed` - This listener function will be invoked after a zoom is triggered.\n     * @method on\n     * @memberof dc.baseMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Internals.md#dispatch_on d3.dispatch.on}\n     * @example\n     * .on('renderlet', function(chart, filter){...})\n     * .on('pretransition', function(chart, filter){...})\n     * .on('preRender', function(chart){...})\n     * .on('postRender', function(chart){...})\n     * .on('preRedraw', function(chart){...})\n     * .on('postRedraw', function(chart){...})\n     * .on('filtered', function(chart, filter){...})\n     * .on('zoomed', function(chart, filter){...})\n     * @param {String} event\n     * @param {Function} listener\n     * @returns {dc.baseMixin}\n     */\n    _chart.on = function (event, listener) {\n        _listeners.on(event, listener);\n        return _chart;\n    };\n\n    return _chart;\n};\n\n/**\n * Margin is a mixin that provides margin utility functions for both the Row Chart and Coordinate Grid\n * Charts.\n * @name marginMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.marginMixin}\n */\ndc.marginMixin = function (_chart) {\n    var _margin = {top: 10, right: 50, bottom: 30, left: 30};\n\n    /**\n     * Get or set the margins for a particular coordinate grid chart instance. The margins is stored as\n     * an associative Javascript array.\n     * @method margins\n     * @memberof dc.marginMixin\n     * @instance\n     * @example\n     * var leftMargin = chart.margins().left; // 30 by default\n     * chart.margins().left = 50;\n     * leftMargin = chart.margins().left; // now 50\n     * @param {{top: Number, right: Number, left: Number, bottom: Number}} [margins={top: 10, right: 50, bottom: 30, left: 30}]\n     * @returns {{top: Number, right: Number, left: Number, bottom: Number}|dc.marginMixin}\n     */\n    _chart.margins = function (margins) {\n        if (!arguments.length) {\n            return _margin;\n        }\n        _margin = margins;\n        return _chart;\n    };\n\n    _chart.effectiveWidth = function () {\n        return _chart.width() - _chart.margins().left - _chart.margins().right;\n    };\n\n    _chart.effectiveHeight = function () {\n        return _chart.height() - _chart.margins().top - _chart.margins().bottom;\n    };\n\n    return _chart;\n};\n\n/**\n * The Color Mixin is an abstract chart functional class providing universal coloring support\n * as a mix-in for any concrete chart implementation.\n * @name colorMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.colorMixin}\n */\ndc.colorMixin = function (_chart) {\n    var _colors = d3.scale.category20c();\n    var _defaultAccessor = true;\n\n    var _colorAccessor = function (d) { return _chart.keyAccessor()(d); };\n\n    /**\n     * Retrieve current color scale or set a new color scale. This methods accepts any function that\n     * operates like a d3 scale.\n     * @method colors\n     * @memberof dc.colorMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @example\n     * // alternate categorical scale\n     * chart.colors(d3.scale.category20b());\n     * // ordinal scale\n     * chart.colors(d3.scale.ordinal().range(['red','green','blue']));\n     * // convenience method, the same as above\n     * chart.ordinalColors(['red','green','blue']);\n     * // set a linear scale\n     * chart.linearColors([\"#4575b4\", \"#ffffbf\", \"#a50026\"]);\n     * @param {d3.scale} [colorScale=d3.scale.category20c()]\n     * @returns {d3.scale|dc.colorMixin}\n     */\n    _chart.colors = function (colorScale) {\n        if (!arguments.length) {\n            return _colors;\n        }\n        if (colorScale instanceof Array) {\n            _colors = d3.scale.quantize().range(colorScale); // deprecated legacy support, note: this fails for ordinal domains\n        } else {\n            _colors = d3.functor(colorScale);\n        }\n        return _chart;\n    };\n\n    /**\n     * Convenience method to set the color scale to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal d3.scale.ordinal} with\n     * range `r`.\n     * @method ordinalColors\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {Array<String>} r\n     * @returns {dc.colorMixin}\n     */\n    _chart.ordinalColors = function (r) {\n        return _chart.colors(d3.scale.ordinal().range(r));\n    };\n\n    /**\n     * Convenience method to set the color scale to an Hcl interpolated linear scale with range `r`.\n     * @method linearColors\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {Array<Number>} r\n     * @returns {dc.colorMixin}\n     */\n    _chart.linearColors = function (r) {\n        return _chart.colors(d3.scale.linear()\n                             .range(r)\n                             .interpolate(d3.interpolateHcl));\n    };\n\n    /**\n     * Set or the get color accessor function. This function will be used to map a data point in a\n     * crossfilter group to a color value on the color scale. The default function uses the key\n     * accessor.\n     * @method colorAccessor\n     * @memberof dc.colorMixin\n     * @instance\n     * @example\n     * // default index based color accessor\n     * .colorAccessor(function (d, i){return i;})\n     * // color accessor for a multi-value crossfilter reduction\n     * .colorAccessor(function (d){return d.value.absGain;})\n     * @param {Function} [colorAccessor]\n     * @returns {Function|dc.colorMixin}\n     */\n    _chart.colorAccessor = function (colorAccessor) {\n        if (!arguments.length) {\n            return _colorAccessor;\n        }\n        _colorAccessor = colorAccessor;\n        _defaultAccessor = false;\n        return _chart;\n    };\n\n    // what is this?\n    _chart.defaultColorAccessor = function () {\n        return _defaultAccessor;\n    };\n\n    /**\n     * Set or get the current domain for the color mapping function. The domain must be supplied as an\n     * array.\n     *\n     * Note: previously this method accepted a callback function. Instead you may use a custom scale\n     * set by {@link dc.colorMixin#colors .colors}.\n     * @method colorDomain\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {Array<String>} [domain]\n     * @returns {Array<String>|dc.colorMixin}\n     */\n    _chart.colorDomain = function (domain) {\n        if (!arguments.length) {\n            return _colors.domain();\n        }\n        _colors.domain(domain);\n        return _chart;\n    };\n\n    /**\n     * Set the domain by determining the min and max values as retrieved by\n     * {@link dc.colorMixin#colorAccessor .colorAccessor} over the chart's dataset.\n     * @method calculateColorDomain\n     * @memberof dc.colorMixin\n     * @instance\n     * @returns {dc.colorMixin}\n     */\n    _chart.calculateColorDomain = function () {\n        var newDomain = [d3.min(_chart.data(), _chart.colorAccessor()),\n                         d3.max(_chart.data(), _chart.colorAccessor())];\n        _colors.domain(newDomain);\n        return _chart;\n    };\n\n    /**\n     * Get the color for the datum d and counter i. This is used internally by charts to retrieve a color.\n     * @method getColor\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {*} d\n     * @param {Number} [i]\n     * @returns {String}\n     */\n    _chart.getColor = function (d, i) {\n        return _colors(_colorAccessor.call(this, d, i));\n    };\n\n    /**\n     * **Deprecated.** Get/set the color calculator. This actually replaces the\n     * {@link dc.colorMixin#getColor getColor} method!\n     *\n     * This is not recommended, since using a {@link dc.colorMixin#colorAccessor colorAccessor} and\n     * color scale ({@link dc.colorMixin#colors .colors}) is more powerful and idiomatic d3.\n     * @method colorCalculator\n     * @memberof dc.colorMixin\n     * @instance\n     * @param {*} [colorCalculator]\n     * @returns {Function|dc.colorMixin}\n     */\n    _chart.colorCalculator = dc.logger.deprecate(function (colorCalculator) {\n        if (!arguments.length) {\n            return _chart.getColor;\n        }\n        _chart.getColor = colorCalculator;\n        return _chart;\n    }, 'colorMixin.colorCalculator has been deprecated. Please colorMixin.colors and colorMixin.colorAccessor instead');\n\n    return _chart;\n};\n\n/**\n * Coordinate Grid is an abstract base chart designed to support a number of coordinate grid based\n * concrete chart types, e.g. bar chart, line chart, and bubble chart.\n * @name coordinateGridMixin\n * @memberof dc\n * @mixin\n * @mixes dc.colorMixin\n * @mixes dc.marginMixin\n * @mixes dc.baseMixin\n * @param {Object} _chart\n * @returns {dc.coordinateGridMixin}\n */\ndc.coordinateGridMixin = function (_chart) {\n    var GRID_LINE_CLASS = 'grid-line';\n    var HORIZONTAL_CLASS = 'horizontal';\n    var VERTICAL_CLASS = 'vertical';\n    var Y_AXIS_LABEL_CLASS = 'y-axis-label';\n    var X_AXIS_LABEL_CLASS = 'x-axis-label';\n    var DEFAULT_AXIS_LABEL_PADDING = 12;\n\n    _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin(_chart)));\n\n    _chart.colors(d3.scale.category10());\n    _chart._mandatoryAttributes().push('x');\n    var _parent;\n    var _g;\n    var _chartBodyG;\n\n    var _x;\n    var _xOriginalDomain;\n    var _xAxis = d3.svg.axis().orient('bottom');\n    var _xUnits = dc.units.integers;\n    var _xAxisPadding = 0;\n    var _xAxisPaddingUnit = 'day';\n    var _xElasticity = false;\n    var _xAxisLabel;\n    var _xAxisLabelPadding = 0;\n    var _lastXDomain;\n\n    var _y;\n    var _yAxis = d3.svg.axis().orient('left');\n    var _yAxisPadding = 0;\n    var _yElasticity = false;\n    var _yAxisLabel;\n    var _yAxisLabelPadding = 0;\n\n    var _brush = d3.svg.brush();\n    var _brushOn = true;\n    var _round;\n\n    var _renderHorizontalGridLine = false;\n    var _renderVerticalGridLine = false;\n\n    var _refocused = false, _resizing = false;\n    var _unitCount;\n\n    var _zoomScale = [1, Infinity];\n    var _zoomOutRestrict = true;\n\n    var _zoom = d3.behavior.zoom().on('zoom', zoomHandler);\n    var _nullZoom = d3.behavior.zoom().on('zoom', null);\n    var _hasBeenMouseZoomable = false;\n\n    var _rangeChart;\n    var _focusChart;\n\n    var _mouseZoomable = false;\n    var _clipPadding = 0;\n\n    var _outerRangeBandPadding = 0.5;\n    var _rangeBandPadding = 0;\n\n    var _useRightYAxis = false;\n\n    /**\n     * When changing the domain of the x or y scale, it is necessary to tell the chart to recalculate\n     * and redraw the axes. (`.rescale()` is called automatically when the x or y scale is replaced\n     * with {@link dc.coordinateGridMixin+x .x()} or {@link dc.coordinateGridMixin#y .y()}, and has\n     * no effect on elastic scales.)\n     * @method rescale\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {dc.coordinateGridMixin}\n     */\n    _chart.rescale = function () {\n        _unitCount = undefined;\n        _resizing = true;\n        return _chart;\n    };\n\n    _chart.resizing = function () {\n        return _resizing;\n    };\n\n    /**\n     * Get or set the range selection chart associated with this instance. Setting the range selection\n     * chart using this function will automatically update its selection brush when the current chart\n     * zooms in. In return the given range chart will also automatically attach this chart as its focus\n     * chart hence zoom in when range brush updates.\n     *\n     * Usually the range and focus charts will share a dimension. The range chart will set the zoom\n     * boundaries for the focus chart, so its dimension values must be compatible with the domain of\n     * the focus chart.\n     *\n     * See the [Nasdaq 100 Index](http://dc-js.github.com/dc.js/) example for this effect in action.\n     * @method rangeChart\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {dc.coordinateGridMixin} [rangeChart]\n     * @returns {dc.coordinateGridMixin}\n     */\n    _chart.rangeChart = function (rangeChart) {\n        if (!arguments.length) {\n            return _rangeChart;\n        }\n        _rangeChart = rangeChart;\n        _rangeChart.focusChart(_chart);\n        return _chart;\n    };\n\n    /**\n     * Get or set the scale extent for mouse zooms.\n     * @method zoomScale\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Array<Number|Date>} [extent=[1, Infinity]]\n     * @returns {Array<Number|Date>|dc.coordinateGridMixin}\n     */\n    _chart.zoomScale = function (extent) {\n        if (!arguments.length) {\n            return _zoomScale;\n        }\n        _zoomScale = extent;\n        return _chart;\n    };\n\n    /**\n     * Get or set the zoom restriction for the chart. If true limits the zoom to origional domain of the chart.\n     * @method zoomOutRestrict\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [zoomOutRestrict=true]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.zoomOutRestrict = function (zoomOutRestrict) {\n        if (!arguments.length) {\n            return _zoomOutRestrict;\n        }\n        _zoomScale[0] = zoomOutRestrict ? 1 : 0;\n        _zoomOutRestrict = zoomOutRestrict;\n        return _chart;\n    };\n\n    _chart._generateG = function (parent) {\n        if (parent === undefined) {\n            _parent = _chart.svg();\n        } else {\n            _parent = parent;\n        }\n\n        var href = window.location.href.split('#')[0];\n\n        _g = _parent.append('g');\n\n        _chartBodyG = _g.append('g').attr('class', 'chart-body')\n            .attr('transform', 'translate(' + _chart.margins().left + ', ' + _chart.margins().top + ')')\n            .attr('clip-path', 'url(' + href + '#' + getClipPathId() + ')');\n\n        return _g;\n    };\n\n    /**\n     * Get or set the root g element. This method is usually used to retrieve the g element in order to\n     * overlay custom svg drawing programatically. **Caution**: The root g element is usually generated\n     * by dc.js internals, and resetting it might produce unpredictable result.\n     * @method g\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {SVGElement} [gElement]\n     * @returns {SVGElement|dc.coordinateGridMixin}\n     */\n    _chart.g = function (gElement) {\n        if (!arguments.length) {\n            return _g;\n        }\n        _g = gElement;\n        return _chart;\n    };\n\n    /**\n     * Set or get mouse zoom capability flag (default: false). When turned on the chart will be\n     * zoomable using the mouse wheel. If the range selector chart is attached zooming will also update\n     * the range selection brush on the associated range selector chart.\n     * @method mouseZoomable\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [mouseZoomable=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.mouseZoomable = function (mouseZoomable) {\n        if (!arguments.length) {\n            return _mouseZoomable;\n        }\n        _mouseZoomable = mouseZoomable;\n        return _chart;\n    };\n\n    /**\n     * Retrieve the svg group for the chart body.\n     * @method chartBodyG\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {SVGElement} [chartBodyG]\n     * @returns {SVGElement}\n     */\n    _chart.chartBodyG = function (chartBodyG) {\n        if (!arguments.length) {\n            return _chartBodyG;\n        }\n        _chartBodyG = chartBodyG;\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Get or set the x scale. The x scale can be any d3\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale} or\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md ordinal scale}.\n     * @method x\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @example\n     * // set x to a linear scale\n     * chart.x(d3.scale.linear().domain([-2500, 2500]))\n     * // set x to a time scale to generate histogram\n     * chart.x(d3.time.scale().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))\n     * @param {d3.scale} [xScale]\n     * @returns {d3.scale|dc.coordinateGridMixin}\n     */\n    _chart.x = function (xScale) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = xScale;\n        _xOriginalDomain = _x.domain();\n        _chart.rescale();\n        return _chart;\n    };\n\n    _chart.xOriginalDomain = function () {\n        return _xOriginalDomain;\n    };\n\n    /**\n     * Set or get the xUnits function. The coordinate grid chart uses the xUnits function to calculate\n     * the number of data projections on x axis such as the number of bars for a bar chart or the\n     * number of dots for a line chart. This function is expected to return a Javascript array of all\n     * data points on x axis, or the number of points on the axis. [d3 time range functions\n     * d3.time.days, d3.time.months, and\n     * d3.time.years](https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#aliases) are all valid xUnits\n     * function. dc.js also provides a few units function, see the {@link dc.units Units Namespace} for\n     * a list of built-in units functions.\n     * @method xUnits\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @todo Add docs for utilities\n     * @example\n     * // set x units to count days\n     * chart.xUnits(d3.time.days);\n     * // set x units to count months\n     * chart.xUnits(d3.time.months);\n     *\n     * // A custom xUnits function can be used as long as it follows the following interface:\n     * // units in integer\n     * function(start, end, xDomain) {\n     *      // simply calculates how many integers in the domain\n     *      return Math.abs(end - start);\n     * };\n     *\n     * // fixed units\n     * function(start, end, xDomain) {\n     *      // be aware using fixed units will disable the focus/zoom ability on the chart\n     *      return 1000;\n     * @param {Function} [xUnits=dc.units.integers]\n     * @returns {Function|dc.coordinateGridMixin}\n     */\n    _chart.xUnits = function (xUnits) {\n        if (!arguments.length) {\n            return _xUnits;\n        }\n        _xUnits = xUnits;\n        return _chart;\n    };\n\n    /**\n     * Set or get the x axis used by a particular coordinate grid chart instance. This function is most\n     * useful when x axis customization is required. The x axis in dc.js is an instance of a\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3 axis object};\n     * therefore it supports any valid d3 axis manipulation.\n     *\n     * **Caution**: The x axis is usually generated internally by dc; resetting it may cause\n     * unexpected results. Note also that when used as a getter, this function is not chainable:\n     * it returns the axis, not the chart,\n     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#why-does-everything-break-after-a-call-to-xaxis-or-yaxis\n     * so attempting to call chart functions after calling `.xAxis()` will fail}.\n     * @method xAxis\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize x axis tick format\n     * chart.xAxis().tickFormat(function(v) {return v + '%';});\n     * // customize x axis tick values\n     * chart.xAxis().tickValues([0, 100, 200, 300]);\n     * @param {d3.svg.axis} [xAxis=d3.svg.axis().orient('bottom')]\n     * @returns {d3.svg.axis|dc.coordinateGridMixin}\n     */\n    _chart.xAxis = function (xAxis) {\n        if (!arguments.length) {\n            return _xAxis;\n        }\n        _xAxis = xAxis;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off elastic x axis behavior. If x axis elasticity is turned on, then the grid chart will\n     * attempt to recalculate the x axis range whenever a redraw event is triggered.\n     * @method elasticX\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [elasticX=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.elasticX = function (elasticX) {\n        if (!arguments.length) {\n            return _xElasticity;\n        }\n        _xElasticity = elasticX;\n        return _chart;\n    };\n\n    /**\n     * Set or get x axis padding for the elastic x axis. The padding will be added to both end of the x\n     * axis if elasticX is turned on; otherwise it is ignored.\n     *\n     * Padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to\n     * number or date x axes.  When padding a date axis, an integer represents number of units being padded\n     * and a percentage string will be treated the same as an integer. The unit will be determined by the\n     * xAxisPaddingUnit variable.\n     * @method xAxisPadding\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Number|String} [padding=0]\n     * @returns {Number|String|dc.coordinateGridMixin}\n     */\n    _chart.xAxisPadding = function (padding) {\n        if (!arguments.length) {\n            return _xAxisPadding;\n        }\n        _xAxisPadding = padding;\n        return _chart;\n    };\n\n    /**\n     * Set or get x axis padding unit for the elastic x axis. The padding unit will determine which unit to\n     * use when applying xAxis padding if elasticX is turned on and if x-axis uses a time dimension;\n     * otherwise it is ignored.\n     *\n     * Padding unit is a string that will be used when the padding is calculated. Available parameters are\n     * the available d3 time intervals; see\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Time-Intervals.md#interval d3.time.interval}.\n     * @method xAxisPaddingUnit\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {String} [unit='days']\n     * @returns {String|dc.coordinateGridMixin}\n     */\n    _chart.xAxisPaddingUnit = function (unit) {\n        if (!arguments.length) {\n            return _xAxisPaddingUnit;\n        }\n        _xAxisPaddingUnit = unit;\n        return _chart;\n    };\n\n    /**\n     * Returns the number of units displayed on the x axis using the unit measure configured by\n     * {@link dc.coordinateGridMixin#xUnits xUnits}.\n     * @method xUnitCount\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {Number}\n     */\n    _chart.xUnitCount = function () {\n        if (_unitCount === undefined) {\n            var units = _chart.xUnits()(_chart.x().domain()[0], _chart.x().domain()[1], _chart.x().domain());\n\n            if (units instanceof Array) {\n                _unitCount = units.length;\n            } else {\n                _unitCount = units;\n            }\n        }\n\n        return _unitCount;\n    };\n\n    /**\n     * Gets or sets whether the chart should be drawn with a right axis instead of a left axis. When\n     * used with a chart in a composite chart, allows both left and right Y axes to be shown on a\n     * chart.\n     * @method useRightYAxis\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [useRightYAxis=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.useRightYAxis = function (useRightYAxis) {\n        if (!arguments.length) {\n            return _useRightYAxis;\n        }\n        _useRightYAxis = useRightYAxis;\n        return _chart;\n    };\n\n    /**\n     * Returns true if the chart is using ordinal xUnits ({@link dc.units.ordinal dc.units.ordinal}, or false\n     * otherwise. Most charts behave differently with ordinal data and use the result of this method to\n     * trigger the appropriate logic.\n     * @method isOrdinal\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {Boolean}\n     */\n    _chart.isOrdinal = function () {\n        return _chart.xUnits() === dc.units.ordinal;\n    };\n\n    _chart._useOuterPadding = function () {\n        return true;\n    };\n\n    _chart._ordinalXDomain = function () {\n        var groups = _chart._computeOrderedGroups(_chart.data());\n        return groups.map(_chart.keyAccessor());\n    };\n\n    function compareDomains (d1, d2) {\n        return !d1 || !d2 || d1.length !== d2.length ||\n            d1.some(function (elem, i) { return (elem && d2[i]) ? elem.toString() !== d2[i].toString() : elem === d2[i]; });\n    }\n\n    function prepareXAxis (g, render) {\n        if (!_chart.isOrdinal()) {\n            if (_chart.elasticX()) {\n                _x.domain([_chart.xAxisMin(), _chart.xAxisMax()]);\n            }\n        } else { // _chart.isOrdinal()\n            if (_chart.elasticX() || _x.domain().length === 0) {\n                _x.domain(_chart._ordinalXDomain());\n            }\n        }\n\n        // has the domain changed?\n        var xdom = _x.domain();\n        if (render || compareDomains(_lastXDomain, xdom)) {\n            _chart.rescale();\n        }\n        _lastXDomain = xdom;\n\n        // please can't we always use rangeBands for bar charts?\n        if (_chart.isOrdinal()) {\n            _x.rangeBands([0, _chart.xAxisLength()], _rangeBandPadding,\n                          _chart._useOuterPadding() ? _outerRangeBandPadding : 0);\n        } else {\n            _x.range([0, _chart.xAxisLength()]);\n        }\n\n        _xAxis = _xAxis.scale(_chart.x());\n\n        renderVerticalGridLines(g);\n    }\n\n    _chart.renderXAxis = function (g) {\n        var axisXG = g.select('g.x');\n\n        if (axisXG.empty()) {\n            axisXG = g.append('g')\n                .attr('class', 'axis x')\n                .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart._xAxisY() + ')');\n        }\n\n        var axisXLab = g.select('text.' + X_AXIS_LABEL_CLASS);\n        if (axisXLab.empty() && _chart.xAxisLabel()) {\n            axisXLab = g.append('text')\n                .attr('class', X_AXIS_LABEL_CLASS)\n                .attr('transform', 'translate(' + (_chart.margins().left + _chart.xAxisLength() / 2) + ',' +\n                      (_chart.height() - _xAxisLabelPadding) + ')')\n                .attr('text-anchor', 'middle');\n        }\n        if (_chart.xAxisLabel() && axisXLab.text() !== _chart.xAxisLabel()) {\n            axisXLab.text(_chart.xAxisLabel());\n        }\n\n        dc.transition(axisXG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart._xAxisY() + ')')\n            .call(_xAxis);\n        dc.transition(axisXLab, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + (_chart.margins().left + _chart.xAxisLength() / 2) + ',' +\n                  (_chart.height() - _xAxisLabelPadding) + ')');\n    };\n\n    function renderVerticalGridLines (g) {\n        var gridLineG = g.select('g.' + VERTICAL_CLASS);\n\n        if (_renderVerticalGridLine) {\n            if (gridLineG.empty()) {\n                gridLineG = g.insert('g', ':first-child')\n                    .attr('class', GRID_LINE_CLASS + ' ' + VERTICAL_CLASS)\n                    .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n            }\n\n            var ticks = _xAxis.tickValues() ? _xAxis.tickValues() :\n                    (typeof _x.ticks === 'function' ? _x.ticks(_xAxis.ticks()[0]) : _x.domain());\n\n            var lines = gridLineG.selectAll('line')\n                .data(ticks);\n\n            // enter\n            var linesGEnter = lines.enter()\n                .append('line')\n                .attr('x1', function (d) {\n                    return _x(d);\n                })\n                .attr('y1', _chart._xAxisY() - _chart.margins().top)\n                .attr('x2', function (d) {\n                    return _x(d);\n                })\n                .attr('y2', 0)\n                .attr('opacity', 0);\n            dc.transition(linesGEnter, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', 1);\n\n            // update\n            dc.transition(lines, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('x1', function (d) {\n                    return _x(d);\n                })\n                .attr('y1', _chart._xAxisY() - _chart.margins().top)\n                .attr('x2', function (d) {\n                    return _x(d);\n                })\n                .attr('y2', 0);\n\n            // exit\n            lines.exit().remove();\n        } else {\n            gridLineG.selectAll('line').remove();\n        }\n    }\n\n    _chart._xAxisY = function () {\n        return (_chart.height() - _chart.margins().bottom);\n    };\n\n    _chart.xAxisLength = function () {\n        return _chart.effectiveWidth();\n    };\n\n    /**\n     * Set or get the x axis label. If setting the label, you may optionally include additional padding to\n     * the margin to make room for the label. By default the padded is set to 12 to accomodate the text height.\n     * @method xAxisLabel\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {String} [labelText]\n     * @param {Number} [padding=12]\n     * @returns {String}\n     */\n    _chart.xAxisLabel = function (labelText, padding) {\n        if (!arguments.length) {\n            return _xAxisLabel;\n        }\n        _xAxisLabel = labelText;\n        _chart.margins().bottom -= _xAxisLabelPadding;\n        _xAxisLabelPadding = (padding === undefined) ? DEFAULT_AXIS_LABEL_PADDING : padding;\n        _chart.margins().bottom += _xAxisLabelPadding;\n        return _chart;\n    };\n\n    _chart._prepareYAxis = function (g) {\n        if (_y === undefined || _chart.elasticY()) {\n            if (_y === undefined) {\n                _y = d3.scale.linear();\n            }\n            var min = _chart.yAxisMin() || 0,\n                max = _chart.yAxisMax() || 0;\n            _y.domain([min, max]).rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _y.range([_chart.yAxisHeight(), 0]);\n        _yAxis = _yAxis.scale(_y);\n\n        if (_useRightYAxis) {\n            _yAxis.orient('right');\n        }\n\n        _chart._renderHorizontalGridLinesForAxis(g, _y, _yAxis);\n    };\n\n    _chart.renderYAxisLabel = function (axisClass, text, rotation, labelXPosition) {\n        labelXPosition = labelXPosition || _yAxisLabelPadding;\n\n        var axisYLab = _chart.g().select('text.' + Y_AXIS_LABEL_CLASS + '.' + axisClass + '-label');\n        var labelYPosition = (_chart.margins().top + _chart.yAxisHeight() / 2);\n        if (axisYLab.empty() && text) {\n            axisYLab = _chart.g().append('text')\n                .attr('transform', 'translate(' + labelXPosition + ',' + labelYPosition + '),rotate(' + rotation + ')')\n                .attr('class', Y_AXIS_LABEL_CLASS + ' ' + axisClass + '-label')\n                .attr('text-anchor', 'middle')\n                .text(text);\n        }\n        if (text && axisYLab.text() !== text) {\n            axisYLab.text(text);\n        }\n        dc.transition(axisYLab, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + labelXPosition + ',' + labelYPosition + '),rotate(' + rotation + ')');\n    };\n\n    _chart.renderYAxisAt = function (axisClass, axis, position) {\n        var axisYG = _chart.g().select('g.' + axisClass);\n        if (axisYG.empty()) {\n            axisYG = _chart.g().append('g')\n                .attr('class', 'axis ' + axisClass)\n                .attr('transform', 'translate(' + position + ',' + _chart.margins().top + ')');\n        }\n\n        dc.transition(axisYG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', 'translate(' + position + ',' + _chart.margins().top + ')')\n            .call(axis);\n    };\n\n    _chart.renderYAxis = function () {\n        var axisPosition = _useRightYAxis ? (_chart.width() - _chart.margins().right) : _chart._yAxisX();\n        _chart.renderYAxisAt('y', _yAxis, axisPosition);\n        var labelPosition = _useRightYAxis ? (_chart.width() - _yAxisLabelPadding) : _yAxisLabelPadding;\n        var rotation = _useRightYAxis ? 90 : -90;\n        _chart.renderYAxisLabel('y', _chart.yAxisLabel(), rotation, labelPosition);\n    };\n\n    _chart._renderHorizontalGridLinesForAxis = function (g, scale, axis) {\n        var gridLineG = g.select('g.' + HORIZONTAL_CLASS);\n\n        if (_renderHorizontalGridLine) {\n            var ticks = axis.tickValues() ? axis.tickValues() : scale.ticks(axis.ticks()[0]);\n\n            if (gridLineG.empty()) {\n                gridLineG = g.insert('g', ':first-child')\n                    .attr('class', GRID_LINE_CLASS + ' ' + HORIZONTAL_CLASS)\n                    .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n            }\n\n            var lines = gridLineG.selectAll('line')\n                .data(ticks);\n\n            // enter\n            var linesGEnter = lines.enter()\n                .append('line')\n                .attr('x1', 1)\n                .attr('y1', function (d) {\n                    return scale(d);\n                })\n                .attr('x2', _chart.xAxisLength())\n                .attr('y2', function (d) {\n                    return scale(d);\n                })\n                .attr('opacity', 0);\n            dc.transition(linesGEnter, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', 1);\n\n            // update\n            dc.transition(lines, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('x1', 1)\n                .attr('y1', function (d) {\n                    return scale(d);\n                })\n                .attr('x2', _chart.xAxisLength())\n                .attr('y2', function (d) {\n                    return scale(d);\n                });\n\n            // exit\n            lines.exit().remove();\n        } else {\n            gridLineG.selectAll('line').remove();\n        }\n    };\n\n    _chart._yAxisX = function () {\n        return _chart.useRightYAxis() ? _chart.width() - _chart.margins().right : _chart.margins().left;\n    };\n\n    /**\n     * Set or get the y axis label. If setting the label, you may optionally include additional padding\n     * to the margin to make room for the label. By default the padding is set to 12 to accommodate the\n     * text height.\n     * @method yAxisLabel\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {String} [labelText]\n     * @param {Number} [padding=12]\n     * @returns {String|dc.coordinateGridMixin}\n     */\n    _chart.yAxisLabel = function (labelText, padding) {\n        if (!arguments.length) {\n            return _yAxisLabel;\n        }\n        _yAxisLabel = labelText;\n        _chart.margins().left -= _yAxisLabelPadding;\n        _yAxisLabelPadding = (padding === undefined) ? DEFAULT_AXIS_LABEL_PADDING : padding;\n        _chart.margins().left += _yAxisLabelPadding;\n        return _chart;\n    };\n\n    /**\n     * Get or set the y scale. The y scale is typically automatically determined by the chart implementation.\n     * @method y\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @param {d3.scale} [yScale]\n     * @returns {d3.scale|dc.coordinateGridMixin}\n     */\n    _chart.y = function (yScale) {\n        if (!arguments.length) {\n            return _y;\n        }\n        _y = yScale;\n        _chart.rescale();\n        return _chart;\n    };\n\n    /**\n     * Set or get the y axis used by the coordinate grid chart instance. This function is most useful\n     * when y axis customization is required. The y axis in dc.js is simply an instance of a [d3 axis\n     * object](https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis); therefore it supports any\n     * valid d3 axis manipulation.\n     *\n     * **Caution**: The y axis is usually generated internally by dc; resetting it may cause\n     * unexpected results.  Note also that when used as a getter, this function is not chainable: it\n     * returns the axis, not the chart,\n     * {@link https://github.com/dc-js/dc.js/wiki/FAQ#why-does-everything-break-after-a-call-to-xaxis-or-yaxis\n     * so attempting to call chart functions after calling `.yAxis()` will fail}.\n     * @method yAxis\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize y axis tick format\n     * chart.yAxis().tickFormat(function(v) {return v + '%';});\n     * // customize y axis tick values\n     * chart.yAxis().tickValues([0, 100, 200, 300]);\n     * @param {d3.svg.axis} [yAxis=d3.svg.axis().orient('left')]\n     * @returns {d3.svg.axis|dc.coordinateGridMixin}\n     */\n    _chart.yAxis = function (yAxis) {\n        if (!arguments.length) {\n            return _yAxis;\n        }\n        _yAxis = yAxis;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off elastic y axis behavior. If y axis elasticity is turned on, then the grid chart will\n     * attempt to recalculate the y axis range whenever a redraw event is triggered.\n     * @method elasticY\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [elasticY=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.elasticY = function (elasticY) {\n        if (!arguments.length) {\n            return _yElasticity;\n        }\n        _yElasticity = elasticY;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off horizontal grid lines.\n     * @method renderHorizontalGridLines\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [renderHorizontalGridLines=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.renderHorizontalGridLines = function (renderHorizontalGridLines) {\n        if (!arguments.length) {\n            return _renderHorizontalGridLine;\n        }\n        _renderHorizontalGridLine = renderHorizontalGridLines;\n        return _chart;\n    };\n\n    /**\n     * Turn on/off vertical grid lines.\n     * @method renderVerticalGridLines\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [renderVerticalGridLines=false]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.renderVerticalGridLines = function (renderVerticalGridLines) {\n        if (!arguments.length) {\n            return _renderVerticalGridLine;\n        }\n        _renderVerticalGridLine = renderVerticalGridLines;\n        return _chart;\n    };\n\n    /**\n     * Calculates the minimum x value to display in the chart. Includes xAxisPadding if set.\n     * @method xAxisMin\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.xAxisMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return _chart.keyAccessor()(e);\n        });\n        return dc.utils.subtract(min, _xAxisPadding, _xAxisPaddingUnit);\n    };\n\n    /**\n     * Calculates the maximum x value to display in the chart. Includes xAxisPadding if set.\n     * @method xAxisMax\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.xAxisMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return _chart.keyAccessor()(e);\n        });\n        return dc.utils.add(max, _xAxisPadding, _xAxisPaddingUnit);\n    };\n\n    /**\n     * Calculates the minimum y value to display in the chart. Includes yAxisPadding if set.\n     * @method yAxisMin\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.yAxisMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return _chart.valueAccessor()(e);\n        });\n        return dc.utils.subtract(min, _yAxisPadding);\n    };\n\n    /**\n     * Calculates the maximum y value to display in the chart. Includes yAxisPadding if set.\n     * @method yAxisMax\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @returns {*}\n     */\n    _chart.yAxisMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return _chart.valueAccessor()(e);\n        });\n        return dc.utils.add(max, _yAxisPadding);\n    };\n\n    /**\n     * Set or get y axis padding for the elastic y axis. The padding will be added to the top and\n     * bottom of the y axis if elasticY is turned on; otherwise it is ignored.\n     *\n     * Padding can be an integer or percentage in string (e.g. '10%'). Padding can be applied to\n     * number or date axes. When padding a date axis, an integer represents number of days being padded\n     * and a percentage string will be treated the same as an integer.\n     * @method yAxisPadding\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Number|String} [padding=0]\n     * @returns {Number|dc.coordinateGridMixin}\n     */\n    _chart.yAxisPadding = function (padding) {\n        if (!arguments.length) {\n            return _yAxisPadding;\n        }\n        _yAxisPadding = padding;\n        return _chart;\n    };\n\n    _chart.yAxisHeight = function () {\n        return _chart.effectiveHeight();\n    };\n\n    /**\n     * Set or get the rounding function used to quantize the selection when brushing is enabled.\n     * @method round\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @example\n     * // set x unit round to by month, this will make sure range selection brush will\n     * // select whole months\n     * chart.round(d3.time.month.round);\n     * @param {Function} [round]\n     * @returns {Function|dc.coordinateGridMixin}\n     */\n    _chart.round = function (round) {\n        if (!arguments.length) {\n            return _round;\n        }\n        _round = round;\n        return _chart;\n    };\n\n    _chart._rangeBandPadding = function (_) {\n        if (!arguments.length) {\n            return _rangeBandPadding;\n        }\n        _rangeBandPadding = _;\n        return _chart;\n    };\n\n    _chart._outerRangeBandPadding = function (_) {\n        if (!arguments.length) {\n            return _outerRangeBandPadding;\n        }\n        _outerRangeBandPadding = _;\n        return _chart;\n    };\n\n    dc.override(_chart, 'filter', function (_) {\n        if (!arguments.length) {\n            return _chart._filter();\n        }\n\n        _chart._filter(_);\n\n        if (_) {\n            _chart.brush().extent(_);\n        } else {\n            _chart.brush().clear();\n        }\n\n        return _chart;\n    });\n\n    _chart.brush = function (_) {\n        if (!arguments.length) {\n            return _brush;\n        }\n        _brush = _;\n        return _chart;\n    };\n\n    function brushHeight () {\n        return _chart._xAxisY() - _chart.margins().top;\n    }\n\n    _chart.renderBrush = function (g) {\n        if (_brushOn) {\n            _brush.on('brush', _chart._brushing);\n            _brush.on('brushstart', _chart._disableMouseZoom);\n            _brush.on('brushend', configureMouseZoom);\n\n            var gBrush = g.append('g')\n                .attr('class', 'brush')\n                .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')')\n                .call(_brush.x(_chart.x()));\n            _chart.setBrushY(gBrush, false);\n            _chart.setHandlePaths(gBrush);\n\n            if (_chart.hasFilter()) {\n                _chart.redrawBrush(g, false);\n            }\n        }\n    };\n\n    _chart.setHandlePaths = function (gBrush) {\n        gBrush.selectAll('.resize').append('path').attr('d', _chart.resizeHandlePath);\n    };\n\n    _chart.setBrushY = function (gBrush) {\n        gBrush.selectAll('rect')\n            .attr('height', brushHeight());\n        gBrush.selectAll('.resize path')\n            .attr('d', _chart.resizeHandlePath);\n    };\n\n    _chart.extendBrush = function () {\n        var extent = _brush.extent();\n        if (_chart.round()) {\n            extent[0] = extent.map(_chart.round())[0];\n            extent[1] = extent.map(_chart.round())[1];\n\n            _g.select('.brush')\n                .call(_brush.extent(extent));\n        }\n        return extent;\n    };\n\n    _chart.brushIsEmpty = function (extent) {\n        return _brush.empty() || !extent || extent[1] <= extent[0];\n    };\n\n    _chart._brushing = function () {\n        var extent = _chart.extendBrush();\n\n        _chart.redrawBrush(_g, false);\n\n        if (_chart.brushIsEmpty(extent)) {\n            dc.events.trigger(function () {\n                _chart.filter(null);\n                _chart.redrawGroup();\n            }, dc.constants.EVENT_DELAY);\n        } else {\n            var rangedFilter = dc.filters.RangedFilter(extent[0], extent[1]);\n\n            dc.events.trigger(function () {\n                _chart.replaceFilter(rangedFilter);\n                _chart.redrawGroup();\n            }, dc.constants.EVENT_DELAY);\n        }\n    };\n\n    _chart.redrawBrush = function (g, doTransition) {\n        if (_brushOn) {\n            if (_chart.filter() && _chart.brush().empty()) {\n                _chart.brush().extent(_chart.filter());\n            }\n\n            var gBrush = dc.optionalTransition(doTransition, _chart.transitionDuration(), _chart.transitionDelay())(g.select('g.brush'));\n            _chart.setBrushY(gBrush);\n            gBrush.call(_chart.brush()\n                      .x(_chart.x())\n                      .extent(_chart.brush().extent()));\n        }\n\n        _chart.fadeDeselectedArea();\n    };\n\n    _chart.fadeDeselectedArea = function () {\n        // do nothing, sub-chart should override this function\n    };\n\n    // borrowed from Crossfilter example\n    _chart.resizeHandlePath = function (d) {\n        var e = +(d === 'e'), x = e ? 1 : -1, y = brushHeight() / 3;\n        return 'M' + (0.5 * x) + ',' + y +\n            'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6) +\n            'V' + (2 * y - 6) +\n            'A6,6 0 0 ' + e + ' ' + (0.5 * x) + ',' + (2 * y) +\n            'Z' +\n            'M' + (2.5 * x) + ',' + (y + 8) +\n            'V' + (2 * y - 8) +\n            'M' + (4.5 * x) + ',' + (y + 8) +\n            'V' + (2 * y - 8);\n    };\n\n    function getClipPathId () {\n        return _chart.anchorName().replace(/[ .#=\\[\\]\"]/g, '-') + '-clip';\n    }\n\n    /**\n     * Get or set the padding in pixels for the clip path. Once set padding will be applied evenly to\n     * the top, left, right, and bottom when the clip path is generated. If set to zero, the clip area\n     * will be exactly the chart body area minus the margins.\n     * @method clipPadding\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Number} [padding=5]\n     * @returns {Number|dc.coordinateGridMixin}\n     */\n    _chart.clipPadding = function (padding) {\n        if (!arguments.length) {\n            return _clipPadding;\n        }\n        _clipPadding = padding;\n        return _chart;\n    };\n\n    function generateClipPath () {\n        var defs = dc.utils.appendOrSelect(_parent, 'defs');\n        // cannot select <clippath> elements; bug in WebKit, must select by id\n        // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n        var id = getClipPathId();\n        var chartBodyClip = dc.utils.appendOrSelect(defs, '#' + id, 'clipPath').attr('id', id);\n\n        var padding = _clipPadding * 2;\n\n        dc.utils.appendOrSelect(chartBodyClip, 'rect')\n            .attr('width', _chart.xAxisLength() + padding)\n            .attr('height', _chart.yAxisHeight() + padding)\n            .attr('transform', 'translate(-' + _clipPadding + ', -' + _clipPadding + ')');\n    }\n\n    _chart._preprocessData = function () {};\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _chart._preprocessData();\n\n        _chart._generateG();\n        generateClipPath();\n\n        drawChart(true);\n\n        configureMouseZoom();\n\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        _chart._preprocessData();\n\n        drawChart(false);\n        generateClipPath();\n\n        return _chart;\n    };\n\n    function drawChart (render) {\n        if (_chart.isOrdinal()) {\n            _brushOn = false;\n        }\n\n        prepareXAxis(_chart.g(), render);\n        _chart._prepareYAxis(_chart.g());\n\n        _chart.plotData();\n\n        if (_chart.elasticX() || _resizing || render) {\n            _chart.renderXAxis(_chart.g());\n        }\n\n        if (_chart.elasticY() || _resizing || render) {\n            _chart.renderYAxis(_chart.g());\n        }\n\n        if (render) {\n            _chart.renderBrush(_chart.g(), false);\n        } else {\n            _chart.redrawBrush(_chart.g(), _resizing);\n        }\n        _chart.fadeDeselectedArea();\n        _resizing = false;\n    }\n\n    function configureMouseZoom () {\n        if (_mouseZoomable) {\n            _chart._enableMouseZoom();\n        } else if (_hasBeenMouseZoomable) {\n            _chart._disableMouseZoom();\n        }\n    }\n\n    _chart._enableMouseZoom = function () {\n        _hasBeenMouseZoomable = true;\n        _zoom.x(_chart.x())\n            .scaleExtent(_zoomScale)\n            .size([_chart.width(), _chart.height()])\n            .duration(_chart.transitionDuration());\n        _chart.root().call(_zoom);\n    };\n\n    _chart._disableMouseZoom = function () {\n        _chart.root().call(_nullZoom);\n    };\n\n    function zoomHandler () {\n        _refocused = true;\n        if (_zoomOutRestrict) {\n            var constraint = _xOriginalDomain;\n            if (_rangeChart) {\n                constraint = intersectExtents(constraint, _rangeChart.x().domain());\n            }\n            var constrained = constrainExtent(_chart.x().domain(), constraint);\n            if (constrained) {\n                _chart.x().domain(constrained);\n            }\n        }\n\n        var domain = _chart.x().domain();\n        var domFilter = dc.filters.RangedFilter(domain[0], domain[1]);\n\n        _chart.replaceFilter(domFilter);\n        _chart.rescale();\n        _chart.redraw();\n\n        if (_rangeChart && !rangesEqual(_chart.filter(), _rangeChart.filter())) {\n            dc.events.trigger(function () {\n                _rangeChart.replaceFilter(domFilter);\n                _rangeChart.redraw();\n            });\n        }\n\n        _chart._invokeZoomedListener();\n\n        dc.events.trigger(function () {\n            _chart.redrawGroup();\n        }, dc.constants.EVENT_DELAY);\n\n        _refocused = !rangesEqual(domain, _xOriginalDomain);\n    }\n\n    function intersectExtents (ext1, ext2) {\n        if (ext1[0] > ext2[1] || ext1[1] < ext2[0]) {\n            console.warn('could not intersect extents');\n        }\n        return [Math.max(ext1[0], ext2[0]), Math.min(ext1[1], ext2[1])];\n    }\n\n    function constrainExtent (extent, constraint) {\n        var size = extent[1] - extent[0];\n        if (extent[0] < constraint[0]) {\n            return [constraint[0], Math.min(constraint[1], dc.utils.add(constraint[0], size, 'millis'))];\n        } else if (extent[1] > constraint[1]) {\n            return [Math.max(constraint[0], dc.utils.subtract(constraint[1], size, 'millis')), constraint[1]];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Zoom this chart to focus on the given range. The given range should be an array containing only\n     * 2 elements (`[start, end]`) defining a range in the x domain. If the range is not given or set\n     * to null, then the zoom will be reset. _For focus to work elasticX has to be turned off;\n     * otherwise focus will be ignored.\n     * @method focus\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @example\n     * chart.on('renderlet', function(chart) {\n     *     // smooth the rendering through event throttling\n     *     dc.events.trigger(function(){\n     *          // focus some other chart to the range selected by user on this chart\n     *          someOtherChart.focus(chart.filter());\n     *     });\n     * })\n     * @param {Array<Number>} [range]\n     */\n    _chart.focus = function (range) {\n        if (hasRangeSelected(range)) {\n            _chart.x().domain(range);\n        } else {\n            _chart.x().domain(_xOriginalDomain);\n        }\n\n        _zoom.x(_chart.x());\n        zoomHandler();\n    };\n\n    _chart.refocused = function () {\n        return _refocused;\n    };\n\n    _chart.focusChart = function (c) {\n        if (!arguments.length) {\n            return _focusChart;\n        }\n        _focusChart = c;\n        _chart.on('filtered', function (chart) {\n            if (!chart.filter()) {\n                dc.events.trigger(function () {\n                    _focusChart.x().domain(_focusChart.xOriginalDomain());\n                });\n            } else if (!rangesEqual(chart.filter(), _focusChart.filter())) {\n                dc.events.trigger(function () {\n                    _focusChart.focus(chart.filter());\n                });\n            }\n        });\n        return _chart;\n    };\n\n    function rangesEqual (range1, range2) {\n        if (!range1 && !range2) {\n            return true;\n        } else if (!range1 || !range2) {\n            return false;\n        } else if (range1.length === 0 && range2.length === 0) {\n            return true;\n        } else if (range1[0].valueOf() === range2[0].valueOf() &&\n            range1[1].valueOf() === range2[1].valueOf()) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Turn on/off the brush-based range filter. When brushing is on then user can drag the mouse\n     * across a chart with a quantitative scale to perform range filtering based on the extent of the\n     * brush, or click on the bars of an ordinal bar chart or slices of a pie chart to filter and\n     * un-filter them. However turning on the brush filter will disable other interactive elements on\n     * the chart such as highlighting, tool tips, and reference lines. Zooming will still be possible\n     * if enabled, but only via scrolling (panning will be disabled.)\n     * @method brushOn\n     * @memberof dc.coordinateGridMixin\n     * @instance\n     * @param {Boolean} [brushOn=true]\n     * @returns {Boolean|dc.coordinateGridMixin}\n     */\n    _chart.brushOn = function (brushOn) {\n        if (!arguments.length) {\n            return _brushOn;\n        }\n        _brushOn = brushOn;\n        return _chart;\n    };\n\n    function hasRangeSelected (range) {\n        return range instanceof Array && range.length > 1;\n    }\n\n    return _chart;\n};\n\n/**\n * Stack Mixin is an mixin that provides cross-chart support of stackability using d3.layout.stack.\n * @name stackMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.stackMixin}\n */\ndc.stackMixin = function (_chart) {\n\n    function prepareValues (layer, layerIdx) {\n        var valAccessor = layer.accessor || _chart.valueAccessor();\n        layer.name = String(layer.name || layerIdx);\n        layer.values = layer.group.all().map(function (d, i) {\n            return {\n                x: _chart.keyAccessor()(d, i),\n                y: layer.hidden ? null : valAccessor(d, i),\n                data: d,\n                layer: layer.name,\n                hidden: layer.hidden\n            };\n        });\n\n        layer.values = layer.values.filter(domainFilter());\n        return layer.values;\n    }\n\n    var _stackLayout = d3.layout.stack()\n        .values(prepareValues);\n\n    var _stack = [];\n    var _titles = {};\n\n    var _hidableStacks = false;\n    var _evadeDomainFilter = false;\n\n    function domainFilter () {\n        if (!_chart.x() || _evadeDomainFilter) {\n            return d3.functor(true);\n        }\n        var xDomain = _chart.x().domain();\n        if (_chart.isOrdinal()) {\n            // TODO #416\n            //var domainSet = d3.set(xDomain);\n            return function () {\n                return true; //domainSet.has(p.x);\n            };\n        }\n        if (_chart.elasticX()) {\n            return function () { return true; };\n        }\n        return function (p) {\n            //return true;\n            return p.x >= xDomain[0] && p.x <= xDomain[xDomain.length - 1];\n        };\n    }\n\n    /**\n     * Stack a new crossfilter group onto this chart with an optional custom value accessor. All stacks\n     * in the same chart will share the same key accessor and therefore the same set of keys.\n     *\n     * For example, in a stacked bar chart, the bars of each stack will be positioned using the same set\n     * of keys on the x axis, while stacked vertically. If name is specified then it will be used to\n     * generate the legend label.\n     * @method stack\n     * @memberof dc.stackMixin\n     * @instance\n     * @see {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group-map-reduce crossfilter.group}\n     * @example\n     * // stack group using default accessor\n     * chart.stack(valueSumGroup)\n     * // stack group using custom accessor\n     * .stack(avgByDayGroup, function(d){return d.value.avgByDay;});\n     * @param {crossfilter.group} group\n     * @param {String} [name]\n     * @param {Function} [accessor]\n     * @returns {Array<{group: crossfilter.group, name: String, accessor: Function}>|dc.stackMixin}\n     */\n    _chart.stack = function (group, name, accessor) {\n        if (!arguments.length) {\n            return _stack;\n        }\n\n        if (arguments.length <= 2) {\n            accessor = name;\n        }\n\n        var layer = {group: group};\n        if (typeof name === 'string') {\n            layer.name = name;\n        }\n        if (typeof accessor === 'function') {\n            layer.accessor = accessor;\n        }\n        _stack.push(layer);\n\n        return _chart;\n    };\n\n    dc.override(_chart, 'group', function (g, n, f) {\n        if (!arguments.length) {\n            return _chart._group();\n        }\n        _stack = [];\n        _titles = {};\n        _chart.stack(g, n);\n        if (f) {\n            _chart.valueAccessor(f);\n        }\n        return _chart._group(g, n);\n    });\n\n    /**\n     * Allow named stacks to be hidden or shown by clicking on legend items.\n     * This does not affect the behavior of hideStack or showStack.\n     * @method hidableStacks\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {Boolean} [hidableStacks=false]\n     * @returns {Boolean|dc.stackMixin}\n     */\n    _chart.hidableStacks = function (hidableStacks) {\n        if (!arguments.length) {\n            return _hidableStacks;\n        }\n        _hidableStacks = hidableStacks;\n        return _chart;\n    };\n\n    function findLayerByName (n) {\n        var i = _stack.map(dc.pluck('name')).indexOf(n);\n        return _stack[i];\n    }\n\n    /**\n     * Hide all stacks on the chart with the given name.\n     * The chart must be re-rendered for this change to appear.\n     * @method hideStack\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {String} stackName\n     * @returns {dc.stackMixin}\n     */\n    _chart.hideStack = function (stackName) {\n        var layer = findLayerByName(stackName);\n        if (layer) {\n            layer.hidden = true;\n        }\n        return _chart;\n    };\n\n    /**\n     * Show all stacks on the chart with the given name.\n     * The chart must be re-rendered for this change to appear.\n     * @method showStack\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {String} stackName\n     * @returns {dc.stackMixin}\n     */\n    _chart.showStack = function (stackName) {\n        var layer = findLayerByName(stackName);\n        if (layer) {\n            layer.hidden = false;\n        }\n        return _chart;\n    };\n\n    _chart.getValueAccessorByIndex = function (index) {\n        return _stack[index].accessor || _chart.valueAccessor();\n    };\n\n    _chart.yAxisMin = function () {\n        var min = d3.min(flattenStack(), function (p) {\n            return (p.y < 0) ? (p.y + p.y0) : p.y0;\n        });\n\n        return dc.utils.subtract(min, _chart.yAxisPadding());\n\n    };\n\n    _chart.yAxisMax = function () {\n        var max = d3.max(flattenStack(), function (p) {\n            return (p.y > 0) ? (p.y + p.y0) : p.y0;\n        });\n\n        return dc.utils.add(max, _chart.yAxisPadding());\n    };\n\n    function flattenStack () {\n        var valueses = _chart.data().map(function (layer) { return layer.values; });\n        return Array.prototype.concat.apply([], valueses);\n    }\n\n    _chart.xAxisMin = function () {\n        var min = d3.min(flattenStack(), dc.pluck('x'));\n        return dc.utils.subtract(min, _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    };\n\n    _chart.xAxisMax = function () {\n        var max = d3.max(flattenStack(), dc.pluck('x'));\n        return dc.utils.add(max, _chart.xAxisPadding(), _chart.xAxisPaddingUnit());\n    };\n\n    /**\n     * Set or get the title function. Chart class will use this function to render svg title (usually interpreted by\n     * browser as tooltips) for each child element in the chart, i.e. a slice in a pie chart or a bubble in a bubble chart.\n     * Almost every chart supports title function however in grid coordinate chart you need to turn off brush in order to\n     * use title otherwise the brush layer will block tooltip trigger.\n     *\n     * If the first argument is a stack name, the title function will get or set the title for that stack. If stackName\n     * is not provided, the first stack is implied.\n     * @method title\n     * @memberof dc.stackMixin\n     * @instance\n     * @example\n     * // set a title function on 'first stack'\n     * chart.title('first stack', function(d) { return d.key + ': ' + d.value; });\n     * // get a title function from 'second stack'\n     * var secondTitleFunction = chart.title('second stack');\n     * @param {String} [stackName]\n     * @param {Function} [titleAccessor]\n     * @returns {String|dc.stackMixin}\n     */\n    dc.override(_chart, 'title', function (stackName, titleAccessor) {\n        if (!stackName) {\n            return _chart._title();\n        }\n\n        if (typeof stackName === 'function') {\n            return _chart._title(stackName);\n        }\n        if (stackName === _chart._groupName && typeof titleAccessor === 'function') {\n            return _chart._title(titleAccessor);\n        }\n\n        if (typeof titleAccessor !== 'function') {\n            return _titles[stackName] || _chart._title();\n        }\n\n        _titles[stackName] = titleAccessor;\n\n        return _chart;\n    });\n\n    /**\n     * Gets or sets the stack layout algorithm, which computes a baseline for each stack and\n     * propagates it to the next.\n     * @method stackLayout\n     * @memberof dc.stackMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Stack-Layout.md d3.layout.stack}\n     * @param {Function} [stack=d3.layout.stack]\n     * @returns {Function|dc.stackMixin}\n     */\n    _chart.stackLayout = function (stack) {\n        if (!arguments.length) {\n            return _stackLayout;\n        }\n        _stackLayout = stack;\n        if (_stackLayout.values() === d3.layout.stack().values()) {\n            _stackLayout.values(prepareValues);\n        }\n        return _chart;\n    };\n\n    /**\n     * Since dc.js 2.0, there has been {@link https://github.com/dc-js/dc.js/issues/949 an issue}\n     * where points are filtered to the current domain. While this is a useful optimization, it is\n     * incorrectly implemented: the next point outside the domain is required in order to draw lines\n     * that are clipped to the bounds, as well as bars that are partly clipped.\n     *\n     * A fix will be included in dc.js 2.1.x, but a workaround is needed for dc.js 2.0 and until\n     * that fix is published, so set this flag to skip any filtering of points.\n     *\n     * Once the bug is fixed, this flag will have no effect, and it will be deprecated.\n     * @method evadeDomainFilter\n     * @memberof dc.stackMixin\n     * @instance\n     * @param {Boolean} [evadeDomainFilter=false]\n     * @returns {Boolean|dc.stackMixin}\n     */\n    _chart.evadeDomainFilter = function (evadeDomainFilter) {\n        if (!arguments.length) {\n            return _evadeDomainFilter;\n        }\n        _evadeDomainFilter = evadeDomainFilter;\n        return _chart;\n    };\n\n    function visability (l) {\n        return !l.hidden;\n    }\n\n    _chart.data(function () {\n        var layers = _stack.filter(visability);\n        return layers.length ? _chart.stackLayout()(layers) : [];\n    });\n\n    _chart._ordinalXDomain = function () {\n        var flat = flattenStack().map(dc.pluck('data'));\n        var ordered = _chart._computeOrderedGroups(flat);\n        return ordered.map(_chart.keyAccessor());\n    };\n\n    _chart.colorAccessor(function (d) {\n        var layer = this.layer || this.name || d.name || d.layer;\n        return layer;\n    });\n\n    _chart.legendables = function () {\n        return _stack.map(function (layer, i) {\n            return {\n                chart: _chart,\n                name: layer.name,\n                hidden: layer.hidden || false,\n                color: _chart.getColor.call(layer, layer.values, i)\n            };\n        });\n    };\n\n    _chart.isLegendableHidden = function (d) {\n        var layer = findLayerByName(d.name);\n        return layer ? layer.hidden : false;\n    };\n\n    _chart.legendToggle = function (d) {\n        if (_hidableStacks) {\n            if (_chart.isLegendableHidden(d)) {\n                _chart.showStack(d.name);\n            } else {\n                _chart.hideStack(d.name);\n            }\n            //_chart.redraw();\n            _chart.renderGroup();\n        }\n    };\n\n    return _chart;\n};\n\n/**\n * Cap is a mixin that groups small data elements below a _cap_ into an *others* grouping for both the\n * Row and Pie Charts.\n *\n * The top ordered elements in the group up to the cap amount will be kept in the chart, and the rest\n * will be replaced with an *others* element, with value equal to the sum of the replaced values. The\n * keys of the elements below the cap limit are recorded in order to filter by those keys when the\n * others* element is clicked.\n * @name capMixin\n * @memberof dc\n * @mixin\n * @param {Object} _chart\n * @returns {dc.capMixin}\n */\ndc.capMixin = function (_chart) {\n    var _cap = Infinity, _takeFront = true;\n    var _othersLabel = 'Others';\n\n    // emulate old group.top(N) ordering\n    _chart.ordering(function (kv) {\n        return -kv.value;\n    });\n\n    var _othersGrouper = function (topItems, restItems) {\n        var restItemsSum = d3.sum(restItems, _chart.valueAccessor()),\n            restKeys = restItems.map(_chart.keyAccessor());\n        if (restItemsSum > 0) {\n            return topItems.concat([{\n                others: restKeys,\n                key: _chart.othersLabel(),\n                value: restItemsSum\n            }]);\n        }\n        return topItems;\n    };\n\n    _chart.cappedKeyAccessor = function (d, i) {\n        if (d.others) {\n            return d.key;\n        }\n        return _chart.keyAccessor()(d, i);\n    };\n\n    _chart.cappedValueAccessor = function (d, i) {\n        if (d.others) {\n            return d.value;\n        }\n        return _chart.valueAccessor()(d, i);\n    };\n\n    // return N \"top\" groups, where N is the cap, sorted by baseMixin.ordering\n    // whether top means front or back depends on takeFront\n    _chart.data(function (group) {\n        if (_cap === Infinity) {\n            return _chart._computeOrderedGroups(group.all());\n        } else {\n            var items = group.all(), rest;\n            items = _chart._computeOrderedGroups(items); // sort by baseMixin.ordering\n\n            if (_cap) {\n                if (_takeFront) {\n                    rest = items.slice(_cap);\n                    items = items.slice(0, _cap);\n                } else {\n                    var start = Math.max(0, items.length - _cap);\n                    rest = items.slice(0, start);\n                    items = items.slice(start);\n                }\n            }\n\n            if (_othersGrouper) {\n                return _othersGrouper(items, rest);\n            }\n            return items;\n        }\n    });\n\n    /**\n     * Get or set the count of elements to that will be included in the cap. If there is an\n     * {@link dc.capMixin#othersGrouper othersGrouper}, any further elements will be combined in an\n     * extra element with its name determined by {@link dc.capMixin#othersLabel othersLabel}.\n     *\n     * As of dc.js 2.1 and onward, the capped charts use\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_all group.all()}\n     * and {@link dc.baseMixin#ordering baseMixin.ordering()} to determine the order of\n     * elements. Then `cap` and {@link dc.capMixin#takeFront takeFront} determine how many elements\n     * to keep, from which end of the resulting array.\n     *\n     * **Migration note:** Up through dc.js 2.0.*, capping used\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_top group.top(N)},\n     * which selects the largest items according to\n     * {@link https://github.com/crossfilter/crossfilter/wiki/API-Reference#group_order group.order()}.\n     * The chart then sorted the items according to {@link dc.baseMixin#ordering baseMixin.ordering()}.\n     * So the two values essentially had to agree, but if the `group.order()` was incorrect (it's\n     * easy to forget about), the wrong rows or slices would be displayed, in the correct order.\n     *\n     * If your chart previously relied on `group.order()`, use `chart.ordering()` instead. As of\n     * 2.1.5, the ordering defaults to sorting from greatest to least like `group.top(N)` did.\n     *\n     * If you want to cap by one ordering but sort by another, please\n     * [file an issue](https://github.com/dc-js/dc.js/issues/new) - it's still possible but we'll\n     * need to work up an example.\n     * @method cap\n     * @memberof dc.capMixin\n     * @instance\n     * @param {Number} [count=Infinity]\n     * @returns {Number|dc.capMixin}\n     */\n    _chart.cap = function (count) {\n        if (!arguments.length) {\n            return _cap;\n        }\n        _cap = count;\n        return _chart;\n    };\n\n    /**\n     * Get or set the direction of capping. If set, the chart takes the first\n     * {@link dc.capMixin#cap cap} elements from the sorted array of elements; otherwise\n     * it takes the last `cap` elements.\n     * @method takeFront\n     * @memberof dc.capMixin\n     * @instance\n     * @param {Boolean} [takeFront=true]\n     * @returns {Boolean|dc.capMixin}\n     */\n    _chart.takeFront = function (takeFront) {\n        if (!arguments.length) {\n            return _takeFront;\n        }\n        _takeFront = takeFront;\n        return _chart;\n    };\n\n    /**\n     * Get or set the label for *Others* slice when slices cap is specified.\n     * @method othersLabel\n     * @memberof dc.capMixin\n     * @instance\n     * @param {String} [label=\"Others\"]\n     * @returns {String|dc.capMixin}\n     */\n    _chart.othersLabel = function (label) {\n        if (!arguments.length) {\n            return _othersLabel;\n        }\n        _othersLabel = label;\n        return _chart;\n    };\n\n    /**\n     * Get or set the grouper function that will perform the insertion of data for the *Others* slice\n     * if the slices cap is specified. If set to a falsy value, no others will be added.\n     *\n     * The grouper function takes an array of included (\"top\") items, and an array of the rest of\n     * the items. By default the grouper function computes the sum of the rest.\n     * @method othersGrouper\n     * @memberof dc.capMixin\n     * @instance\n     * @example\n     * // Do not show others\n     * chart.othersGrouper(null);\n     * // Default others grouper\n     * chart.othersGrouper(function (topItems, restItems) {\n     *     var restItemsSum = d3.sum(restItems, _chart.valueAccessor()),\n     *         restKeys = restItems.map(_chart.keyAccessor());\n     *     if (restItemsSum > 0) {\n     *         return topItems.concat([{\n     *             others: restKeys,\n     *             key: _chart.othersLabel(),\n     *             value: restItemsSum\n     *         }]);\n     *     }\n     *     return topItems;\n     * });\n     * @param {Function} [grouperFunction]\n     * @returns {Function|dc.capMixin}\n     */\n    _chart.othersGrouper = function (grouperFunction) {\n        if (!arguments.length) {\n            return _othersGrouper;\n        }\n        _othersGrouper = grouperFunction;\n        return _chart;\n    };\n\n    dc.override(_chart, 'onClick', function (d) {\n        if (d.others) {\n            _chart.filter([d.others]);\n        }\n        _chart._onClick(d);\n    });\n\n    return _chart;\n};\n\n/**\n * This Mixin provides reusable functionalities for any chart that needs to visualize data using bubbles.\n * @name bubbleMixin\n * @memberof dc\n * @mixin\n * @mixes dc.colorMixin\n * @param {Object} _chart\n * @returns {dc.bubbleMixin}\n */\ndc.bubbleMixin = function (_chart) {\n    var _maxBubbleRelativeSize = 0.3;\n    var _minRadiusWithLabel = 10;\n    var _sortBubbleSize = false;\n    var _elasticRadius = false;\n\n    _chart.BUBBLE_NODE_CLASS = 'node';\n    _chart.BUBBLE_CLASS = 'bubble';\n    _chart.MIN_RADIUS = 10;\n\n    _chart = dc.colorMixin(_chart);\n\n    _chart.renderLabel(true);\n\n    _chart.data(function (group) {\n        var data = group.all();\n        if (_sortBubbleSize) {\n            // sort descending so smaller bubbles are on top\n            var radiusAccessor = _chart.radiusValueAccessor();\n            data.sort(function (a, b) { return d3.descending(radiusAccessor(a), radiusAccessor(b)); });\n        }\n        return data;\n    });\n\n    var _r = d3.scale.linear().domain([0, 100]);\n\n    var _rValueAccessor = function (d) {\n        return d.r;\n    };\n\n    /**\n     * Get or set the bubble radius scale. By default the bubble chart uses\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md#linear d3.scale.linear().domain([0, 100])}\n     * as its radius scale.\n     * @method r\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @param {d3.scale} [bubbleRadiusScale=d3.scale.linear().domain([0, 100])]\n     * @returns {d3.scale|dc.bubbleMixin}\n     */\n    _chart.r = function (bubbleRadiusScale) {\n        if (!arguments.length) {\n            return _r;\n        }\n        _r = bubbleRadiusScale;\n        return _chart;\n    };\n\n    /**\n     * Turn on or off the elastic bubble radius feature, or return the value of the flag. If this\n     * feature is turned on, then bubble radii will be automatically rescaled to fit the chart better.\n     * @method elasticRadius\n     * @memberof dc.bubbleChart\n     * @instance\n     * @param {Boolean} [elasticRadius=false]\n     * @returns {Boolean|dc.bubbleChart}\n     */\n    _chart.elasticRadius = function (elasticRadius) {\n        if (!arguments.length) {\n            return _elasticRadius;\n        }\n        _elasticRadius = elasticRadius;\n        return _chart;\n    };\n\n    _chart.calculateRadiusDomain = function () {\n        if (_elasticRadius) {\n            _chart.r().domain([_chart.rMin(), _chart.rMax()]);\n        }\n    };\n\n    /**\n     * Get or set the radius value accessor function. If set, the radius value accessor function will\n     * be used to retrieve a data value for each bubble. The data retrieved then will be mapped using\n     * the r scale to the actual bubble radius. This allows you to encode a data dimension using bubble\n     * size.\n     * @method radiusValueAccessor\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Function} [radiusValueAccessor]\n     * @returns {Function|dc.bubbleMixin}\n     */\n    _chart.radiusValueAccessor = function (radiusValueAccessor) {\n        if (!arguments.length) {\n            return _rValueAccessor;\n        }\n        _rValueAccessor = radiusValueAccessor;\n        return _chart;\n    };\n\n    _chart.rMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return _chart.radiusValueAccessor()(e);\n        });\n        return min;\n    };\n\n    _chart.rMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return _chart.radiusValueAccessor()(e);\n        });\n        return max;\n    };\n\n    _chart.bubbleR = function (d) {\n        var value = _chart.radiusValueAccessor()(d);\n        var r = _chart.r()(value);\n        if (isNaN(r) || value <= 0) {\n            r = 0;\n        }\n        return r;\n    };\n\n    var labelFunction = function (d) {\n        return _chart.label()(d);\n    };\n\n    var shouldLabel = function (d) {\n        return (_chart.bubbleR(d) > _minRadiusWithLabel);\n    };\n\n    var labelOpacity = function (d) {\n        return shouldLabel(d) ? 1 : 0;\n    };\n\n    var labelPointerEvent = function (d) {\n        return shouldLabel(d) ? 'all' : 'none';\n    };\n\n    _chart._doRenderLabel = function (bubbleGEnter) {\n        if (_chart.renderLabel()) {\n            var label = bubbleGEnter.select('text');\n\n            if (label.empty()) {\n                label = bubbleGEnter.append('text')\n                    .attr('text-anchor', 'middle')\n                    .attr('dy', '.3em')\n                    .on('click', _chart.onClick);\n            }\n\n            label\n                .attr('opacity', 0)\n                .attr('pointer-events', labelPointerEvent)\n                .text(labelFunction);\n            dc.transition(label, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', labelOpacity);\n        }\n    };\n\n    _chart.doUpdateLabels = function (bubbleGEnter) {\n        if (_chart.renderLabel()) {\n            var labels = bubbleGEnter.select('text')\n                .attr('pointer-events', labelPointerEvent)\n                .text(labelFunction);\n            dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('opacity', labelOpacity);\n        }\n    };\n\n    var titleFunction = function (d) {\n        return _chart.title()(d);\n    };\n\n    _chart._doRenderTitles = function (g) {\n        if (_chart.renderTitle()) {\n            var title = g.select('title');\n\n            if (title.empty()) {\n                g.append('title').text(titleFunction);\n            }\n        }\n    };\n\n    _chart.doUpdateTitles = function (g) {\n        if (_chart.renderTitle()) {\n            g.select('title').text(titleFunction);\n        }\n    };\n\n    /**\n     * Turn on or off the bubble sorting feature, or return the value of the flag. If enabled,\n     * bubbles will be sorted by their radius, with smaller bubbles in front.\n     * @method sortBubbleSize\n     * @memberof dc.bubbleChart\n     * @instance\n     * @param {Boolean} [sortBubbleSize=false]\n     * @returns {Boolean|dc.bubbleChart}\n     */\n    _chart.sortBubbleSize = function (sortBubbleSize) {\n        if (!arguments.length) {\n            return _sortBubbleSize;\n        }\n        _sortBubbleSize = sortBubbleSize;\n        return _chart;\n    };\n\n    /**\n     * Get or set the minimum radius. This will be used to initialize the radius scale's range.\n     * @method minRadius\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Number} [radius=10]\n     * @returns {Number|dc.bubbleMixin}\n     */\n    _chart.minRadius = function (radius) {\n        if (!arguments.length) {\n            return _chart.MIN_RADIUS;\n        }\n        _chart.MIN_RADIUS = radius;\n        return _chart;\n    };\n\n    /**\n     * Get or set the minimum radius for label rendering. If a bubble's radius is less than this value\n     * then no label will be rendered.\n     * @method minRadiusWithLabel\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Number} [radius=10]\n     * @returns {Number|dc.bubbleMixin}\n     */\n\n    _chart.minRadiusWithLabel = function (radius) {\n        if (!arguments.length) {\n            return _minRadiusWithLabel;\n        }\n        _minRadiusWithLabel = radius;\n        return _chart;\n    };\n\n    /**\n     * Get or set the maximum relative size of a bubble to the length of x axis. This value is useful\n     * when the difference in radius between bubbles is too great.\n     * @method maxBubbleRelativeSize\n     * @memberof dc.bubbleMixin\n     * @instance\n     * @param {Number} [relativeSize=0.3]\n     * @returns {Number|dc.bubbleMixin}\n     */\n    _chart.maxBubbleRelativeSize = function (relativeSize) {\n        if (!arguments.length) {\n            return _maxBubbleRelativeSize;\n        }\n        _maxBubbleRelativeSize = relativeSize;\n        return _chart;\n    };\n\n    _chart.fadeDeselectedArea = function () {\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.' + _chart.BUBBLE_NODE_CLASS).each(function (d) {\n                if (_chart.isSelectedNode(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.' + _chart.BUBBLE_NODE_CLASS).each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(d.key);\n    };\n\n    _chart.onClick = function (d) {\n        var filter = d.key;\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    return _chart;\n};\n\n/**\n * The pie chart implementation is usually used to visualize a small categorical distribution.  The pie\n * chart uses keyAccessor to determine the slices, and valueAccessor to calculate the size of each\n * slice relative to the sum of all values. Slices are ordered by {@link dc.baseMixin#ordering ordering}\n * which defaults to sorting by key.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * @class pieChart\n * @memberof dc\n * @mixes dc.capMixin\n * @mixes dc.colorMixin\n * @mixes dc.baseMixin\n * @example\n * // create a pie chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.pieChart('#chart-container1');\n * // create a pie chart under #chart-container2 element using chart group A\n * var chart2 = dc.pieChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.pieChart}\n */\ndc.pieChart = function (parent, chartGroup) {\n    var DEFAULT_MIN_ANGLE_FOR_LABEL = 0.5;\n\n    var _sliceCssClass = 'pie-slice';\n    var _labelCssClass = 'pie-label';\n    var _sliceGroupCssClass = 'pie-slice-group';\n    var _labelGroupCssClass = 'pie-label-group';\n    var _emptyCssClass = 'empty-chart';\n    var _emptyTitle = 'empty';\n\n    var _radius,\n        _givenRadius, // specified radius, if any\n        _innerRadius = 0,\n        _externalRadiusPadding = 0;\n\n    var _g;\n    var _cx;\n    var _cy;\n    var _minAngleForLabel = DEFAULT_MIN_ANGLE_FOR_LABEL;\n    var _externalLabelRadius;\n    var _drawPaths = false;\n    var _chart = dc.capMixin(dc.colorMixin(dc.baseMixin({})));\n\n    _chart.colorAccessor(_chart.cappedKeyAccessor);\n\n    _chart.title(function (d) {\n        return _chart.cappedKeyAccessor(d) + ': ' + _chart.cappedValueAccessor(d);\n    });\n\n    /**\n     * Get or set the maximum number of slices the pie chart will generate. The top slices are determined by\n     * value from high to low. Other slices exeeding the cap will be rolled up into one single *Others* slice.\n     * @method slicesCap\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [cap]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.slicesCap = _chart.cap;\n\n    _chart.label(_chart.cappedKeyAccessor);\n    _chart.renderLabel(true);\n\n    _chart.transitionDuration(350);\n    _chart.transitionDelay(0);\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _g = _chart.svg()\n            .append('g')\n            .attr('transform', 'translate(' + _chart.cx() + ',' + _chart.cy() + ')');\n\n        _g.append('g').attr('class', _sliceGroupCssClass);\n        _g.append('g').attr('class', _labelGroupCssClass);\n\n        drawChart();\n\n        return _chart;\n    };\n\n    function drawChart () {\n        // set radius from chart size if none given, or if given radius is too large\n        var maxRadius =  d3.min([_chart.width(), _chart.height()]) / 2;\n        _radius = _givenRadius && _givenRadius < maxRadius ? _givenRadius : maxRadius;\n\n        var arc = buildArcs();\n\n        var pie = pieLayout();\n        var pieData;\n        // if we have data...\n        if (d3.sum(_chart.data(), _chart.valueAccessor())) {\n            pieData = pie(_chart.data());\n            _g.classed(_emptyCssClass, false);\n        } else {\n            // otherwise we'd be getting NaNs, so override\n            // note: abuse others for its ignoring the value accessor\n            pieData = pie([{key: _emptyTitle, value: 1, others: [_emptyTitle]}]);\n            _g.classed(_emptyCssClass, true);\n        }\n\n        if (_g) {\n            var slices = _g.select('g.' + _sliceGroupCssClass)\n                .selectAll('g.' + _sliceCssClass)\n                .data(pieData);\n\n            var labels = _g.select('g.' + _labelGroupCssClass)\n                .selectAll('text.' + _labelCssClass)\n                .data(pieData);\n\n            createElements(slices, labels, arc, pieData);\n\n            updateElements(pieData, arc);\n\n            removeElements(slices, labels);\n\n            highlightFilter();\n\n            dc.transition(_g, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('transform', 'translate(' + _chart.cx() + ',' + _chart.cy() + ')');\n        }\n    }\n\n    function createElements (slices, labels, arc, pieData) {\n        var slicesEnter = createSliceNodes(slices);\n\n        createSlicePath(slicesEnter, arc);\n\n        createTitles(slicesEnter);\n\n        createLabels(labels, pieData, arc);\n    }\n\n    function createSliceNodes (slices) {\n        var slicesEnter = slices\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return _sliceCssClass + ' _' + i;\n            });\n        return slicesEnter;\n    }\n\n    function createSlicePath (slicesEnter, arc) {\n        var slicePath = slicesEnter.append('path')\n            .attr('fill', fill)\n            .on('click', onClick)\n            .attr('d', function (d, i) {\n                return safeArc(d, i, arc);\n            });\n\n        var transition = dc.transition(slicePath, _chart.transitionDuration(), _chart.transitionDelay());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenPie);\n        }\n    }\n\n    function createTitles (slicesEnter) {\n        if (_chart.renderTitle()) {\n            slicesEnter.append('title').text(function (d) {\n                return _chart.title()(d.data);\n            });\n        }\n    }\n\n    _chart._applyLabelText = function (labels) {\n        labels\n            .text(function (d) {\n                var data = d.data;\n                if ((sliceHasNoData(data) || sliceTooSmall(d)) && !isSelectedSlice(d)) {\n                    return '';\n                }\n                return _chart.label()(d.data);\n            });\n    };\n\n    function positionLabels (labels, arc) {\n        _chart._applyLabelText(labels);\n        dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', function (d) {\n                return labelPosition(d, arc);\n            })\n            .attr('text-anchor', 'middle');\n    }\n\n    function highlightSlice (i, whether) {\n        _chart.select('g.pie-slice._' + i)\n            .classed('highlight', whether);\n    }\n\n    function createLabels (labels, pieData, arc) {\n        if (_chart.renderLabel()) {\n            var labelsEnter = labels\n                .enter()\n                .append('text')\n                .attr('class', function (d, i) {\n                    var classes = _sliceCssClass + ' ' + _labelCssClass + ' _' + i;\n                    if (_externalLabelRadius) {\n                        classes += ' external';\n                    }\n                    return classes;\n                })\n                .on('click', onClick)\n                .on('mouseover', function (d, i) {\n                    highlightSlice(i, true);\n                })\n                .on('mouseout', function (d, i) {\n                    highlightSlice(i, false);\n                });\n            positionLabels(labelsEnter, arc);\n            if (_externalLabelRadius && _drawPaths) {\n                updateLabelPaths(pieData, arc);\n            }\n        }\n    }\n\n    function updateLabelPaths (pieData, arc) {\n        var polyline = _g.selectAll('polyline.' + _sliceCssClass)\n                .data(pieData);\n\n        polyline\n                .enter()\n                .append('polyline')\n                .attr('class', function (d, i) {\n                    return 'pie-path _' + i + ' ' + _sliceCssClass;\n                })\n                .on('click', onClick)\n                .on('mouseover', function (d, i) {\n                    highlightSlice(i, true);\n                })\n                .on('mouseout', function (d, i) {\n                    highlightSlice(i, false);\n                });\n\n        polyline.exit().remove();\n        var arc2 = d3.svg.arc()\n                .outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius)\n                .innerRadius(_radius - _externalRadiusPadding);\n        var transition = dc.transition(polyline, _chart.transitionDuration(), _chart.transitionDelay());\n        // this is one rare case where d3.selection differs from d3.transition\n        if (transition.attrTween) {\n            transition\n                .attrTween('points', function (d) {\n                    var current = this._current || d;\n                    current = {startAngle: current.startAngle, endAngle: current.endAngle};\n                    var interpolate = d3.interpolate(current, d);\n                    this._current = interpolate(0);\n                    return function (t) {\n                        var d2 = interpolate(t);\n                        return [arc.centroid(d2), arc2.centroid(d2)];\n                    };\n                });\n        } else {\n            transition.attr('points', function (d) {\n                return [arc.centroid(d), arc2.centroid(d)];\n            });\n        }\n        transition.style('visibility', function (d) {\n            return d.endAngle - d.startAngle < 0.0001 ? 'hidden' : 'visible';\n        });\n\n    }\n\n    function updateElements (pieData, arc) {\n        updateSlicePaths(pieData, arc);\n        updateLabels(pieData, arc);\n        updateTitles(pieData);\n    }\n\n    function updateSlicePaths (pieData, arc) {\n        var slicePaths = _g.selectAll('g.' + _sliceCssClass)\n            .data(pieData)\n            .select('path')\n            .attr('d', function (d, i) {\n                return safeArc(d, i, arc);\n            });\n        var transition = dc.transition(slicePaths, _chart.transitionDuration(), _chart.transitionDelay());\n        if (transition.attrTween) {\n            transition.attrTween('d', tweenPie);\n        }\n        transition.attr('fill', fill);\n    }\n\n    function updateLabels (pieData, arc) {\n        if (_chart.renderLabel()) {\n            var labels = _g.selectAll('text.' + _labelCssClass)\n                .data(pieData);\n            positionLabels(labels, arc);\n            if (_externalLabelRadius && _drawPaths) {\n                updateLabelPaths(pieData, arc);\n            }\n        }\n    }\n\n    function updateTitles (pieData) {\n        if (_chart.renderTitle()) {\n            _g.selectAll('g.' + _sliceCssClass)\n                .data(pieData)\n                .select('title')\n                .text(function (d) {\n                    return _chart.title()(d.data);\n                });\n        }\n    }\n\n    function removeElements (slices, labels) {\n        slices.exit().remove();\n        labels.exit().remove();\n    }\n\n    function highlightFilter () {\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.' + _sliceCssClass).each(function (d) {\n                if (isSelectedSlice(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.' + _sliceCssClass).each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    }\n\n    /**\n     * Get or set the external radius padding of the pie chart. This will force the radius of the\n     * pie chart to become smaller or larger depending on the value.\n     * @method externalRadiusPadding\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [externalRadiusPadding=0]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.externalRadiusPadding = function (externalRadiusPadding) {\n        if (!arguments.length) {\n            return _externalRadiusPadding;\n        }\n        _externalRadiusPadding = externalRadiusPadding;\n        return _chart;\n    };\n\n    /**\n     * Get or set the inner radius of the pie chart. If the inner radius is greater than 0px then the\n     * pie chart will be rendered as a doughnut chart.\n     * @method innerRadius\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [innerRadius=0]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.innerRadius = function (innerRadius) {\n        if (!arguments.length) {\n            return _innerRadius;\n        }\n        _innerRadius = innerRadius;\n        return _chart;\n    };\n\n    /**\n     * Get or set the outer radius. If the radius is not set, it will be half of the minimum of the\n     * chart width and height.\n     * @method radius\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [radius]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.radius = function (radius) {\n        if (!arguments.length) {\n            return _givenRadius;\n        }\n        _givenRadius = radius;\n        return _chart;\n    };\n\n    /**\n     * Get or set center x coordinate position. Default is center of svg.\n     * @method cx\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [cx]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.cx = function (cx) {\n        if (!arguments.length) {\n            return (_cx ||  _chart.width() / 2);\n        }\n        _cx = cx;\n        return _chart;\n    };\n\n    /**\n     * Get or set center y coordinate position. Default is center of svg.\n     * @method cy\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [cy]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.cy = function (cy) {\n        if (!arguments.length) {\n            return (_cy ||  _chart.height() / 2);\n        }\n        _cy = cy;\n        return _chart;\n    };\n\n    function buildArcs () {\n        return d3.svg.arc()\n            .outerRadius(_radius - _externalRadiusPadding)\n            .innerRadius(_innerRadius);\n    }\n\n    function isSelectedSlice (d) {\n        return _chart.hasFilter(_chart.cappedKeyAccessor(d.data));\n    }\n\n    _chart._doRedraw = function () {\n        drawChart();\n        return _chart;\n    };\n\n    /**\n     * Get or set the minimal slice angle for label rendering. Any slice with a smaller angle will not\n     * display a slice label.\n     * @method minAngleForLabel\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [minAngleForLabel=0.5]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.minAngleForLabel = function (minAngleForLabel) {\n        if (!arguments.length) {\n            return _minAngleForLabel;\n        }\n        _minAngleForLabel = minAngleForLabel;\n        return _chart;\n    };\n\n    function pieLayout () {\n        return d3.layout.pie().sort(null).value(_chart.cappedValueAccessor);\n    }\n\n    function sliceTooSmall (d) {\n        var angle = (d.endAngle - d.startAngle);\n        return isNaN(angle) || angle < _minAngleForLabel;\n    }\n\n    function sliceHasNoData (d) {\n        return _chart.cappedValueAccessor(d) === 0;\n    }\n\n    function tweenPie (b) {\n        b.innerRadius = _innerRadius;\n        var current = this._current;\n        if (isOffCanvas(current)) {\n            current = {startAngle: 0, endAngle: 0};\n        } else {\n            // only interpolate startAngle & endAngle, not the whole data object\n            current = {startAngle: current.startAngle, endAngle: current.endAngle};\n        }\n        var i = d3.interpolate(current, b);\n        this._current = i(0);\n        return function (t) {\n            return safeArc(i(t), 0, buildArcs());\n        };\n    }\n\n    function isOffCanvas (current) {\n        return !current || isNaN(current.startAngle) || isNaN(current.endAngle);\n    }\n\n    function fill (d, i) {\n        return _chart.getColor(d.data, i);\n    }\n\n    function onClick (d, i) {\n        if (_g.attr('class') !== _emptyCssClass) {\n            _chart.onClick(d.data, i);\n        }\n    }\n\n    function safeArc (d, i, arc) {\n        var path = arc(d, i);\n        if (path.indexOf('NaN') >= 0) {\n            path = 'M0,0';\n        }\n        return path;\n    }\n\n    /**\n     * Title to use for the only slice when there is no data.\n     * @method emptyTitle\n     * @memberof dc.pieChart\n     * @instance\n     * @param {String} [title]\n     * @returns {String|dc.pieChart}\n     */\n    _chart.emptyTitle = function (title) {\n        if (arguments.length === 0) {\n            return _emptyTitle;\n        }\n        _emptyTitle = title;\n        return _chart;\n    };\n\n    /**\n     * Position slice labels offset from the outer edge of the chart.\n     *\n     * The argument specifies the extra radius to be added for slice labels.\n     * @method externalLabels\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Number} [externalLabelRadius]\n     * @returns {Number|dc.pieChart}\n     */\n    _chart.externalLabels = function (externalLabelRadius) {\n        if (arguments.length === 0) {\n            return _externalLabelRadius;\n        } else if (externalLabelRadius) {\n            _externalLabelRadius = externalLabelRadius;\n        } else {\n            _externalLabelRadius = undefined;\n        }\n\n        return _chart;\n    };\n\n    /**\n     * Get or set whether to draw lines from pie slices to their labels.\n     *\n     * @method drawPaths\n     * @memberof dc.pieChart\n     * @instance\n     * @param {Boolean} [drawPaths]\n     * @returns {Boolean|dc.pieChart}\n     */\n    _chart.drawPaths = function (drawPaths) {\n        if (arguments.length === 0) {\n            return _drawPaths;\n        }\n        _drawPaths = drawPaths;\n        return _chart;\n    };\n\n    function labelPosition (d, arc) {\n        var centroid;\n        if (_externalLabelRadius) {\n            centroid = d3.svg.arc()\n                .outerRadius(_radius - _externalRadiusPadding + _externalLabelRadius)\n                .innerRadius(_radius - _externalRadiusPadding + _externalLabelRadius)\n                .centroid(d);\n        } else {\n            centroid = arc.centroid(d);\n        }\n        if (isNaN(centroid[0]) || isNaN(centroid[1])) {\n            return 'translate(0,0)';\n        } else {\n            return 'translate(' + centroid + ')';\n        }\n    }\n\n    _chart.legendables = function () {\n        return _chart.data().map(function (d, i) {\n            var legendable = {name: d.key, data: d.value, others: d.others, chart: _chart};\n            legendable.color = _chart.getColor(d, i);\n            return legendable;\n        });\n    };\n\n    _chart.legendHighlight = function (d) {\n        highlightSliceFromLegendable(d, true);\n    };\n\n    _chart.legendReset = function (d) {\n        highlightSliceFromLegendable(d, false);\n    };\n\n    _chart.legendToggle = function (d) {\n        _chart.onClick({key: d.name, others: d.others});\n    };\n\n    function highlightSliceFromLegendable (legendable, highlighted) {\n        _chart.selectAll('g.pie-slice').each(function (d) {\n            if (legendable.name === d.data.key) {\n                d3.select(this).classed('highlight', highlighted);\n            }\n        });\n    }\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Concrete bar chart/histogram implementation.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class barChart\n * @memberof dc\n * @mixes dc.stackMixin\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a bar chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.barChart('#chart-container1');\n * // create a bar chart under #chart-container2 element using chart group A\n * var chart2 = dc.barChart('#chart-container2', 'chartGroupA');\n * // create a sub-chart under a composite parent chart\n * var chart3 = dc.barChart(compositeChart);\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}\n * specifying a dom block element such as a div; or a dom element or d3 selection.  If the bar\n * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent\n * composite chart instance instead.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.barChart}\n */\ndc.barChart = function (parent, chartGroup) {\n    var MIN_BAR_WIDTH = 1;\n    var DEFAULT_GAP_BETWEEN_BARS = 2;\n    var LABEL_PADDING = 3;\n\n    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));\n\n    var _gap = DEFAULT_GAP_BETWEEN_BARS;\n    var _centerBar = false;\n    var _alwaysUseRounding = false;\n\n    var _barWidth;\n\n    dc.override(_chart, 'rescale', function () {\n        _chart._rescale();\n        _barWidth = undefined;\n        return _chart;\n    });\n\n    dc.override(_chart, 'render', function () {\n        if (_chart.round() && _centerBar && !_alwaysUseRounding) {\n            dc.logger.warn('By default, brush rounding is disabled if bars are centered. ' +\n                         'See dc.js bar chart API documentation for details.');\n        }\n\n        return _chart._render();\n    });\n\n    _chart.label(function (d) {\n        return dc.utils.printSingleValue(d.y0 + d.y);\n    }, false);\n\n    _chart.plotData = function () {\n        var layers = _chart.chartBodyG().selectAll('g.stack')\n            .data(_chart.data());\n\n        calculateBarWidth();\n\n        layers\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return 'stack ' + '_' + i;\n            });\n\n        var last = layers.size() - 1;\n        layers.each(function (d, i) {\n            var layer = d3.select(this);\n\n            renderBars(layer, i, d);\n\n            if (_chart.renderLabel() && last === i) {\n                renderLabels(layer, i, d);\n            }\n        });\n    };\n\n    function barHeight (d) {\n        return dc.utils.safeNumber(Math.abs(_chart.y()(d.y + d.y0) - _chart.y()(d.y0)));\n    }\n\n    function renderLabels (layer, layerIndex, d) {\n        var labels = layer.selectAll('text.barLabel')\n            .data(d.values, dc.pluck('x'));\n\n        labels.enter()\n            .append('text')\n            .attr('class', 'barLabel')\n            .attr('text-anchor', 'middle');\n\n        if (_chart.isOrdinal()) {\n            labels.on('click', _chart.onClick);\n            labels.attr('cursor', 'pointer');\n        }\n\n        dc.transition(labels, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d) {\n                var x = _chart.x()(d.x);\n                if (!_centerBar) {\n                    x += _barWidth / 2;\n                }\n                return dc.utils.safeNumber(x);\n            })\n            .attr('y', function (d) {\n                var y = _chart.y()(d.y + d.y0);\n\n                if (d.y < 0) {\n                    y -= barHeight(d);\n                }\n\n                return dc.utils.safeNumber(y - LABEL_PADDING);\n            })\n            .text(function (d) {\n                return _chart.label()(d);\n            });\n\n        dc.transition(labels.exit(), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('height', 0)\n            .remove();\n    }\n\n    function renderBars (layer, layerIndex, d) {\n        var bars = layer.selectAll('rect.bar')\n            .data(d.values, dc.pluck('x'));\n\n        var enter = bars.enter()\n            .append('rect')\n            .attr('class', 'bar')\n            .attr('fill', dc.pluck('data', _chart.getColor))\n            .attr('y', _chart.yAxisHeight())\n            .attr('height', 0);\n\n        if (_chart.renderTitle()) {\n            enter.append('title').text(dc.pluck('data', _chart.title(d.name)));\n        }\n\n        if (_chart.isOrdinal()) {\n            bars.on('click', _chart.onClick);\n        }\n\n        dc.transition(bars, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d) {\n                var x = _chart.x()(d.x);\n                if (_centerBar) {\n                    x -= _barWidth / 2;\n                }\n                if (_chart.isOrdinal() && _gap !== undefined) {\n                    x += _gap / 2;\n                }\n                return dc.utils.safeNumber(x);\n            })\n            .attr('y', function (d) {\n                var y = _chart.y()(d.y + d.y0);\n\n                if (d.y < 0) {\n                    y -= barHeight(d);\n                }\n\n                return dc.utils.safeNumber(y);\n            })\n            .attr('width', _barWidth)\n            .attr('height', function (d) {\n                return barHeight(d);\n            })\n            .attr('fill', dc.pluck('data', _chart.getColor))\n            .select('title').text(dc.pluck('data', _chart.title(d.name)));\n\n        dc.transition(bars.exit(), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d) { return _chart.x()(d.x); })\n            .attr('width', _barWidth * 0.9)\n            .remove();\n    }\n\n    function calculateBarWidth () {\n        if (_barWidth === undefined) {\n            var numberOfBars = _chart.xUnitCount();\n\n            // please can't we always use rangeBands for bar charts?\n            if (_chart.isOrdinal() && _gap === undefined) {\n                _barWidth = Math.floor(_chart.x().rangeBand());\n            } else if (_gap) {\n                _barWidth = Math.floor((_chart.xAxisLength() - (numberOfBars - 1) * _gap) / numberOfBars);\n            } else {\n                _barWidth = Math.floor(_chart.xAxisLength() / (1 + _chart.barPadding()) / numberOfBars);\n            }\n\n            if (_barWidth === Infinity || isNaN(_barWidth) || _barWidth < MIN_BAR_WIDTH) {\n                _barWidth = MIN_BAR_WIDTH;\n            }\n        }\n    }\n\n    _chart.fadeDeselectedArea = function () {\n        var bars = _chart.chartBodyG().selectAll('rect.bar');\n        var extent = _chart.brush().extent();\n\n        if (_chart.isOrdinal()) {\n            if (_chart.hasFilter()) {\n                bars.classed(dc.constants.SELECTED_CLASS, function (d) {\n                    return _chart.hasFilter(d.x);\n                });\n                bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n                    return !_chart.hasFilter(d.x);\n                });\n            } else {\n                bars.classed(dc.constants.SELECTED_CLASS, false);\n                bars.classed(dc.constants.DESELECTED_CLASS, false);\n            }\n        } else {\n            if (!_chart.brushIsEmpty(extent)) {\n                var start = extent[0];\n                var end = extent[1];\n\n                bars.classed(dc.constants.DESELECTED_CLASS, function (d) {\n                    return d.x < start || d.x >= end;\n                });\n            } else {\n                bars.classed(dc.constants.DESELECTED_CLASS, false);\n            }\n        }\n    };\n\n    /**\n     * Whether the bar chart will render each bar centered around the data position on the x-axis.\n     * @method centerBar\n     * @memberof dc.barChart\n     * @instance\n     * @param {Boolean} [centerBar=false]\n     * @returns {Boolean|dc.barChart}\n     */\n    _chart.centerBar = function (centerBar) {\n        if (!arguments.length) {\n            return _centerBar;\n        }\n        _centerBar = centerBar;\n        return _chart;\n    };\n\n    dc.override(_chart, 'onClick', function (d) {\n        _chart._onClick(d.data);\n    });\n\n    /**\n     * Get or set the spacing between bars as a fraction of bar size. Valid values are between 0-1.\n     * Setting this value will also remove any previously set {@link dc.barChart#gap gap}. See the\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3 docs}\n     * for a visual description of how the padding is applied.\n     * @method barPadding\n     * @memberof dc.barChart\n     * @instance\n     * @param {Number} [barPadding=0]\n     * @returns {Number|dc.barChart}\n     */\n    _chart.barPadding = function (barPadding) {\n        if (!arguments.length) {\n            return _chart._rangeBandPadding();\n        }\n        _chart._rangeBandPadding(barPadding);\n        _gap = undefined;\n        return _chart;\n    };\n\n    _chart._useOuterPadding = function () {\n        return _gap === undefined;\n    };\n\n    /**\n     * Get or set the outer padding on an ordinal bar chart. This setting has no effect on non-ordinal charts.\n     * Will pad the width by `padding * barWidth` on each side of the chart.\n     * @method outerPadding\n     * @memberof dc.barChart\n     * @instance\n     * @param {Number} [padding=0.5]\n     * @returns {Number|dc.barChart}\n     */\n    _chart.outerPadding = _chart._outerRangeBandPadding;\n\n    /**\n     * Manually set fixed gap (in px) between bars instead of relying on the default auto-generated\n     * gap.  By default the bar chart implementation will calculate and set the gap automatically\n     * based on the number of data points and the length of the x axis.\n     * @method gap\n     * @memberof dc.barChart\n     * @instance\n     * @param {Number} [gap=2]\n     * @returns {Number|dc.barChart}\n     */\n    _chart.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _chart;\n    };\n\n    _chart.extendBrush = function () {\n        var extent = _chart.brush().extent();\n        if (_chart.round() && (!_centerBar || _alwaysUseRounding)) {\n            extent[0] = extent.map(_chart.round())[0];\n            extent[1] = extent.map(_chart.round())[1];\n\n            _chart.chartBodyG().select('.brush')\n                .call(_chart.brush().extent(extent));\n        }\n\n        return extent;\n    };\n\n    /**\n     * Set or get whether rounding is enabled when bars are centered. If false, using\n     * rounding with centered bars will result in a warning and rounding will be ignored.  This flag\n     * has no effect if bars are not {@link dc.barChart#centerBar centered}.\n     * When using standard d3.js rounding methods, the brush often doesn't align correctly with\n     * centered bars since the bars are offset.  The rounding function must add an offset to\n     * compensate, such as in the following example.\n     * @method alwaysUseRounding\n     * @memberof dc.barChart\n     * @instance\n     * @example\n     * chart.round(function(n) { return Math.floor(n) + 0.5; });\n     * @param {Boolean} [alwaysUseRounding=false]\n     * @returns {Boolean|dc.barChart}\n     */\n    _chart.alwaysUseRounding = function (alwaysUseRounding) {\n        if (!arguments.length) {\n            return _alwaysUseRounding;\n        }\n        _alwaysUseRounding = alwaysUseRounding;\n        return _chart;\n    };\n\n    function colorFilter (color, inv) {\n        return function () {\n            var item = d3.select(this);\n            var match = item.attr('fill') === color;\n            return inv ? !match : match;\n        };\n    }\n\n    _chart.legendHighlight = function (d) {\n        if (!_chart.isLegendableHidden(d)) {\n            _chart.g().selectAll('rect.bar')\n                .classed('highlight', colorFilter(d.color))\n                .classed('fadeout', colorFilter(d.color, true));\n        }\n    };\n\n    _chart.legendReset = function () {\n        _chart.g().selectAll('rect.bar')\n            .classed('highlight', false)\n            .classed('fadeout', false);\n    };\n\n    dc.override(_chart, 'xAxisMax', function () {\n        var max = this._xAxisMax();\n        if ('resolution' in _chart.xUnits()) {\n            var res = _chart.xUnits().resolution;\n            max += res;\n        }\n        return max;\n    });\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Concrete line/area chart implementation.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class lineChart\n * @memberof dc\n * @mixes dc.stackMixin\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a line chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.lineChart('#chart-container1');\n * // create a line chart under #chart-container2 element using chart group A\n * var chart2 = dc.lineChart('#chart-container2', 'chartGroupA');\n * // create a sub-chart under a composite parent chart\n * var chart3 = dc.lineChart(compositeChart);\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector}\n * specifying a dom block element such as a div; or a dom element or d3 selection.  If the line\n * chart is a sub-chart in a {@link dc.compositeChart Composite Chart} then pass in the parent\n * composite chart instance instead.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.lineChart}\n */\ndc.lineChart = function (parent, chartGroup) {\n    var DEFAULT_DOT_RADIUS = 5;\n    var TOOLTIP_G_CLASS = 'dc-tooltip';\n    var DOT_CIRCLE_CLASS = 'dot';\n    var Y_AXIS_REF_LINE_CLASS = 'yRef';\n    var X_AXIS_REF_LINE_CLASS = 'xRef';\n    var DEFAULT_DOT_OPACITY = 1e-6;\n    var LABEL_PADDING = 3;\n\n    var _chart = dc.stackMixin(dc.coordinateGridMixin({}));\n    var _renderArea = false;\n    var _dotRadius = DEFAULT_DOT_RADIUS;\n    var _dataPointRadius = null;\n    var _dataPointFillOpacity = DEFAULT_DOT_OPACITY;\n    var _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;\n    var _interpolate = 'linear';\n    var _tension = 0.7;\n    var _defined;\n    var _dashStyle;\n    var _xyTipsOn = true;\n\n    _chart.transitionDuration(500);\n    _chart.transitionDelay(0);\n    _chart._rangeBandPadding(1);\n\n    _chart.plotData = function () {\n        var chartBody = _chart.chartBodyG();\n        var layersList = chartBody.select('g.stack-list');\n\n        if (layersList.empty()) {\n            layersList = chartBody.append('g').attr('class', 'stack-list');\n        }\n\n        var layers = layersList.selectAll('g.stack').data(_chart.data());\n\n        var layersEnter = layers\n            .enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return 'stack ' + '_' + i;\n            });\n\n        drawLine(layersEnter, layers);\n\n        drawArea(layersEnter, layers);\n\n        drawDots(chartBody, layers);\n\n        if (_chart.renderLabel()) {\n            drawLabels(layers);\n        }\n    };\n\n    /**\n     * Gets or sets the interpolator to use for lines drawn, by string name, allowing e.g. step\n     * functions, splines, and cubic interpolation.  This is passed to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate} and\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate},\n     * where you can find a complete list of valid arguments.\n     * @method interpolate\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate}\n     * @param  {String} [interpolate='linear']\n     * @returns {String|dc.lineChart}\n     */\n    _chart.interpolate = function (interpolate) {\n        if (!arguments.length) {\n            return _interpolate;\n        }\n        _interpolate = interpolate;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the tension to use for lines drawn, in the range 0 to 1.\n     * This parameter further customizes the interpolation behavior.  It is passed to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_tension d3.svg.line.tension} and\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_tension d3.svg.area.tension}.\n     * @method tension\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate d3.svg.line.interpolate}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#area_interpolate d3.svg.area.interpolate}\n     * @param  {Number} [tension=0.7]\n     * @returns {Number|dc.lineChart}\n     */\n    _chart.tension = function (tension) {\n        if (!arguments.length) {\n            return _tension;\n        }\n        _tension = tension;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets a function that will determine discontinuities in the line which should be\n     * skipped: the path will be broken into separate subpaths if some points are undefined.\n     * This function is passed to\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_defined d3.svg.line.defined}\n     *\n     * Note: crossfilter will sometimes coerce nulls to 0, so you may need to carefully write\n     * custom reduce functions to get this to work, depending on your data. See\n     * {@link https://github.com/dc-js/dc.js/issues/615#issuecomment-49089248 this GitHub comment}\n     * for more details and an example.\n     * @method defined\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_defined d3.svg.line.defined}\n     * @param  {Function} [defined]\n     * @returns {Function|dc.lineChart}\n     */\n    _chart.defined = function (defined) {\n        if (!arguments.length) {\n            return _defined;\n        }\n        _defined = defined;\n        return _chart;\n    };\n\n    /**\n     * Set the line's d3 dashstyle. This value becomes the 'stroke-dasharray' of line. Defaults to empty\n     * array (solid line).\n     * @method dashStyle\n     * @memberof dc.lineChart\n     * @instance\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray stroke-dasharray}\n     * @example\n     * // create a Dash Dot Dot Dot\n     * chart.dashStyle([3,1,1,1]);\n     * @param  {Array<Number>} [dashStyle=[]]\n     * @returns {Array<Number>|dc.lineChart}\n     */\n    _chart.dashStyle = function (dashStyle) {\n        if (!arguments.length) {\n            return _dashStyle;\n        }\n        _dashStyle = dashStyle;\n        return _chart;\n    };\n\n    /**\n     * Get or set render area flag. If the flag is set to true then the chart will render the area\n     * beneath each line and the line chart effectively becomes an area chart.\n     * @method renderArea\n     * @memberof dc.lineChart\n     * @instance\n     * @param  {Boolean} [renderArea=false]\n     * @returns {Boolean|dc.lineChart}\n     */\n    _chart.renderArea = function (renderArea) {\n        if (!arguments.length) {\n            return _renderArea;\n        }\n        _renderArea = renderArea;\n        return _chart;\n    };\n\n    function colors (d, i) {\n        return _chart.getColor.call(d, d.values, i);\n    }\n\n    function drawLine (layersEnter, layers) {\n        var line = d3.svg.line()\n            .x(function (d) {\n                return _chart.x()(d.x);\n            })\n            .y(function (d) {\n                return _chart.y()(d.y + d.y0);\n            })\n            .interpolate(_interpolate)\n            .tension(_tension);\n        if (_defined) {\n            line.defined(_defined);\n        }\n\n        var path = layersEnter.append('path')\n            .attr('class', 'line')\n            .attr('stroke', colors);\n        if (_dashStyle) {\n            path.attr('stroke-dasharray', _dashStyle);\n        }\n\n        dc.transition(layers.select('path.line'), _chart.transitionDuration(), _chart.transitionDelay())\n            //.ease('linear')\n            .attr('stroke', colors)\n            .attr('d', function (d) {\n                return safeD(line(d.values));\n            });\n    }\n\n    function drawArea (layersEnter, layers) {\n        if (_renderArea) {\n            var area = d3.svg.area()\n                .x(function (d) {\n                    return _chart.x()(d.x);\n                })\n                .y(function (d) {\n                    return _chart.y()(d.y + d.y0);\n                })\n                .y0(function (d) {\n                    return _chart.y()(d.y0);\n                })\n                .interpolate(_interpolate)\n                .tension(_tension);\n            if (_defined) {\n                area.defined(_defined);\n            }\n\n            layersEnter.append('path')\n                .attr('class', 'area')\n                .attr('fill', colors)\n                .attr('d', function (d) {\n                    return safeD(area(d.values));\n                });\n\n            dc.transition(layers.select('path.area'), _chart.transitionDuration(), _chart.transitionDelay())\n                //.ease('linear')\n                .attr('fill', colors)\n                .attr('d', function (d) {\n                    return safeD(area(d.values));\n                });\n        }\n    }\n\n    function safeD (d) {\n        return (!d || d.indexOf('NaN') >= 0) ? 'M0,0' : d;\n    }\n\n    function drawDots (chartBody, layers) {\n        if (_chart.xyTipsOn() === 'always' || (!_chart.brushOn() && _chart.xyTipsOn())) {\n            var tooltipListClass = TOOLTIP_G_CLASS + '-list';\n            var tooltips = chartBody.select('g.' + tooltipListClass);\n\n            if (tooltips.empty()) {\n                tooltips = chartBody.append('g').attr('class', tooltipListClass);\n            }\n\n            layers.each(function (d, layerIndex) {\n                var points = d.values;\n                if (_defined) {\n                    points = points.filter(_defined);\n                }\n\n                var g = tooltips.select('g.' + TOOLTIP_G_CLASS + '._' + layerIndex);\n                if (g.empty()) {\n                    g = tooltips.append('g').attr('class', TOOLTIP_G_CLASS + ' _' + layerIndex);\n                }\n\n                createRefLines(g);\n\n                var dots = g.selectAll('circle.' + DOT_CIRCLE_CLASS)\n                    .data(points, dc.pluck('x'));\n\n                dots.enter()\n                    .append('circle')\n                    .attr('class', DOT_CIRCLE_CLASS)\n                    .attr('r', getDotRadius())\n                    .style('fill-opacity', _dataPointFillOpacity)\n                    .style('stroke-opacity', _dataPointStrokeOpacity)\n                    .attr('fill', _chart.getColor)\n                    .on('mousemove', function () {\n                        var dot = d3.select(this);\n                        showDot(dot);\n                        showRefLines(dot, g);\n                    })\n                    .on('mouseout', function () {\n                        var dot = d3.select(this);\n                        hideDot(dot);\n                        hideRefLines(g);\n                    });\n\n                dots.call(renderTitle, d);\n\n                dc.transition(dots, _chart.transitionDuration())\n                    .attr('cx', function (d) {\n                        return dc.utils.safeNumber(_chart.x()(d.x));\n                    })\n                    .attr('cy', function (d) {\n                        return dc.utils.safeNumber(_chart.y()(d.y + d.y0));\n                    })\n                    .attr('fill', _chart.getColor);\n\n                dots.exit().remove();\n            });\n        }\n    }\n\n    _chart.label(function (d) {\n        return dc.utils.printSingleValue(d.y0 + d.y);\n    }, false);\n\n    function drawLabels (layers) {\n        layers.each(function (d, layerIndex) {\n            var layer = d3.select(this);\n            var labels = layer.selectAll('text.lineLabel')\n                .data(d.values, dc.pluck('x'));\n\n            labels.enter()\n                .append('text')\n                .attr('class', 'lineLabel')\n                .attr('text-anchor', 'middle');\n\n            dc.transition(labels, _chart.transitionDuration())\n                .attr('x', function (d) {\n                    return dc.utils.safeNumber(_chart.x()(d.x));\n                })\n                .attr('y', function (d) {\n                    var y = _chart.y()(d.y + d.y0) - LABEL_PADDING;\n                    return dc.utils.safeNumber(y);\n                })\n                .text(function (d) {\n                    return _chart.label()(d);\n                });\n\n            dc.transition(labels.exit(), _chart.transitionDuration())\n                .attr('height', 0)\n                .remove();\n        });\n    }\n\n    function createRefLines (g) {\n        var yRefLine = g.select('path.' + Y_AXIS_REF_LINE_CLASS).empty() ?\n            g.append('path').attr('class', Y_AXIS_REF_LINE_CLASS) : g.select('path.' + Y_AXIS_REF_LINE_CLASS);\n        yRefLine.style('display', 'none').attr('stroke-dasharray', '5,5');\n\n        var xRefLine = g.select('path.' + X_AXIS_REF_LINE_CLASS).empty() ?\n            g.append('path').attr('class', X_AXIS_REF_LINE_CLASS) : g.select('path.' + X_AXIS_REF_LINE_CLASS);\n        xRefLine.style('display', 'none').attr('stroke-dasharray', '5,5');\n    }\n\n    function showDot (dot) {\n        dot.style('fill-opacity', 0.8);\n        dot.style('stroke-opacity', 0.8);\n        dot.attr('r', _dotRadius);\n        return dot;\n    }\n\n    function showRefLines (dot, g) {\n        var x = dot.attr('cx');\n        var y = dot.attr('cy');\n        var yAxisX = (_chart._yAxisX() - _chart.margins().left);\n        var yAxisRefPathD = 'M' + yAxisX + ' ' + y + 'L' + (x) + ' ' + (y);\n        var xAxisRefPathD = 'M' + x + ' ' + _chart.yAxisHeight() + 'L' + x + ' ' + y;\n        g.select('path.' + Y_AXIS_REF_LINE_CLASS).style('display', '').attr('d', yAxisRefPathD);\n        g.select('path.' + X_AXIS_REF_LINE_CLASS).style('display', '').attr('d', xAxisRefPathD);\n    }\n\n    function getDotRadius () {\n        return _dataPointRadius || _dotRadius;\n    }\n\n    function hideDot (dot) {\n        dot.style('fill-opacity', _dataPointFillOpacity)\n            .style('stroke-opacity', _dataPointStrokeOpacity)\n            .attr('r', getDotRadius());\n    }\n\n    function hideRefLines (g) {\n        g.select('path.' + Y_AXIS_REF_LINE_CLASS).style('display', 'none');\n        g.select('path.' + X_AXIS_REF_LINE_CLASS).style('display', 'none');\n    }\n\n    function renderTitle (dot, d) {\n        if (_chart.renderTitle()) {\n            dot.select('title').remove();\n            dot.append('title').text(dc.pluck('data', _chart.title(d.name)));\n        }\n    }\n\n    /**\n     * Turn on/off the mouseover behavior of an individual data point which renders a circle and x/y axis\n     * dashed lines back to each respective axis.  This is ignored if the chart\n     * {@link dc.coordinateGridMixin#brushOn brush} is on\n     * @method xyTipsOn\n     * @memberof dc.lineChart\n     * @instance\n     * @param  {Boolean} [xyTipsOn=false]\n     * @returns {Boolean|dc.lineChart}\n     */\n    _chart.xyTipsOn = function (xyTipsOn) {\n        if (!arguments.length) {\n            return _xyTipsOn;\n        }\n        _xyTipsOn = xyTipsOn;\n        return _chart;\n    };\n\n    /**\n     * Get or set the radius (in px) for dots displayed on the data points.\n     * @method dotRadius\n     * @memberof dc.lineChart\n     * @instance\n     * @param  {Number} [dotRadius=5]\n     * @returns {Number|dc.lineChart}\n     */\n    _chart.dotRadius = function (dotRadius) {\n        if (!arguments.length) {\n            return _dotRadius;\n        }\n        _dotRadius = dotRadius;\n        return _chart;\n    };\n\n    /**\n     * Always show individual dots for each datapoint.\n     *\n     * If `options` is falsy, it disables data point rendering. If no `options` are provided, the\n     * current `options` values are instead returned.\n     * @method renderDataPoints\n     * @memberof dc.lineChart\n     * @instance\n     * @example\n     * chart.renderDataPoints({radius: 2, fillOpacity: 0.8, strokeOpacity: 0.8})\n     * @param  {{fillOpacity: Number, strokeOpacity: Number, radius: Number}} [options={fillOpacity: 0.8, strokeOpacity: 0.8, radius: 2}]\n     * @returns {{fillOpacity: Number, strokeOpacity: Number, radius: Number}|dc.lineChart}\n     */\n    _chart.renderDataPoints = function (options) {\n        if (!arguments.length) {\n            return {\n                fillOpacity: _dataPointFillOpacity,\n                strokeOpacity: _dataPointStrokeOpacity,\n                radius: _dataPointRadius\n            };\n        } else if (!options) {\n            _dataPointFillOpacity = DEFAULT_DOT_OPACITY;\n            _dataPointStrokeOpacity = DEFAULT_DOT_OPACITY;\n            _dataPointRadius = null;\n        } else {\n            _dataPointFillOpacity = options.fillOpacity || 0.8;\n            _dataPointStrokeOpacity = options.strokeOpacity || 0.8;\n            _dataPointRadius = options.radius || 2;\n        }\n        return _chart;\n    };\n\n    function colorFilter (color, dashstyle, inv) {\n        return function () {\n            var item = d3.select(this);\n            var match = (item.attr('stroke') === color &&\n                item.attr('stroke-dasharray') === ((dashstyle instanceof Array) ?\n                    dashstyle.join(',') : null)) || item.attr('fill') === color;\n            return inv ? !match : match;\n        };\n    }\n\n    _chart.legendHighlight = function (d) {\n        if (!_chart.isLegendableHidden(d)) {\n            _chart.g().selectAll('path.line, path.area')\n                .classed('highlight', colorFilter(d.color, d.dashstyle))\n                .classed('fadeout', colorFilter(d.color, d.dashstyle, true));\n        }\n    };\n\n    _chart.legendReset = function () {\n        _chart.g().selectAll('path.line, path.area')\n            .classed('highlight', false)\n            .classed('fadeout', false);\n    };\n\n    dc.override(_chart, 'legendables', function () {\n        var legendables = _chart._legendables();\n        if (!_dashStyle) {\n            return legendables;\n        }\n        return legendables.map(function (l) {\n            l.dashstyle = _dashStyle;\n            return l;\n        });\n    });\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The data count widget is a simple widget designed to display the number of records selected by the\n * current filters out of the total number of records in the data set. Once created the data count widget\n * will automatically update the text content of child elements with the following classes:\n *\n * * `.total-count` - total number of records\n * * `.filter-count` - number of records matched by the current filters\n *\n * Note: this widget works best for the specific case of showing the number of records out of a\n * total. If you want a more general-purpose numeric display, please use the\n * {@link dc.numberDisplay} widget instead.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * @class dataCount\n * @memberof dc\n * @mixes dc.baseMixin\n * @example\n * var ndx = crossfilter(data);\n * var all = ndx.groupAll();\n *\n * dc.dataCount('.dc-data-count')\n *     .dimension(ndx)\n *     .group(all);\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.dataCount}\n */\ndc.dataCount = function (parent, chartGroup) {\n    var _formatNumber = d3.format(',d');\n    var _chart = dc.baseMixin({});\n    var _html = {some: '', all: ''};\n\n    /**\n     * Gets or sets an optional object specifying HTML templates to use depending how many items are\n     * selected. The text `%total-count` will replaced with the total number of records, and the text\n     * `%filter-count` will be replaced with the number of selected records.\n     * - all: HTML template to use if all items are selected\n     * - some: HTML template to use if not all items are selected\n     * @method html\n     * @memberof dc.dataCount\n     * @instance\n     * @example\n     * counter.html({\n     *      some: '%filter-count out of %total-count records selected',\n     *      all: 'All records selected. Click on charts to apply filters'\n     * })\n     * @param {{some:String, all: String}} [options]\n     * @returns {{some:String, all: String}|dc.dataCount}\n     */\n    _chart.html = function (options) {\n        if (!arguments.length) {\n            return _html;\n        }\n        if (options.all) {\n            _html.all = options.all;\n        }\n        if (options.some) {\n            _html.some = options.some;\n        }\n        return _chart;\n    };\n\n    /**\n     * Gets or sets an optional function to format the filter count and total count.\n     * @method formatNumber\n     * @memberof dc.dataCount\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Formatting.md d3.format}\n     * @example\n     * counter.formatNumber(d3.format('.2g'))\n     * @param {Function} [formatter=d3.format('.2g')]\n     * @returns {Function|dc.dataCount}\n     */\n    _chart.formatNumber = function (formatter) {\n        if (!arguments.length) {\n            return _formatNumber;\n        }\n        _formatNumber = formatter;\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        var tot = _chart.dimension().size(),\n            val = _chart.group().value();\n        var all = _formatNumber(tot);\n        var selected = _formatNumber(val);\n\n        if ((tot === val) && (_html.all !== '')) {\n            _chart.root().html(_html.all.replace('%total-count', all).replace('%filter-count', selected));\n        } else if (_html.some !== '') {\n            _chart.root().html(_html.some.replace('%total-count', all).replace('%filter-count', selected));\n        } else {\n            _chart.selectAll('.total-count').text(all);\n            _chart.selectAll('.filter-count').text(selected);\n        }\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The data table is a simple widget designed to list crossfilter focused data set (rows being\n * filtered) in a good old tabular fashion.\n *\n * Note: Unlike other charts, the data table (and data grid chart) use the {@link dc.dataTable#group group} attribute as a\n * keying function for {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#nest nesting} the data\n * together in groups.  Do not pass in a crossfilter group as this will not work.\n *\n * Another interesting feature of the data table is that you can pass a crossfilter group to the `dimension`, as\n * long as you specify the {@link dc.dataTable#order order} as `d3.descending`, since the data\n * table will use `dimension.top()` to fetch the data in that case, and the method is equally\n * supported on the crossfilter group as the crossfilter dimension.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.io/dc.js/examples/table-on-aggregated-data.html dataTable on a crossfilter group}\n * ({@link https://github.com/dc-js/dc.js/blob/develop/web/examples/table-on-aggregated-data.html source})\n * @class dataTable\n * @memberof dc\n * @mixes dc.baseMixin\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.dataTable}\n */\ndc.dataTable = function (parent, chartGroup) {\n    var LABEL_CSS_CLASS = 'dc-table-label';\n    var ROW_CSS_CLASS = 'dc-table-row';\n    var COLUMN_CSS_CLASS = 'dc-table-column';\n    var GROUP_CSS_CLASS = 'dc-table-group';\n    var HEAD_CSS_CLASS = 'dc-table-head';\n\n    var _chart = dc.baseMixin({});\n\n    var _size = 25;\n    var _columns = [];\n    var _sortBy = function (d) {\n        return d;\n    };\n    var _order = d3.ascending;\n    var _beginSlice = 0;\n    var _endSlice;\n    var _showGroups = true;\n\n    _chart._doRender = function () {\n        _chart.selectAll('tbody').remove();\n\n        renderRows(renderGroups());\n\n        return _chart;\n    };\n\n    _chart._doColumnValueFormat = function (v, d) {\n        return ((typeof v === 'function') ?\n                v(d) :                          // v as function\n                ((typeof v === 'string') ?\n                 d[v] :                         // v is field name string\n                 v.format(d)                        // v is Object, use fn (element 2)\n                )\n               );\n    };\n\n    _chart._doColumnHeaderFormat = function (d) {\n        // if 'function', convert to string representation\n        // show a string capitalized\n        // if an object then display its label string as-is.\n        return (typeof d === 'function') ?\n                _chart._doColumnHeaderFnToString(d) :\n                ((typeof d === 'string') ?\n                 _chart._doColumnHeaderCapitalize(d) : String(d.label));\n    };\n\n    _chart._doColumnHeaderCapitalize = function (s) {\n        // capitalize\n        return s.charAt(0).toUpperCase() + s.slice(1);\n    };\n\n    _chart._doColumnHeaderFnToString = function (f) {\n        // columnString(f) {\n        var s = String(f);\n        var i1 = s.indexOf('return ');\n        if (i1 >= 0) {\n            var i2 = s.lastIndexOf(';');\n            if (i2 >= 0) {\n                s = s.substring(i1 + 7, i2);\n                var i3 = s.indexOf('numberFormat');\n                if (i3 >= 0) {\n                    s = s.replace('numberFormat', '');\n                }\n            }\n        }\n        return s;\n    };\n\n    function renderGroups () {\n        // The 'original' example uses all 'functions'.\n        // If all 'functions' are used, then don't remove/add a header, and leave\n        // the html alone. This preserves the functionality of earlier releases.\n        // A 2nd option is a string representing a field in the data.\n        // A third option is to supply an Object such as an array of 'information', and\n        // supply your own _doColumnHeaderFormat and _doColumnValueFormat functions to\n        // create what you need.\n        var bAllFunctions = true;\n        _columns.forEach(function (f) {\n            bAllFunctions = bAllFunctions & (typeof f === 'function');\n        });\n\n        if (!bAllFunctions) {\n            // ensure one thead\n            var thead = _chart.selectAll('thead').data([0]);\n            thead.enter().append('thead');\n            thead.exit().remove();\n\n            // with one tr\n            var headrow = thead.selectAll('tr').data([0]);\n            headrow.enter().append('tr');\n            headrow.exit().remove();\n\n            // with a th for each column\n            var headcols = headrow.selectAll('th')\n                .data(_columns);\n            headcols.enter().append('th');\n            headcols.exit().remove();\n\n            headcols\n                .attr('class', HEAD_CSS_CLASS)\n                    .html(function (d) {\n                        return (_chart._doColumnHeaderFormat(d));\n\n                    });\n        }\n\n        var groups = _chart.root().selectAll('tbody')\n            .data(nestEntries(), function (d) {\n                return _chart.keyAccessor()(d);\n            });\n\n        var rowGroup = groups\n            .enter()\n            .append('tbody');\n\n        if (_showGroups === true) {\n            rowGroup\n                .append('tr')\n                .attr('class', GROUP_CSS_CLASS)\n                    .append('td')\n                    .attr('class', LABEL_CSS_CLASS)\n                    .attr('colspan', _columns.length)\n                    .html(function (d) {\n                        return _chart.keyAccessor()(d);\n                    });\n        }\n\n        groups.exit().remove();\n\n        return rowGroup;\n    }\n\n    function nestEntries () {\n        var entries;\n        if (_order === d3.ascending) {\n            entries = _chart.dimension().bottom(_size);\n        } else {\n            entries = _chart.dimension().top(_size);\n        }\n\n        return d3.nest()\n            .key(_chart.group())\n            .sortKeys(_order)\n            .entries(entries.sort(function (a, b) {\n                return _order(_sortBy(a), _sortBy(b));\n            }).slice(_beginSlice, _endSlice));\n    }\n\n    function renderRows (groups) {\n        var rows = groups.order()\n            .selectAll('tr.' + ROW_CSS_CLASS)\n            .data(function (d) {\n                return d.values;\n            });\n\n        var rowEnter = rows.enter()\n            .append('tr')\n            .attr('class', ROW_CSS_CLASS);\n\n        _columns.forEach(function (v, i) {\n            rowEnter.append('td')\n                .attr('class', COLUMN_CSS_CLASS + ' _' + i)\n                .html(function (d) {\n                    return _chart._doColumnValueFormat(v, d);\n                });\n        });\n\n        rows.exit().remove();\n\n        return rows;\n    }\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\n     * Get or set the group function for the data table. The group function takes a data row and\n     * returns the key to specify to {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_nest d3.nest}\n     * to split rows into groups.\n     *\n     * Do not pass in a crossfilter group as this will not work.\n     * @method group\n     * @memberof dc.dataTable\n     * @instance\n     * @example\n     * // group rows by the value of their field\n     * chart\n     *     .group(function(d) { return d.field; })\n     * @param {Function} groupFunction Function taking a row of data and returning the nest key.\n     * @returns {Function|dc.dataTable}\n     */\n\n    /**\n     * Get or set the table size which determines the number of rows displayed by the widget.\n     * @method size\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Number} [size=25]\n     * @returns {Number|dc.dataTable}\n     */\n    _chart.size = function (size) {\n        if (!arguments.length) {\n            return _size;\n        }\n        _size = size;\n        return _chart;\n    };\n\n    /**\n     * Get or set the index of the beginning slice which determines which entries get displayed\n     * by the widget. Useful when implementing pagination.\n     *\n     * Note: the sortBy function will determine how the rows are ordered for pagination purposes.\n\n     * See the {@link http://dc-js.github.io/dc.js/examples/table-pagination.html table pagination example}\n     * to see how to implement the pagination user interface using `beginSlice` and `endSlice`.\n     * @method beginSlice\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Number} [beginSlice=0]\n     * @returns {Number|dc.dataTable}\n     */\n    _chart.beginSlice = function (beginSlice) {\n        if (!arguments.length) {\n            return _beginSlice;\n        }\n        _beginSlice = beginSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set the index of the end slice which determines which entries get displayed by the\n     * widget. Useful when implementing pagination. See {@link dc.dataTable#beginSlice `beginSlice`} for more information.\n     * @method endSlice\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Number|undefined} [endSlice=undefined]\n     * @returns {Number|dc.dataTable}\n     */\n    _chart.endSlice = function (endSlice) {\n        if (!arguments.length) {\n            return _endSlice;\n        }\n        _endSlice = endSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set column functions. The data table widget supports several methods of specifying the\n     * columns to display.\n     *\n     * The original method uses an array of functions to generate dynamic columns. Column functions\n     * are simple javascript functions with only one input argument `d` which represents a row in\n     * the data set. The return value of these functions will be used to generate the content for\n     * each cell. However, this method requires the HTML for the table to have a fixed set of column\n     * headers.\n     *\n     * <pre><code>chart.columns([\n     *     function(d) { return d.date; },\n     *     function(d) { return d.open; },\n     *     function(d) { return d.close; },\n     *     function(d) { return numberFormat(d.close - d.open); },\n     *     function(d) { return d.volume; }\n     * ]);\n     * </code></pre>\n     *\n     * In the second method, you can list the columns to read from the data without specifying it as\n     * a function, except where necessary (ie, computed columns).  Note the data element name is\n     * capitalized when displayed in the table header. You can also mix in functions as necessary,\n     * using the third `{label, format}` form, as shown below.\n     *\n     * <pre><code>chart.columns([\n     *     \"date\",    // d[\"date\"], ie, a field accessor; capitalized automatically\n     *     \"open\",    // ...\n     *     \"close\",   // ...\n     *     {\n     *         label: \"Change\",\n     *         format: function (d) {\n     *             return numberFormat(d.close - d.open);\n     *         }\n     *     },\n     *     \"volume\"   // d[\"volume\"], ie, a field accessor; capitalized automatically\n     * ]);\n     * </code></pre>\n     *\n     * In the third example, we specify all fields using the `{label, format}` method:\n     * <pre><code>chart.columns([\n     *     {\n     *         label: \"Date\",\n     *         format: function (d) { return d.date; }\n     *     },\n     *     {\n     *         label: \"Open\",\n     *         format: function (d) { return numberFormat(d.open); }\n     *     },\n     *     {\n     *         label: \"Close\",\n     *         format: function (d) { return numberFormat(d.close); }\n     *     },\n     *     {\n     *         label: \"Change\",\n     *         format: function (d) { return numberFormat(d.close - d.open); }\n     *     },\n     *     {\n     *         label: \"Volume\",\n     *         format: function (d) { return d.volume; }\n     *     }\n     * ]);\n     * </code></pre>\n     *\n     * You may wish to override the dataTable functions `_doColumnHeaderCapitalize` and\n     * `_doColumnHeaderFnToString`, which are used internally to translate the column information or\n     * function into a displayed header. The first one is used on the \"string\" column specifier; the\n     * second is used to transform a stringified function into something displayable. For the Stock\n     * example, the function for Change becomes the table header **d.close - d.open**.\n     *\n     * Finally, you can even specify a completely different form of column definition. To do this,\n     * override `_chart._doColumnHeaderFormat` and `_chart._doColumnValueFormat` Be aware that\n     * fields without numberFormat specification will be displayed just as they are stored in the\n     * data, unformatted.\n     * @method columns\n     * @memberof dc.dataTable\n     * @instance\n     * @param {Array<Function>} [columns=[]]\n     * @returns {Array<Function>}|dc.dataTable}\n     */\n    _chart.columns = function (columns) {\n        if (!arguments.length) {\n            return _columns;\n        }\n        _columns = columns;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort-by function. This function works as a value accessor at row level and returns a\n     * particular field to be sorted by.\n     * @method sortBy\n     * @memberof dc.dataTable\n     * @instance\n     * @example\n     * chart.sortBy(function(d) {\n     *     return d.date;\n     * });\n     * @param {Function} [sortBy=identity function]\n     * @returns {Function|dc.dataTable}\n     */\n    _chart.sortBy = function (sortBy) {\n        if (!arguments.length) {\n            return _sortBy;\n        }\n        _sortBy = sortBy;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort order. If the order is `d3.ascending`, the data table will use\n     * `dimension().bottom()` to fetch the data; otherwise it will use `dimension().top()`\n     * @method order\n     * @memberof dc.dataTable\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * chart.order(d3.descending);\n     * @param {Function} [order=d3.ascending]\n     * @returns {Function|dc.dataTable}\n     */\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    /**\n     * Get or set if group rows will be shown. The dataTable {@link dc.dataTable#group group}\n     * function must be specified even if groups are not shown.\n     * @method showGroups\n     * @memberof dc.dataTable\n     * @instance\n     * @example\n     * chart\n     *     .group([value], [name])\n     *     .showGroups(true|false);\n     * @param {Boolean} [showGroups=true]\n     * @returns {Boolean|dc.dataTable}\n     */\n    _chart.showGroups = function (showGroups) {\n        if (!arguments.length) {\n            return _showGroups;\n        }\n        _showGroups = showGroups;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Data grid is a simple widget designed to list the filtered records, providing\n * a simple way to define how the items are displayed.\n *\n * Note: Unlike other charts, the data grid chart (and data table) use the {@link dc.dataGrid#group group} attribute as a keying function\n * for {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#nest nesting} the data together in groups.\n * Do not pass in a crossfilter group as this will not work.\n *\n * Examples:\n * - {@link http://europarl.me/dc.js/web/ep/index.html List of members of the european parliament}\n * @class dataGrid\n * @memberof dc\n * @mixes dc.baseMixin\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.dataGrid}\n */\ndc.dataGrid = function (parent, chartGroup) {\n    var LABEL_CSS_CLASS = 'dc-grid-label';\n    var ITEM_CSS_CLASS = 'dc-grid-item';\n    var GROUP_CSS_CLASS = 'dc-grid-group';\n    var GRID_CSS_CLASS = 'dc-grid-top';\n\n    var _chart = dc.baseMixin({});\n\n    var _size = 999; // shouldn't be needed, but you might\n    var _html = function (d) { return 'you need to provide an html() handling param:  ' + JSON.stringify(d); };\n    var _sortBy = function (d) {\n        return d;\n    };\n    var _order = d3.ascending;\n    var _beginSlice = 0, _endSlice;\n\n    var _htmlGroup = function (d) {\n        return '<div class=\\'' + GROUP_CSS_CLASS + '\\'><h1 class=\\'' + LABEL_CSS_CLASS + '\\'>' +\n            _chart.keyAccessor()(d) + '</h1></div>';\n    };\n\n    _chart._doRender = function () {\n        _chart.selectAll('div.' + GRID_CSS_CLASS).remove();\n\n        renderItems(renderGroups());\n\n        return _chart;\n    };\n\n    function renderGroups () {\n        var groups = _chart.root().selectAll('div.' + GRID_CSS_CLASS)\n                .data(nestEntries(), function (d) {\n                    return _chart.keyAccessor()(d);\n                });\n\n        var itemGroup = groups\n                .enter()\n                .append('div')\n                .attr('class', GRID_CSS_CLASS);\n\n        if (_htmlGroup) {\n            itemGroup\n                .html(function (d) {\n                    return _htmlGroup(d);\n                });\n        }\n\n        groups.exit().remove();\n        return itemGroup;\n    }\n\n    function nestEntries () {\n        var entries = _chart.dimension().top(_size);\n\n        return d3.nest()\n            .key(_chart.group())\n            .sortKeys(_order)\n            .entries(entries.sort(function (a, b) {\n                return _order(_sortBy(a), _sortBy(b));\n            }).slice(_beginSlice, _endSlice));\n    }\n\n    function renderItems (groups) {\n        var items = groups.order()\n                .selectAll('div.' + ITEM_CSS_CLASS)\n                .data(function (d) {\n                    return d.values;\n                });\n\n        items.enter()\n            .append('div')\n            .attr('class', ITEM_CSS_CLASS)\n            .html(function (d) {\n                return _html(d);\n            });\n\n        items.exit().remove();\n\n        return items;\n    }\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\n     * Get or set the group function for the data grid. The group function takes a data row and\n     * returns the key to specify to {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_nest d3.nest}\n     * to split rows into groups.\n     *\n     * Do not pass in a crossfilter group as this will not work.\n     * @method group\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * // group rows by the value of their field\n     * chart\n     *     .group(function(d) { return d.field; })\n     * @param {Function} groupFunction Function taking a row of data and returning the nest key.\n     * @returns {Function|dc.dataTable}\n     */\n\n    /**\n     * Get or set the index of the beginning slice which determines which entries get displayed by the widget.\n     * Useful when implementing pagination.\n     * @method beginSlice\n     * @memberof dc.dataGrid\n     * @instance\n     * @param {Number} [beginSlice=0]\n     * @returns {Number|dc.dataGrid}\n     */\n    _chart.beginSlice = function (beginSlice) {\n        if (!arguments.length) {\n            return _beginSlice;\n        }\n        _beginSlice = beginSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set the index of the end slice which determines which entries get displayed by the widget.\n     * Useful when implementing pagination.\n     * @method endSlice\n     * @memberof dc.dataGrid\n     * @instance\n     * @param {Number} [endSlice]\n     * @returns {Number|dc.dataGrid}\n     */\n    _chart.endSlice = function (endSlice) {\n        if (!arguments.length) {\n            return _endSlice;\n        }\n        _endSlice = endSlice;\n        return _chart;\n    };\n\n    /**\n     * Get or set the grid size which determines the number of items displayed by the widget.\n     * @method size\n     * @memberof dc.dataGrid\n     * @instance\n     * @param {Number} [size=999]\n     * @returns {Number|dc.dataGrid}\n     */\n    _chart.size = function (size) {\n        if (!arguments.length) {\n            return _size;\n        }\n        _size = size;\n        return _chart;\n    };\n\n    /**\n     * Get or set the function that formats an item. The data grid widget uses a\n     * function to generate dynamic html. Use your favourite templating engine or\n     * generate the string directly.\n     * @method html\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * chart.html(function (d) { return '<div class='item '+data.exampleCategory+''>'+data.exampleString+'</div>';});\n     * @param {Function} [html]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.html = function (html) {\n        if (!arguments.length) {\n            return _html;\n        }\n        _html = html;\n        return _chart;\n    };\n\n    /**\n     * Get or set the function that formats a group label.\n     * @method htmlGroup\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * chart.htmlGroup (function (d) { return '<h2>'.d.key . 'with ' . d.values.length .' items</h2>'});\n     * @param {Function} [htmlGroup]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.htmlGroup = function (htmlGroup) {\n        if (!arguments.length) {\n            return _htmlGroup;\n        }\n        _htmlGroup = htmlGroup;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort-by function. This function works as a value accessor at the item\n     * level and returns a particular field to be sorted.\n     * @method sortBy\n     * @memberof dc.dataGrid\n     * @instance\n     * @example\n     * chart.sortBy(function(d) {\n     *     return d.date;\n     * });\n     * @param {Function} [sortByFunction]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.sortBy = function (sortByFunction) {\n        if (!arguments.length) {\n            return _sortBy;\n        }\n        _sortBy = sortByFunction;\n        return _chart;\n    };\n\n    /**\n     * Get or set sort the order function.\n     * @method order\n     * @memberof dc.dataGrid\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * chart.order(d3.descending);\n     * @param {Function} [order=d3.ascending]\n     * @returns {Function|dc.dataGrid}\n     */\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A concrete implementation of a general purpose bubble chart that allows data visualization using the\n * following dimensions:\n * - x axis position\n * - y axis position\n * - bubble radius\n * - color\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}\n * @class bubbleChart\n * @memberof dc\n * @mixes dc.bubbleMixin\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a bubble chart under #chart-container1 element using the default global chart group\n * var bubbleChart1 = dc.bubbleChart('#chart-container1');\n * // create a bubble chart under #chart-container2 element using chart group A\n * var bubbleChart2 = dc.bubbleChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.bubbleChart}\n */\ndc.bubbleChart = function (parent, chartGroup) {\n    var _chart = dc.bubbleMixin(dc.coordinateGridMixin({}));\n\n    _chart.transitionDuration(750);\n\n    _chart.transitionDelay(0);\n\n    var bubbleLocator = function (d) {\n        return 'translate(' + (bubbleX(d)) + ',' + (bubbleY(d)) + ')';\n    };\n\n    _chart.plotData = function () {\n        _chart.calculateRadiusDomain();\n        _chart.r().range([_chart.MIN_RADIUS, _chart.xAxisLength() * _chart.maxBubbleRelativeSize()]);\n\n        var data = _chart.data();\n        var bubbleG = _chart.chartBodyG().selectAll('g.' + _chart.BUBBLE_NODE_CLASS)\n                .data(data, function (d) { return d.key; });\n        if (_chart.sortBubbleSize()) {\n            // update dom order based on sort\n            bubbleG.order();\n        }\n\n        renderNodes(bubbleG);\n\n        updateNodes(bubbleG);\n\n        removeNodes(bubbleG);\n\n        _chart.fadeDeselectedArea();\n    };\n\n    function renderNodes (bubbleG) {\n        var bubbleGEnter = bubbleG.enter().append('g');\n\n        bubbleGEnter\n            .attr('class', _chart.BUBBLE_NODE_CLASS)\n            .attr('transform', bubbleLocator)\n            .append('circle').attr('class', function (d, i) {\n                return _chart.BUBBLE_CLASS + ' _' + i;\n            })\n            .on('click', _chart.onClick)\n            .attr('fill', _chart.getColor)\n            .attr('r', 0);\n        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay())\n            .select('circle.' + _chart.BUBBLE_CLASS)\n            .attr('r', function (d) {\n                return _chart.bubbleR(d);\n            })\n            .attr('opacity', function (d) {\n                return (_chart.bubbleR(d) > 0) ? 1 : 0;\n            });\n\n        _chart._doRenderLabel(bubbleGEnter);\n\n        _chart._doRenderTitles(bubbleGEnter);\n    }\n\n    function updateNodes (bubbleG) {\n        dc.transition(bubbleG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', bubbleLocator)\n            .select('circle.' + _chart.BUBBLE_CLASS)\n            .attr('fill', _chart.getColor)\n            .attr('r', function (d) {\n                return _chart.bubbleR(d);\n            })\n            .attr('opacity', function (d) {\n                return (_chart.bubbleR(d) > 0) ? 1 : 0;\n            });\n\n        _chart.doUpdateLabels(bubbleG);\n        _chart.doUpdateTitles(bubbleG);\n    }\n\n    function removeNodes (bubbleG) {\n        bubbleG.exit().remove();\n    }\n\n    function bubbleX (d) {\n        var x = _chart.x()(_chart.keyAccessor()(d));\n        if (isNaN(x)) {\n            x = 0;\n        }\n        return x;\n    }\n\n    function bubbleY (d) {\n        var y = _chart.y()(_chart.valueAccessor()(d));\n        if (isNaN(y)) {\n            y = 0;\n        }\n        return y;\n    }\n\n    _chart.renderBrush = function () {\n        // override default x axis brush from parent chart\n    };\n\n    _chart.redrawBrush = function () {\n        // override default x axis brush from parent chart\n        _chart.fadeDeselectedArea();\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Composite charts are a special kind of chart that render multiple charts on the same Coordinate\n * Grid. You can overlay (compose) different bar/line/area charts in a single composite chart to\n * achieve some quite flexible charting effects.\n * @class compositeChart\n * @memberof dc\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a composite chart under #chart-container1 element using the default global chart group\n * var compositeChart1 = dc.compositeChart('#chart-container1');\n * // create a composite chart under #chart-container2 element using chart group A\n * var compositeChart2 = dc.compositeChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.compositeChart}\n */\ndc.compositeChart = function (parent, chartGroup) {\n\n    var SUB_CHART_CLASS = 'sub';\n    var DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING = 12;\n\n    var _chart = dc.coordinateGridMixin({});\n    var _children = [];\n\n    var _childOptions = {};\n\n    var _shareColors = false,\n        _shareTitle = true,\n        _alignYAxes = false;\n\n    var _rightYAxis = d3.svg.axis(),\n        _rightYAxisLabel = 0,\n        _rightYAxisLabelPadding = DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING,\n        _rightY,\n        _rightAxisGridLines = false;\n\n    _chart._mandatoryAttributes([]);\n    _chart.transitionDuration(500);\n    _chart.transitionDelay(0);\n\n    dc.override(_chart, '_generateG', function () {\n        var g = this.__generateG();\n\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n\n            generateChildG(child, i);\n\n            if (!child.dimension()) {\n                child.dimension(_chart.dimension());\n            }\n            if (!child.group()) {\n                child.group(_chart.group());\n            }\n\n            child.chartGroup(_chart.chartGroup());\n            child.svg(_chart.svg());\n            child.xUnits(_chart.xUnits());\n            child.transitionDuration(_chart.transitionDuration(), _chart.transitionDelay());\n            child.brushOn(_chart.brushOn());\n            child.renderTitle(_chart.renderTitle());\n            child.elasticX(_chart.elasticX());\n        }\n\n        return g;\n    });\n\n    _chart._brushing = function () {\n        var extent = _chart.extendBrush();\n        var brushIsEmpty = _chart.brushIsEmpty(extent);\n\n        for (var i = 0; i < _children.length; ++i) {\n            _children[i].replaceFilter(brushIsEmpty ? null : extent);\n        }\n    };\n\n    _chart._prepareYAxis = function () {\n        var left = (leftYAxisChildren().length !== 0);\n        var right = (rightYAxisChildren().length !== 0);\n        var ranges = calculateYAxisRanges(left, right);\n\n        if (left) { prepareLeftYAxis(ranges); }\n        if (right) { prepareRightYAxis(ranges); }\n\n        if (leftYAxisChildren().length > 0 && !_rightAxisGridLines) {\n            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _chart.y(), _chart.yAxis());\n        } else if (rightYAxisChildren().length > 0) {\n            _chart._renderHorizontalGridLinesForAxis(_chart.g(), _rightY, _rightYAxis);\n        }\n    };\n\n    _chart.renderYAxis = function () {\n        if (leftYAxisChildren().length !== 0) {\n            _chart.renderYAxisAt('y', _chart.yAxis(), _chart.margins().left);\n            _chart.renderYAxisLabel('y', _chart.yAxisLabel(), -90);\n        }\n\n        if (rightYAxisChildren().length !== 0) {\n            _chart.renderYAxisAt('yr', _chart.rightYAxis(), _chart.width() - _chart.margins().right);\n            _chart.renderYAxisLabel('yr', _chart.rightYAxisLabel(), 90, _chart.width() - _rightYAxisLabelPadding);\n        }\n    };\n\n    function calculateYAxisRanges (left, right) {\n        var lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax;\n        var ranges;\n\n        if (left) {\n            lyAxisMin = yAxisMin();\n            lyAxisMax = yAxisMax();\n        }\n\n        if (right) {\n            ryAxisMin = rightYAxisMin();\n            ryAxisMax = rightYAxisMax();\n        }\n\n        if (_chart.alignYAxes() && left && right) {\n            ranges = alignYAxisRanges(lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax);\n        }\n\n        return ranges || {\n            lyAxisMin: lyAxisMin,\n            lyAxisMax: lyAxisMax,\n            ryAxisMin: ryAxisMin,\n            ryAxisMax: ryAxisMax\n        };\n    }\n\n    function alignYAxisRanges (lyAxisMin, lyAxisMax, ryAxisMin, ryAxisMax) {\n        // since the two series will share a zero, each Y is just a multiple\n        // of the other. and the ratio should be the ratio of the ranges of the\n        // input data, so that they come out the same height. so we just min/max\n\n        // note: both ranges already include zero due to the stack mixin (#667)\n        // if #667 changes, we can reconsider whether we want data height or\n        // height from zero to be equal. and it will be possible for the axes\n        // to be aligned but not visible.\n        var extentRatio = (ryAxisMax - ryAxisMin) / (lyAxisMax - lyAxisMin);\n\n        return {\n            lyAxisMin: Math.min(lyAxisMin, ryAxisMin / extentRatio),\n            lyAxisMax: Math.max(lyAxisMax, ryAxisMax / extentRatio),\n            ryAxisMin: Math.min(ryAxisMin, lyAxisMin * extentRatio),\n            ryAxisMax: Math.max(ryAxisMax, lyAxisMax * extentRatio)\n        };\n    }\n\n    function prepareRightYAxis (ranges) {\n        var needDomain = _chart.rightY() === undefined || _chart.elasticY(),\n            needRange = needDomain || _chart.resizing();\n        if (_chart.rightY() === undefined) {\n            _chart.rightY(d3.scale.linear());\n        }\n        if (needDomain) {\n            _chart.rightY().domain([ranges.ryAxisMin, ranges.ryAxisMax]);\n        }\n        if (needRange) {\n            _chart.rightY().rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _chart.rightY().range([_chart.yAxisHeight(), 0]);\n        _chart.rightYAxis(_chart.rightYAxis().scale(_chart.rightY()));\n\n        _chart.rightYAxis().orient('right');\n    }\n\n    function prepareLeftYAxis (ranges) {\n        var needDomain = _chart.y() === undefined || _chart.elasticY(),\n            needRange = needDomain || _chart.resizing();\n        if (_chart.y() === undefined) {\n            _chart.y(d3.scale.linear());\n        }\n        if (needDomain) {\n            _chart.y().domain([ranges.lyAxisMin, ranges.lyAxisMax]);\n        }\n        if (needRange) {\n            _chart.y().rangeRound([_chart.yAxisHeight(), 0]);\n        }\n\n        _chart.y().range([_chart.yAxisHeight(), 0]);\n        _chart.yAxis(_chart.yAxis().scale(_chart.y()));\n\n        _chart.yAxis().orient('left');\n    }\n\n    function generateChildG (child, i) {\n        child._generateG(_chart.g());\n        child.g().attr('class', SUB_CHART_CLASS + ' _' + i);\n    }\n\n    _chart.plotData = function () {\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n\n            if (!child.g()) {\n                generateChildG(child, i);\n            }\n\n            if (_shareColors) {\n                child.colors(_chart.colors());\n            }\n\n            child.x(_chart.x());\n\n            child.xAxis(_chart.xAxis());\n\n            if (child.useRightYAxis()) {\n                child.y(_chart.rightY());\n                child.yAxis(_chart.rightYAxis());\n            } else {\n                child.y(_chart.y());\n                child.yAxis(_chart.yAxis());\n            }\n\n            child.plotData();\n\n            child._activateRenderlets();\n        }\n    };\n\n    /**\n     * Get or set whether to draw gridlines from the right y axis.  Drawing from the left y axis is the\n     * default behavior. This option is only respected when subcharts with both left and right y-axes\n     * are present.\n     * @method useRightAxisGridLines\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [useRightAxisGridLines=false]\n     * @returns {Boolean|dc.compositeChart}\n     */\n    _chart.useRightAxisGridLines = function (useRightAxisGridLines) {\n        if (!arguments) {\n            return _rightAxisGridLines;\n        }\n\n        _rightAxisGridLines = useRightAxisGridLines;\n        return _chart;\n    };\n\n    /**\n     * Get or set chart-specific options for all child charts. This is equivalent to calling\n     * {@link dc.baseMixin#options .options} on each child chart.\n     * @method childOptions\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Object} [childOptions]\n     * @returns {Object|dc.compositeChart}\n     */\n    _chart.childOptions = function (childOptions) {\n        if (!arguments.length) {\n            return _childOptions;\n        }\n        _childOptions = childOptions;\n        _children.forEach(function (child) {\n            child.options(_childOptions);\n        });\n        return _chart;\n    };\n\n    _chart.fadeDeselectedArea = function () {\n        for (var i = 0; i < _children.length; ++i) {\n            var child = _children[i];\n            child.brush(_chart.brush());\n            child.fadeDeselectedArea();\n        }\n    };\n\n    /**\n     * Set or get the right y axis label.\n     * @method rightYAxisLabel\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {String} [rightYAxisLabel]\n     * @param {Number} [padding]\n     * @returns {String|dc.compositeChart}\n     */\n    _chart.rightYAxisLabel = function (rightYAxisLabel, padding) {\n        if (!arguments.length) {\n            return _rightYAxisLabel;\n        }\n        _rightYAxisLabel = rightYAxisLabel;\n        _chart.margins().right -= _rightYAxisLabelPadding;\n        _rightYAxisLabelPadding = (padding === undefined) ? DEFAULT_RIGHT_Y_AXIS_LABEL_PADDING : padding;\n        _chart.margins().right += _rightYAxisLabelPadding;\n        return _chart;\n    };\n\n    /**\n     * Combine the given charts into one single composite coordinate grid chart.\n     * @method compose\n     * @memberof dc.compositeChart\n     * @instance\n     * @example\n     * moveChart.compose([\n     *     // when creating sub-chart you need to pass in the parent chart\n     *     dc.lineChart(moveChart)\n     *         .group(indexAvgByMonthGroup) // if group is missing then parent's group will be used\n     *         .valueAccessor(function (d){return d.value.avg;})\n     *         // most of the normal functions will continue to work in a composed chart\n     *         .renderArea(true)\n     *         .stack(monthlyMoveGroup, function (d){return d.value;})\n     *         .title(function (d){\n     *             var value = d.value.avg?d.value.avg:d.value;\n     *             if(isNaN(value)) value = 0;\n     *             return dateFormat(d.key) + '\\n' + numberFormat(value);\n     *         }),\n     *     dc.barChart(moveChart)\n     *         .group(volumeByMonthGroup)\n     *         .centerBar(true)\n     * ]);\n     * @param {Array<Chart>} [subChartArray]\n     * @returns {dc.compositeChart}\n     */\n    _chart.compose = function (subChartArray) {\n        _children = subChartArray;\n        _children.forEach(function (child) {\n            child.height(_chart.height());\n            child.width(_chart.width());\n            child.margins(_chart.margins());\n\n            if (_shareTitle) {\n                child.title(_chart.title());\n            }\n\n            child.options(_childOptions);\n        });\n        return _chart;\n    };\n\n    /**\n     * Returns the child charts which are composed into the composite chart.\n     * @method children\n     * @memberof dc.compositeChart\n     * @instance\n     * @returns {Array<dc.baseMixin>}\n     */\n    _chart.children = function () {\n        return _children;\n    };\n\n    /**\n     * Get or set color sharing for the chart. If set, the {@link dc.colorMixin#colors .colors()} value from this chart\n     * will be shared with composed children. Additionally if the child chart implements\n     * Stackable and has not set a custom .colorAccessor, then it will generate a color\n     * specific to its order in the composition.\n     * @method shareColors\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [shareColors=false]\n     * @returns {Boolean|dc.compositeChart}\n     */\n    _chart.shareColors = function (shareColors) {\n        if (!arguments.length) {\n            return _shareColors;\n        }\n        _shareColors = shareColors;\n        return _chart;\n    };\n\n    /**\n     * Get or set title sharing for the chart. If set, the {@link dc.baseMixin#title .title()} value from\n     * this chart will be shared with composed children.\n     * @method shareTitle\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [shareTitle=true]\n     * @returns {Boolean|dc.compositeChart}\n     */\n    _chart.shareTitle = function (shareTitle) {\n        if (!arguments.length) {\n            return _shareTitle;\n        }\n        _shareTitle = shareTitle;\n        return _chart;\n    };\n\n    /**\n     * Get or set the y scale for the right axis. The right y scale is typically automatically\n     * generated by the chart implementation.\n     * @method rightY\n     * @memberof dc.compositeChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Scales.md d3.scale}\n     * @param {d3.scale} [yScale]\n     * @returns {d3.scale|dc.compositeChart}\n     */\n    _chart.rightY = function (yScale) {\n        if (!arguments.length) {\n            return _rightY;\n        }\n        _rightY = yScale;\n        _chart.rescale();\n        return _chart;\n    };\n\n    /**\n     * Get or set alignment between left and right y axes. A line connecting '0' on both y axis\n     * will be parallel to x axis. This only has effect when {@link #dc.coordinateGridMixin+elasticY elasticY} is true.\n     * @method alignYAxes\n     * @memberof dc.compositeChart\n     * @instance\n     * @param {Boolean} [alignYAxes=false]\n     * @returns {Chart}\n     */\n    _chart.alignYAxes = function (alignYAxes) {\n        if (!arguments.length) {\n            return _alignYAxes;\n        }\n        _alignYAxes = alignYAxes;\n        _chart.rescale();\n        return _chart;\n    };\n\n    function leftYAxisChildren () {\n        return _children.filter(function (child) {\n            return !child.useRightYAxis();\n        });\n    }\n\n    function rightYAxisChildren () {\n        return _children.filter(function (child) {\n            return child.useRightYAxis();\n        });\n    }\n\n    function getYAxisMin (charts) {\n        return charts.map(function (c) {\n            return c.yAxisMin();\n        });\n    }\n\n    delete _chart.yAxisMin;\n    function yAxisMin () {\n        return d3.min(getYAxisMin(leftYAxisChildren()));\n    }\n\n    function rightYAxisMin () {\n        return d3.min(getYAxisMin(rightYAxisChildren()));\n    }\n\n    function getYAxisMax (charts) {\n        return charts.map(function (c) {\n            return c.yAxisMax();\n        });\n    }\n\n    delete _chart.yAxisMax;\n    function yAxisMax () {\n        return dc.utils.add(d3.max(getYAxisMax(leftYAxisChildren())), _chart.yAxisPadding());\n    }\n\n    function rightYAxisMax () {\n        return dc.utils.add(d3.max(getYAxisMax(rightYAxisChildren())), _chart.yAxisPadding());\n    }\n\n    function getAllXAxisMinFromChildCharts () {\n        return _children.map(function (c) {\n            return c.xAxisMin();\n        });\n    }\n\n    dc.override(_chart, 'xAxisMin', function () {\n        return dc.utils.subtract(d3.min(getAllXAxisMinFromChildCharts()), _chart.xAxisPadding());\n    });\n\n    function getAllXAxisMaxFromChildCharts () {\n        return _children.map(function (c) {\n            return c.xAxisMax();\n        });\n    }\n\n    dc.override(_chart, 'xAxisMax', function () {\n        return dc.utils.add(d3.max(getAllXAxisMaxFromChildCharts()), _chart.xAxisPadding());\n    });\n\n    _chart.legendables = function () {\n        return _children.reduce(function (items, child) {\n            if (_shareColors) {\n                child.colors(_chart.colors());\n            }\n            items.push.apply(items, child.legendables());\n            return items;\n        }, []);\n    };\n\n    _chart.legendHighlight = function (d) {\n        for (var j = 0; j < _children.length; ++j) {\n            var child = _children[j];\n            child.legendHighlight(d);\n        }\n    };\n\n    _chart.legendReset = function (d) {\n        for (var j = 0; j < _children.length; ++j) {\n            var child = _children[j];\n            child.legendReset(d);\n        }\n    };\n\n    _chart.legendToggle = function () {\n        console.log('composite should not be getting legendToggle itself');\n    };\n\n    /**\n     * Set or get the right y axis used by the composite chart. This function is most useful when y\n     * axis customization is required. The y axis in dc.js is an instance of a [d3 axis\n     * object](https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis) therefore it supports any valid\n     * d3 axis manipulation.\n     *\n     * **Caution**: The y axis is usually generated internally by dc; resetting it may cause\n     * unexpected results.\n     * @method rightYAxis\n     * @memberof dc.compositeChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize y axis tick format\n     * chart.rightYAxis().tickFormat(function (v) {return v + '%';});\n     * // customize y axis tick values\n     * chart.rightYAxis().tickValues([0, 100, 200, 300]);\n     * @param {d3.svg.axis} [rightYAxis]\n     * @returns {d3.svg.axis|dc.compositeChart}\n     */\n    _chart.rightYAxis = function (rightYAxis) {\n        if (!arguments.length) {\n            return _rightYAxis;\n        }\n        _rightYAxis = rightYAxis;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A series chart is a chart that shows multiple series of data overlaid on one chart, where the\n * series is specified in the data. It is a specialization of Composite Chart and inherits all\n * composite features other than recomposing the chart.\n *\n * Examples:\n * - {@link http://dc-js.github.io/dc.js/examples/series.html Series Chart}\n * @class seriesChart\n * @memberof dc\n * @mixes dc.compositeChart\n * @example\n * // create a series chart under #chart-container1 element using the default global chart group\n * var seriesChart1 = dc.seriesChart(\"#chart-container1\");\n * // create a series chart under #chart-container2 element using chart group A\n * var seriesChart2 = dc.seriesChart(\"#chart-container2\", \"chartGroupA\");\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.seriesChart}\n */\ndc.seriesChart = function (parent, chartGroup) {\n    var _chart = dc.compositeChart(parent, chartGroup);\n\n    function keySort (a, b) {\n        return d3.ascending(_chart.keyAccessor()(a), _chart.keyAccessor()(b));\n    }\n\n    var _charts = {};\n    var _chartFunction = dc.lineChart;\n    var _seriesAccessor;\n    var _seriesSort = d3.ascending;\n    var _valueSort = keySort;\n\n    _chart._mandatoryAttributes().push('seriesAccessor', 'chart');\n    _chart.shareColors(true);\n\n    _chart._preprocessData = function () {\n        var keep = [];\n        var childrenChanged;\n        var nester = d3.nest().key(_seriesAccessor);\n        if (_seriesSort) {\n            nester.sortKeys(_seriesSort);\n        }\n        if (_valueSort) {\n            nester.sortValues(_valueSort);\n        }\n        var nesting = nester.entries(_chart.data());\n        var children =\n            nesting.map(function (sub, i) {\n                var subChart = _charts[sub.key] || _chartFunction.call(_chart, _chart, chartGroup, sub.key, i);\n                if (!_charts[sub.key]) {\n                    childrenChanged = true;\n                }\n                _charts[sub.key] = subChart;\n                keep.push(sub.key);\n                return subChart\n                    .dimension(_chart.dimension())\n                    .group({all: d3.functor(sub.values)}, sub.key)\n                    .keyAccessor(_chart.keyAccessor())\n                    .valueAccessor(_chart.valueAccessor())\n                    .brushOn(_chart.brushOn());\n            });\n        // this works around the fact compositeChart doesn't really\n        // have a removal interface\n        Object.keys(_charts)\n            .filter(function (c) {return keep.indexOf(c) === -1;})\n            .forEach(function (c) {\n                clearChart(c);\n                childrenChanged = true;\n            });\n        _chart._compose(children);\n        if (childrenChanged && _chart.legend()) {\n            _chart.legend().render();\n        }\n    };\n\n    function clearChart (c) {\n        if (_charts[c].g()) {\n            _charts[c].g().remove();\n        }\n        delete _charts[c];\n    }\n\n    function resetChildren () {\n        Object.keys(_charts).map(clearChart);\n        _charts = {};\n    }\n\n    /**\n     * Get or set the chart function, which generates the child charts.\n     * @method chart\n     * @memberof dc.seriesChart\n     * @instance\n     * @example\n     * // put interpolation on the line charts used for the series\n     * chart.chart(function(c) { return dc.lineChart(c).interpolate('basis'); })\n     * // do a scatter series chart\n     * chart.chart(dc.scatterPlot)\n     * @param {Function} [chartFunction=dc.lineChart]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.chart = function (chartFunction) {\n        if (!arguments.length) {\n            return _chartFunction;\n        }\n        _chartFunction = chartFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Get or set accessor function for the displayed series. Given a datum, this function\n     * should return the series that datum belongs to.\n     * @method seriesAccessor\n     * @memberof dc.seriesChart\n     * @instance\n     * @example\n     * // simple series accessor\n     * chart.seriesAccessor(function(d) { return \"Expt: \" + d.key[0]; })\n     * @param {Function} [accessor]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.seriesAccessor = function (accessor) {\n        if (!arguments.length) {\n            return _seriesAccessor;\n        }\n        _seriesAccessor = accessor;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\n     * Get or set a function to sort the list of series by, given series values.\n     * @method seriesSort\n     * @memberof dc.seriesChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * chart.seriesSort(d3.descending);\n     * @param {Function} [sortFunction=d3.ascending]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.seriesSort = function (sortFunction) {\n        if (!arguments.length) {\n            return _seriesSort;\n        }\n        _seriesSort = sortFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    /**\n     * Get or set a function to sort each series values by. By default this is the key accessor which,\n     * for example, will ensure a lineChart series connects its points in increasing key/x order,\n     * rather than haphazardly.\n     * @method valueSort\n     * @memberof dc.seriesChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_ascending d3.ascending}\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Arrays.md#d3_descending d3.descending}\n     * @example\n     * // Default value sort\n     * _chart.valueSort(function keySort (a, b) {\n     *     return d3.ascending(_chart.keyAccessor()(a), _chart.keyAccessor()(b));\n     * });\n     * @param {Function} [sortFunction]\n     * @returns {Function|dc.seriesChart}\n     */\n    _chart.valueSort = function (sortFunction) {\n        if (!arguments.length) {\n            return _valueSort;\n        }\n        _valueSort = sortFunction;\n        resetChildren();\n        return _chart;\n    };\n\n    // make compose private\n    _chart._compose = _chart.compose;\n    delete _chart.compose;\n\n    return _chart;\n};\n\n/**\n * The geo choropleth chart is designed as an easy way to create a crossfilter driven choropleth map\n * from GeoJson data. This chart implementation was inspired by\n * {@link http://bl.ocks.org/4060606 the great d3 choropleth example}.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/vc/index.html US Venture Capital Landscape 2011}\n * @class geoChoroplethChart\n * @memberof dc\n * @mixes dc.colorMixin\n * @mixes dc.baseMixin\n * @example\n * // create a choropleth chart under '#us-chart' element using the default global chart group\n * var chart1 = dc.geoChoroplethChart('#us-chart');\n * // create a choropleth chart under '#us-chart2' element using chart group A\n * var chart2 = dc.compositeChart('#us-chart2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.geoChoroplethChart}\n */\ndc.geoChoroplethChart = function (parent, chartGroup) {\n    var _chart = dc.colorMixin(dc.baseMixin({}));\n\n    _chart.colorAccessor(function (d) {\n        return d || 0;\n    });\n\n    var _geoPath = d3.geo.path();\n    var _projectionFlag;\n\n    var _geoJsons = [];\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n        for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {\n            var states = _chart.svg().append('g')\n                .attr('class', 'layer' + layerIndex);\n\n            var regionG = states.selectAll('g.' + geoJson(layerIndex).name)\n                .data(geoJson(layerIndex).data)\n                .enter()\n                .append('g')\n                .attr('class', geoJson(layerIndex).name);\n\n            regionG\n                .append('path')\n                .attr('fill', 'white')\n                .attr('d', _geoPath);\n\n            regionG.append('title');\n\n            plotData(layerIndex);\n        }\n        _projectionFlag = false;\n    };\n\n    function plotData (layerIndex) {\n        var data = generateLayeredData();\n\n        if (isDataLayer(layerIndex)) {\n            var regionG = renderRegionG(layerIndex);\n\n            renderPaths(regionG, layerIndex, data);\n\n            renderTitle(regionG, layerIndex, data);\n        }\n    }\n\n    function generateLayeredData () {\n        var data = {};\n        var groupAll = _chart.data();\n        for (var i = 0; i < groupAll.length; ++i) {\n            data[_chart.keyAccessor()(groupAll[i])] = _chart.valueAccessor()(groupAll[i]);\n        }\n        return data;\n    }\n\n    function isDataLayer (layerIndex) {\n        return geoJson(layerIndex).keyAccessor;\n    }\n\n    function renderRegionG (layerIndex) {\n        var regionG = _chart.svg()\n            .selectAll(layerSelector(layerIndex))\n            .classed('selected', function (d) {\n                return isSelected(layerIndex, d);\n            })\n            .classed('deselected', function (d) {\n                return isDeselected(layerIndex, d);\n            })\n            .attr('class', function (d) {\n                var layerNameClass = geoJson(layerIndex).name;\n                var regionClass = dc.utils.nameToId(geoJson(layerIndex).keyAccessor(d));\n                var baseClasses = layerNameClass + ' ' + regionClass;\n                if (isSelected(layerIndex, d)) {\n                    baseClasses += ' selected';\n                }\n                if (isDeselected(layerIndex, d)) {\n                    baseClasses += ' deselected';\n                }\n                return baseClasses;\n            });\n        return regionG;\n    }\n\n    function layerSelector (layerIndex) {\n        return 'g.layer' + layerIndex + ' g.' + geoJson(layerIndex).name;\n    }\n\n    function isSelected (layerIndex, d) {\n        return _chart.hasFilter() && _chart.hasFilter(getKey(layerIndex, d));\n    }\n\n    function isDeselected (layerIndex, d) {\n        return _chart.hasFilter() && !_chart.hasFilter(getKey(layerIndex, d));\n    }\n\n    function getKey (layerIndex, d) {\n        return geoJson(layerIndex).keyAccessor(d);\n    }\n\n    function geoJson (index) {\n        return _geoJsons[index];\n    }\n\n    function renderPaths (regionG, layerIndex, data) {\n        var paths = regionG\n            .select('path')\n            .attr('fill', function () {\n                var currentFill = d3.select(this).attr('fill');\n                if (currentFill) {\n                    return currentFill;\n                }\n                return 'none';\n            })\n            .on('click', function (d) {\n                return _chart.onClick(d, layerIndex);\n            });\n\n        dc.transition(paths, _chart.transitionDuration(), _chart.transitionDelay()).attr('fill', function (d, i) {\n            return _chart.getColor(data[geoJson(layerIndex).keyAccessor(d)], i);\n        });\n    }\n\n    _chart.onClick = function (d, layerIndex) {\n        var selectedRegion = geoJson(layerIndex).keyAccessor(d);\n        dc.events.trigger(function () {\n            _chart.filter(selectedRegion);\n            _chart.redrawGroup();\n        });\n    };\n\n    function renderTitle (regionG, layerIndex, data) {\n        if (_chart.renderTitle()) {\n            regionG.selectAll('title').text(function (d) {\n                var key = getKey(layerIndex, d);\n                var value = data[key];\n                return _chart.title()({key: key, value: value});\n            });\n        }\n    }\n\n    _chart._doRedraw = function () {\n        for (var layerIndex = 0; layerIndex < _geoJsons.length; ++layerIndex) {\n            plotData(layerIndex);\n            if (_projectionFlag) {\n                _chart.svg().selectAll('g.' + geoJson(layerIndex).name + ' path').attr('d', _geoPath);\n            }\n        }\n        _projectionFlag = false;\n    };\n\n    /**\n     * **mandatory**\n     *\n     * Use this function to insert a new GeoJson map layer. This function can be invoked multiple times\n     * if you have multiple GeoJson data layers to render on top of each other. If you overlay multiple\n     * layers with the same name the new overlay will override the existing one.\n     * @method overlayGeoJson\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @see {@link http://geojson.org/ GeoJSON}\n     * @see {@link https://github.com/topojson/topojson/wiki TopoJSON}\n     * @see {@link https://github.com/topojson/topojson-1.x-api-reference/blob/master/API-Reference.md#wiki-feature topojson.feature}\n     * @example\n     * // insert a layer for rendering US states\n     * chart.overlayGeoJson(statesJson.features, 'state', function(d) {\n     *      return d.properties.name;\n     * });\n     * @param {geoJson} json - a geojson feed\n     * @param {String} name - name of the layer\n     * @param {Function} keyAccessor - accessor function used to extract 'key' from the GeoJson data. The key extracted by\n     * this function should match the keys returned by the crossfilter groups.\n     * @returns {dc.geoChoroplethChart}\n     */\n    _chart.overlayGeoJson = function (json, name, keyAccessor) {\n        for (var i = 0; i < _geoJsons.length; ++i) {\n            if (_geoJsons[i].name === name) {\n                _geoJsons[i].data = json;\n                _geoJsons[i].keyAccessor = keyAccessor;\n                return _chart;\n            }\n        }\n        _geoJsons.push({name: name, data: json, keyAccessor: keyAccessor});\n        return _chart;\n    };\n\n    /**\n     * Set custom geo projection function. See the available\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Projections.md d3 geo projection functions}.\n     * @method projection\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Projections.md d3.geo.projection}\n     * @see {@link https://github.com/d3/d3-geo-projection Extended d3.geo.projection}\n     * @param {d3.projection} [projection=d3.geo.albersUsa()]\n     * @returns {dc.geoChoroplethChart}\n     */\n    _chart.projection = function (projection) {\n        _geoPath.projection(projection);\n        _projectionFlag = true;\n        return _chart;\n    };\n\n    /**\n     * Returns all GeoJson layers currently registered with this chart. The returned array is a\n     * reference to this chart's internal data structure, so any modification to this array will also\n     * modify this chart's internal registration.\n     * @method geoJsons\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @returns {Array<{name:String, data: Object, accessor: Function}>}\n     */\n    _chart.geoJsons = function () {\n        return _geoJsons;\n    };\n\n    /**\n     * Returns the {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Paths.md#path d3.geo.path} object used to\n     * render the projection and features.  Can be useful for figuring out the bounding box of the\n     * feature set and thus a way to calculate scale and translation for the projection.\n     * @method geoPath\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Geo-Paths.md#path d3.geo.path}\n     * @returns {d3.geo.path}\n     */\n    _chart.geoPath = function () {\n        return _geoPath;\n    };\n\n    /**\n     * Remove a GeoJson layer from this chart by name\n     * @method removeGeoJson\n     * @memberof dc.geoChoroplethChart\n     * @instance\n     * @param {String} name\n     * @returns {dc.geoChoroplethChart}\n     */\n    _chart.removeGeoJson = function (name) {\n        var geoJsons = [];\n\n        for (var i = 0; i < _geoJsons.length; ++i) {\n            var layer = _geoJsons[i];\n            if (layer.name !== name) {\n                geoJsons.push(layer);\n            }\n        }\n\n        _geoJsons = geoJsons;\n\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The bubble overlay chart is quite different from the typical bubble chart. With the bubble overlay\n * chart you can arbitrarily place bubbles on an existing svg or bitmap image, thus changing the\n * typical x and y positioning while retaining the capability to visualize data using bubble radius\n * and coloring.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class bubbleOverlay\n * @memberof dc\n * @mixes dc.bubbleMixin\n * @mixes dc.baseMixin\n * @example\n * // create a bubble overlay chart on top of the '#chart-container1 svg' element using the default global chart group\n * var bubbleChart1 = dc.bubbleOverlayChart('#chart-container1').svg(d3.select('#chart-container1 svg'));\n * // create a bubble overlay chart on top of the '#chart-container2 svg' element using chart group A\n * var bubbleChart2 = dc.compositeChart('#chart-container2', 'chartGroupA').svg(d3.select('#chart-container2 svg'));\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.bubbleOverlay}\n */\ndc.bubbleOverlay = function (parent, chartGroup) {\n    var BUBBLE_OVERLAY_CLASS = 'bubble-overlay';\n    var BUBBLE_NODE_CLASS = 'node';\n    var BUBBLE_CLASS = 'bubble';\n\n    /**\n     * **mandatory**\n     *\n     * Set the underlying svg image element. Unlike other dc charts this chart will not generate a svg\n     * element; therefore the bubble overlay chart will not work if this function is not invoked. If the\n     * underlying image is a bitmap, then an empty svg will need to be created on top of the image.\n     * @method svg\n     * @memberof dc.bubbleOverlay\n     * @instance\n     * @example\n     * // set up underlying svg element\n     * chart.svg(d3.select('#chart svg'));\n     * @param {SVGElement|d3.selection} [imageElement]\n     * @returns {dc.bubbleOverlay}\n     */\n    var _chart = dc.bubbleMixin(dc.baseMixin({}));\n    var _g;\n    var _points = [];\n\n    _chart.transitionDuration(750);\n\n    _chart.transitionDelay(0);\n\n    _chart.radiusValueAccessor(function (d) {\n        return d.value;\n    });\n\n    /**\n     * **mandatory**\n     *\n     * Set up a data point on the overlay. The name of a data point should match a specific 'key' among\n     * data groups generated using keyAccessor.  If a match is found (point name <-> data group key)\n     * then a bubble will be generated at the position specified by the function. x and y\n     * value specified here are relative to the underlying svg.\n     * @method point\n     * @memberof dc.bubbleOverlay\n     * @instance\n     * @param {String} name\n     * @param {Number} x\n     * @param {Number} y\n     * @returns {dc.bubbleOverlay}\n     */\n    _chart.point = function (name, x, y) {\n        _points.push({name: name, x: x, y: y});\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        _g = initOverlayG();\n\n        _chart.r().range([_chart.MIN_RADIUS, _chart.width() * _chart.maxBubbleRelativeSize()]);\n\n        initializeBubbles();\n\n        _chart.fadeDeselectedArea();\n\n        return _chart;\n    };\n\n    function initOverlayG () {\n        _g = _chart.select('g.' + BUBBLE_OVERLAY_CLASS);\n        if (_g.empty()) {\n            _g = _chart.svg().append('g').attr('class', BUBBLE_OVERLAY_CLASS);\n        }\n        return _g;\n    }\n\n    function initializeBubbles () {\n        var data = mapData();\n        _chart.calculateRadiusDomain();\n\n        _points.forEach(function (point) {\n            var nodeG = getNodeG(point, data);\n\n            var circle = nodeG.select('circle.' + BUBBLE_CLASS);\n\n            if (circle.empty()) {\n                circle = nodeG.append('circle')\n                    .attr('class', BUBBLE_CLASS)\n                    .attr('r', 0)\n                    .attr('fill', _chart.getColor)\n                    .on('click', _chart.onClick);\n            }\n\n            dc.transition(circle, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('r', function (d) {\n                    return _chart.bubbleR(d);\n                });\n\n            _chart._doRenderLabel(nodeG);\n\n            _chart._doRenderTitles(nodeG);\n        });\n    }\n\n    function mapData () {\n        var data = {};\n        _chart.data().forEach(function (datum) {\n            data[_chart.keyAccessor()(datum)] = datum;\n        });\n        return data;\n    }\n\n    function getNodeG (point, data) {\n        var bubbleNodeClass = BUBBLE_NODE_CLASS + ' ' + dc.utils.nameToId(point.name);\n\n        var nodeG = _g.select('g.' + dc.utils.nameToId(point.name));\n\n        if (nodeG.empty()) {\n            nodeG = _g.append('g')\n                .attr('class', bubbleNodeClass)\n                .attr('transform', 'translate(' + point.x + ',' + point.y + ')');\n        }\n\n        nodeG.datum(data[point.name]);\n\n        return nodeG;\n    }\n\n    _chart._doRedraw = function () {\n        updateBubbles();\n\n        _chart.fadeDeselectedArea();\n\n        return _chart;\n    };\n\n    function updateBubbles () {\n        var data = mapData();\n        _chart.calculateRadiusDomain();\n\n        _points.forEach(function (point) {\n            var nodeG = getNodeG(point, data);\n\n            var circle = nodeG.select('circle.' + BUBBLE_CLASS);\n\n            dc.transition(circle, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('r', function (d) {\n                    return _chart.bubbleR(d);\n                })\n                .attr('fill', _chart.getColor);\n\n            _chart.doUpdateLabels(nodeG);\n\n            _chart.doUpdateTitles(nodeG);\n        });\n    }\n\n    _chart.debug = function (flag) {\n        if (flag) {\n            var debugG = _chart.select('g.' + dc.constants.DEBUG_GROUP_CLASS);\n\n            if (debugG.empty()) {\n                debugG = _chart.svg()\n                    .append('g')\n                    .attr('class', dc.constants.DEBUG_GROUP_CLASS);\n            }\n\n            var debugText = debugG.append('text')\n                .attr('x', 10)\n                .attr('y', 20);\n\n            debugG\n                .append('rect')\n                .attr('width', _chart.width())\n                .attr('height', _chart.height())\n                .on('mousemove', function () {\n                    var position = d3.mouse(debugG.node());\n                    var msg = position[0] + ', ' + position[1];\n                    debugText.text(msg);\n                });\n        } else {\n            _chart.selectAll('.debug').remove();\n        }\n\n        return _chart;\n    };\n\n    _chart.anchor(parent, chartGroup);\n\n    return _chart;\n};\n\n/**\n * Concrete row chart implementation.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * @class rowChart\n * @memberof dc\n * @mixes dc.capMixin\n * @mixes dc.marginMixin\n * @mixes dc.colorMixin\n * @mixes dc.baseMixin\n * @example\n * // create a row chart under #chart-container1 element using the default global chart group\n * var chart1 = dc.rowChart('#chart-container1');\n * // create a row chart under #chart-container2 element using chart group A\n * var chart2 = dc.rowChart('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.rowChart}\n */\ndc.rowChart = function (parent, chartGroup) {\n\n    var _g;\n\n    var _labelOffsetX = 10;\n    var _labelOffsetY = 15;\n    var _hasLabelOffsetY = false;\n    var _dyOffset = '0.35em';  // this helps center labels https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#svg_text\n    var _titleLabelOffsetX = 2;\n\n    var _gap = 5;\n\n    var _fixedBarHeight = false;\n    var _rowCssClass = 'row';\n    var _titleRowCssClass = 'titlerow';\n    var _renderTitleLabel = false;\n\n    var _chart = dc.capMixin(dc.marginMixin(dc.colorMixin(dc.baseMixin({}))));\n\n    var _x;\n\n    var _elasticX;\n\n    var _xAxis = d3.svg.axis().orient('bottom');\n\n    var _rowData;\n\n    _chart.rowsCap = _chart.cap;\n\n    function calculateAxisScale () {\n        if (!_x || _elasticX) {\n            var extent = d3.extent(_rowData, _chart.cappedValueAccessor);\n            if (extent[0] > 0) {\n                extent[0] = 0;\n            }\n            if (extent[1] < 0) {\n                extent[1] = 0;\n            }\n            _x = d3.scale.linear().domain(extent)\n                .range([0, _chart.effectiveWidth()]);\n        }\n        _xAxis.scale(_x);\n    }\n\n    function drawAxis () {\n        var axisG = _g.select('g.axis');\n\n        calculateAxisScale();\n\n        if (axisG.empty()) {\n            axisG = _g.append('g').attr('class', 'axis');\n        }\n        axisG.attr('transform', 'translate(0, ' + _chart.effectiveHeight() + ')');\n\n        dc.transition(axisG, _chart.transitionDuration(), _chart.transitionDelay())\n            .call(_xAxis);\n    }\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _g = _chart.svg()\n            .append('g')\n            .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n\n        drawChart();\n\n        return _chart;\n    };\n\n    _chart.title(function (d) {\n        return _chart.cappedKeyAccessor(d) + ': ' + _chart.cappedValueAccessor(d);\n    });\n\n    _chart.label(_chart.cappedKeyAccessor);\n\n    /**\n     * Gets or sets the x scale. The x scale can be any d3\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale}.\n     * @method x\n     * @memberof dc.rowChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Quantitative-Scales.md quantitive scale}\n     * @param {d3.scale} [scale]\n     * @returns {d3.scale|dc.rowChart}\n     */\n    _chart.x = function (scale) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = scale;\n        return _chart;\n    };\n\n    function drawGridLines () {\n        _g.selectAll('g.tick')\n            .select('line.grid-line')\n            .remove();\n\n        _g.selectAll('g.tick')\n            .append('line')\n            .attr('class', 'grid-line')\n            .attr('x1', 0)\n            .attr('y1', 0)\n            .attr('x2', 0)\n            .attr('y2', function () {\n                return -_chart.effectiveHeight();\n            });\n    }\n\n    function drawChart () {\n        _rowData = _chart.data();\n\n        drawAxis();\n        drawGridLines();\n\n        var rows = _g.selectAll('g.' + _rowCssClass)\n            .data(_rowData);\n\n        createElements(rows);\n        removeElements(rows);\n        updateElements(rows);\n    }\n\n    function createElements (rows) {\n        var rowEnter = rows.enter()\n            .append('g')\n            .attr('class', function (d, i) {\n                return _rowCssClass + ' _' + i;\n            });\n\n        rowEnter.append('rect').attr('width', 0);\n\n        createLabels(rowEnter);\n    }\n\n    function removeElements (rows) {\n        rows.exit().remove();\n    }\n\n    function rootValue () {\n        var root = _x(0);\n        return (root === -Infinity || root !== root) ? _x(1) : root;\n    }\n\n    function updateElements (rows) {\n        var n = _rowData.length;\n\n        var height;\n        if (!_fixedBarHeight) {\n            height = (_chart.effectiveHeight() - (n + 1) * _gap) / n;\n        } else {\n            height = _fixedBarHeight;\n        }\n\n        // vertically align label in center unless they override the value via property setter\n        if (!_hasLabelOffsetY) {\n            _labelOffsetY = height / 2;\n        }\n\n        var rect = rows.attr('transform', function (d, i) {\n                return 'translate(0,' + ((i + 1) * _gap + i * height) + ')';\n            }).select('rect')\n            .attr('height', height)\n            .attr('fill', _chart.getColor)\n            .on('click', onClick)\n            .classed('deselected', function (d) {\n                return (_chart.hasFilter()) ? !isSelectedRow(d) : false;\n            })\n            .classed('selected', function (d) {\n                return (_chart.hasFilter()) ? isSelectedRow(d) : false;\n            });\n\n        dc.transition(rect, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('width', function (d) {\n                return Math.abs(rootValue() - _x(_chart.valueAccessor()(d)));\n            })\n            .attr('transform', translateX);\n\n        createTitles(rows);\n        updateLabels(rows);\n    }\n\n    function createTitles (rows) {\n        if (_chart.renderTitle()) {\n            rows.select('title').remove();\n            rows.append('title').text(_chart.title());\n        }\n    }\n\n    function createLabels (rowEnter) {\n        if (_chart.renderLabel()) {\n            rowEnter.append('text')\n                .on('click', onClick);\n        }\n        if (_chart.renderTitleLabel()) {\n            rowEnter.append('text')\n                .attr('class', _titleRowCssClass)\n                .on('click', onClick);\n        }\n    }\n\n    function updateLabels (rows) {\n        if (_chart.renderLabel()) {\n            var lab = rows.select('text')\n                .attr('x', _labelOffsetX)\n                .attr('y', _labelOffsetY)\n                .attr('dy', _dyOffset)\n                .on('click', onClick)\n                .attr('class', function (d, i) {\n                    return _rowCssClass + ' _' + i;\n                })\n                .text(function (d) {\n                    return _chart.label()(d);\n                });\n            dc.transition(lab, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('transform', translateX);\n        }\n        if (_chart.renderTitleLabel()) {\n            var titlelab = rows.select('.' + _titleRowCssClass)\n                    .attr('x', _chart.effectiveWidth() - _titleLabelOffsetX)\n                    .attr('y', _labelOffsetY)\n                    .attr('dy', _dyOffset)\n                    .attr('text-anchor', 'end')\n                    .on('click', onClick)\n                    .attr('class', function (d, i) {\n                        return _titleRowCssClass + ' _' + i ;\n                    })\n                    .text(function (d) {\n                        return _chart.title()(d);\n                    });\n            dc.transition(titlelab, _chart.transitionDuration(), _chart.transitionDelay())\n                .attr('transform', translateX);\n        }\n    }\n\n    /**\n     * Turn on/off Title label rendering (values) using SVG style of text-anchor 'end'.\n     * @method renderTitleLabel\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Boolean} [renderTitleLabel=false]\n     * @returns {Boolean|dc.rowChart}\n     */\n    _chart.renderTitleLabel = function (renderTitleLabel) {\n        if (!arguments.length) {\n            return _renderTitleLabel;\n        }\n        _renderTitleLabel = renderTitleLabel;\n        return _chart;\n    };\n\n    function onClick (d) {\n        _chart.onClick(d);\n    }\n\n    function translateX (d) {\n        var x = _x(_chart.cappedValueAccessor(d)),\n            x0 = rootValue(),\n            s = x > x0 ? x0 : x;\n        return 'translate(' + s + ',0)';\n    }\n\n    _chart._doRedraw = function () {\n        drawChart();\n        return _chart;\n    };\n\n    /**\n     * Get the x axis for the row chart instance.  Note: not settable for row charts.\n     * See the {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3 axis object}\n     * documention for more information.\n     * @method xAxis\n     * @memberof dc.rowChart\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Axes.md#axis d3.svg.axis}\n     * @example\n     * // customize x axis tick format\n     * chart.xAxis().tickFormat(function (v) {return v + '%';});\n     * // customize x axis tick values\n     * chart.xAxis().tickValues([0, 100, 200, 300]);\n     * @returns {d3.svg.axis}\n     */\n    _chart.xAxis = function () {\n        return _xAxis;\n    };\n\n    /**\n     * Get or set the fixed bar height. Default is [false] which will auto-scale bars.\n     * For example, if you want to fix the height for a specific number of bars (useful in TopN charts)\n     * you could fix height as follows (where count = total number of bars in your TopN and gap is\n     * your vertical gap space).\n     * @method fixedBarHeight\n     * @memberof dc.rowChart\n     * @instance\n     * @example\n     * chart.fixedBarHeight( chartheight - (count + 1) * gap / count);\n     * @param {Boolean|Number} [fixedBarHeight=false]\n     * @returns {Boolean|Number|dc.rowChart}\n     */\n    _chart.fixedBarHeight = function (fixedBarHeight) {\n        if (!arguments.length) {\n            return _fixedBarHeight;\n        }\n        _fixedBarHeight = fixedBarHeight;\n        return _chart;\n    };\n\n    /**\n     * Get or set the vertical gap space between rows on a particular row chart instance.\n     * @method gap\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [gap=5]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _chart;\n    };\n\n    /**\n     * Get or set the elasticity on x axis. If this attribute is set to true, then the x axis will rescle to auto-fit the\n     * data range when filtered.\n     * @method elasticX\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Boolean} [elasticX]\n     * @returns {Boolean|dc.rowChart}\n     */\n    _chart.elasticX = function (elasticX) {\n        if (!arguments.length) {\n            return _elasticX;\n        }\n        _elasticX = elasticX;\n        return _chart;\n    };\n\n    /**\n     * Get or set the x offset (horizontal space to the top left corner of a row) for labels on a particular row chart.\n     * @method labelOffsetX\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [labelOffsetX=10]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.labelOffsetX = function (labelOffsetX) {\n        if (!arguments.length) {\n            return _labelOffsetX;\n        }\n        _labelOffsetX = labelOffsetX;\n        return _chart;\n    };\n\n    /**\n     * Get or set the y offset (vertical space to the top left corner of a row) for labels on a particular row chart.\n     * @method labelOffsetY\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [labelOffsety=15]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.labelOffsetY = function (labelOffsety) {\n        if (!arguments.length) {\n            return _labelOffsetY;\n        }\n        _labelOffsetY = labelOffsety;\n        _hasLabelOffsetY = true;\n        return _chart;\n    };\n\n    /**\n     * Get of set the x offset (horizontal space between right edge of row and right edge or text.\n     * @method titleLabelOffsetX\n     * @memberof dc.rowChart\n     * @instance\n     * @param {Number} [titleLabelOffsetX=2]\n     * @returns {Number|dc.rowChart}\n     */\n    _chart.titleLabelOffsetX = function (titleLabelOffsetX) {\n        if (!arguments.length) {\n            return _titleLabelOffsetX;\n        }\n        _titleLabelOffsetX = titleLabelOffsetX;\n        return _chart;\n    };\n\n    function isSelectedRow (d) {\n        return _chart.hasFilter(_chart.cappedKeyAccessor(d));\n    }\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * Legend is a attachable widget that can be added to other dc charts to render horizontal legend\n * labels.\n *\n * Examples:\n * - {@link http://dc-js.github.com/dc.js/ Nasdaq 100 Index}\n * - {@link http://dc-js.github.com/dc.js/crime/index.html Canadian City Crime Stats}\n * @class legend\n * @memberof dc\n * @example\n * chart.legend(dc.legend().x(400).y(10).itemHeight(13).gap(5))\n * @returns {dc.legend}\n */\ndc.legend = function () {\n    var LABEL_GAP = 2;\n\n    var _legend = {},\n        _parent,\n        _x = 0,\n        _y = 0,\n        _itemHeight = 12,\n        _gap = 5,\n        _horizontal = false,\n        _legendWidth = 560,\n        _itemWidth = 70,\n        _autoItemWidth = false,\n        _legendText = dc.pluck('name'),\n        _maxItems;\n\n    var _g;\n\n    _legend.parent = function (p) {\n        if (!arguments.length) {\n            return _parent;\n        }\n        _parent = p;\n        return _legend;\n    };\n\n    _legend.render = function () {\n        _parent.svg().select('g.dc-legend').remove();\n        _g = _parent.svg().append('g')\n            .attr('class', 'dc-legend')\n            .attr('transform', 'translate(' + _x + ',' + _y + ')');\n        var legendables = _parent.legendables();\n\n        if (_maxItems !== undefined) {\n            legendables = legendables.slice(0, _maxItems);\n        }\n\n        var itemEnter = _g.selectAll('g.dc-legend-item')\n            .data(legendables)\n            .enter()\n            .append('g')\n            .attr('class', 'dc-legend-item')\n            .on('mouseover', function (d) {\n                _parent.legendHighlight(d);\n            })\n            .on('mouseout', function (d) {\n                _parent.legendReset(d);\n            })\n            .on('click', function (d) {\n                d.chart.legendToggle(d);\n            });\n\n        _g.selectAll('g.dc-legend-item')\n            .classed('fadeout', function (d) {\n                return d.chart.isLegendableHidden(d);\n            });\n\n        if (legendables.some(dc.pluck('dashstyle'))) {\n            itemEnter\n                .append('line')\n                .attr('x1', 0)\n                .attr('y1', _itemHeight / 2)\n                .attr('x2', _itemHeight)\n                .attr('y2', _itemHeight / 2)\n                .attr('stroke-width', 2)\n                .attr('stroke-dasharray', dc.pluck('dashstyle'))\n                .attr('stroke', dc.pluck('color'));\n        } else {\n            itemEnter\n                .append('rect')\n                .attr('width', _itemHeight)\n                .attr('height', _itemHeight)\n                .attr('fill', function (d) {return d ? d.color : 'blue';});\n        }\n\n        itemEnter.append('text')\n                .text(_legendText)\n                .attr('x', _itemHeight + LABEL_GAP)\n                .attr('y', function () {\n                    return _itemHeight / 2 + (this.clientHeight ? this.clientHeight : 13) / 2 - 2;\n                });\n\n        var _cumulativeLegendTextWidth = 0;\n        var row = 0;\n        itemEnter.attr('transform', function (d, i) {\n            if (_horizontal) {\n                var itemWidth   = _autoItemWidth === true ? this.getBBox().width + _gap : _itemWidth;\n                if ((_cumulativeLegendTextWidth + itemWidth) > _legendWidth && _cumulativeLegendTextWidth > 0) {\n                    ++row;\n                    _cumulativeLegendTextWidth = 0;\n                }\n                var translateBy = 'translate(' + _cumulativeLegendTextWidth + ',' + row * legendItemHeight() + ')';\n                _cumulativeLegendTextWidth += itemWidth;\n                return translateBy;\n            } else {\n                return 'translate(0,' + i * legendItemHeight() + ')';\n            }\n        });\n    };\n\n    function legendItemHeight () {\n        return _gap + _itemHeight;\n    }\n\n    /**\n     * Set or get x coordinate for legend widget.\n     * @method x\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [x=0]\n     * @returns {Number|dc.legend}\n     */\n    _legend.x = function (x) {\n        if (!arguments.length) {\n            return _x;\n        }\n        _x = x;\n        return _legend;\n    };\n\n    /**\n     * Set or get y coordinate for legend widget.\n     * @method y\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [y=0]\n     * @returns {Number|dc.legend}\n     */\n    _legend.y = function (y) {\n        if (!arguments.length) {\n            return _y;\n        }\n        _y = y;\n        return _legend;\n    };\n\n    /**\n     * Set or get gap between legend items.\n     * @method gap\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [gap=5]\n     * @returns {Number|dc.legend}\n     */\n    _legend.gap = function (gap) {\n        if (!arguments.length) {\n            return _gap;\n        }\n        _gap = gap;\n        return _legend;\n    };\n\n    /**\n     * Set or get legend item height.\n     * @method itemHeight\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [itemHeight=12]\n     * @returns {Number|dc.legend}\n     */\n    _legend.itemHeight = function (itemHeight) {\n        if (!arguments.length) {\n            return _itemHeight;\n        }\n        _itemHeight = itemHeight;\n        return _legend;\n    };\n\n    /**\n     * Position legend horizontally instead of vertically.\n     * @method horizontal\n     * @memberof dc.legend\n     * @instance\n     * @param  {Boolean} [horizontal=false]\n     * @returns {Boolean|dc.legend}\n     */\n    _legend.horizontal = function (horizontal) {\n        if (!arguments.length) {\n            return _horizontal;\n        }\n        _horizontal = horizontal;\n        return _legend;\n    };\n\n    /**\n     * Maximum width for horizontal legend.\n     * @method legendWidth\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [legendWidth=500]\n     * @returns {Number|dc.legend}\n     */\n    _legend.legendWidth = function (legendWidth) {\n        if (!arguments.length) {\n            return _legendWidth;\n        }\n        _legendWidth = legendWidth;\n        return _legend;\n    };\n\n    /**\n     * Legend item width for horizontal legend.\n     * @method itemWidth\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [itemWidth=70]\n     * @returns {Number|dc.legend}\n     */\n    _legend.itemWidth = function (itemWidth) {\n        if (!arguments.length) {\n            return _itemWidth;\n        }\n        _itemWidth = itemWidth;\n        return _legend;\n    };\n\n    /**\n     * Turn automatic width for legend items on or off. If true, {@link dc.legend#itemWidth itemWidth} is ignored.\n     * This setting takes into account the {@link dc.legend#gap gap}.\n     * @method autoItemWidth\n     * @memberof dc.legend\n     * @instance\n     * @param  {Boolean} [autoItemWidth=false]\n     * @returns {Boolean|dc.legend}\n     */\n    _legend.autoItemWidth = function (autoItemWidth) {\n        if (!arguments.length) {\n            return _autoItemWidth;\n        }\n        _autoItemWidth = autoItemWidth;\n        return _legend;\n    };\n\n    /**\n     * Set or get the legend text function. The legend widget uses this function to render the legend\n     * text for each item. If no function is specified the legend widget will display the names\n     * associated with each group.\n     * @method legendText\n     * @memberof dc.legend\n     * @instance\n     * @param  {Function} [legendText]\n     * @returns {Function|dc.legend}\n     * @example\n     * // default legendText\n     * legend.legendText(dc.pluck('name'))\n     *\n     * // create numbered legend items\n     * chart.legend(dc.legend().legendText(function(d, i) { return i + '. ' + d.name; }))\n     *\n     * // create legend displaying group counts\n     * chart.legend(dc.legend().legendText(function(d) { return d.name + ': ' d.data; }))\n     **/\n    _legend.legendText = function (legendText) {\n        if (!arguments.length) {\n            return _legendText;\n        }\n        _legendText = legendText;\n        return _legend;\n    };\n\n    /**\n     * Maximum number of legend items to display\n     * @method maxItems\n     * @memberof dc.legend\n     * @instance\n     * @param  {Number} [maxItems]\n     * @return {dc.legend}\n     */\n    _legend.maxItems = function (maxItems) {\n        if (!arguments.length) {\n            return _maxItems;\n        }\n        _maxItems = dc.utils.isNumber(maxItems) ? maxItems : undefined;\n        return _legend;\n    };\n\n    return _legend;\n};\n\n/**\n * A scatter plot chart\n *\n * Examples:\n * - {@link http://dc-js.github.io/dc.js/examples/scatter.html Scatter Chart}\n * - {@link http://dc-js.github.io/dc.js/examples/multi-scatter.html Multi-Scatter Chart}\n * @class scatterPlot\n * @memberof dc\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a scatter plot under #chart-container1 element using the default global chart group\n * var chart1 = dc.scatterPlot('#chart-container1');\n * // create a scatter plot under #chart-container2 element using chart group A\n * var chart2 = dc.scatterPlot('#chart-container2', 'chartGroupA');\n * // create a sub-chart under a composite parent chart\n * var chart3 = dc.scatterPlot(compositeChart);\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.scatterPlot}\n */\ndc.scatterPlot = function (parent, chartGroup) {\n    var _chart = dc.coordinateGridMixin({});\n    var _symbol = d3.svg.symbol();\n\n    var _existenceAccessor = function (d) { return d.value; };\n\n    var originalKeyAccessor = _chart.keyAccessor();\n    _chart.keyAccessor(function (d) { return originalKeyAccessor(d)[0]; });\n    _chart.valueAccessor(function (d) { return originalKeyAccessor(d)[1]; });\n    _chart.colorAccessor(function () { return _chart._groupName; });\n\n    _chart.title(function (d) {\n        // this basically just counteracts the setting of its own key/value accessors\n        // see https://github.com/dc-js/dc.js/issues/702\n        return _chart.keyAccessor()(d) + ',' + _chart.valueAccessor()(d) + ': ' +\n            _chart.existenceAccessor()(d);\n    });\n\n    var _locator = function (d) {\n        return 'translate(' + _chart.x()(_chart.keyAccessor()(d)) + ',' +\n                              _chart.y()(_chart.valueAccessor()(d)) + ')';\n    };\n\n    var _highlightedSize = 7;\n    var _symbolSize = 5;\n    var _excludedSize = 3;\n    var _excludedColor = null;\n    var _excludedOpacity = 1.0;\n    var _emptySize = 0;\n    var _emptyOpacity = 0;\n    var _nonemptyOpacity = 1;\n    var _emptyColor = null;\n    var _filtered = [];\n\n    function elementSize (d, i) {\n        if (!_existenceAccessor(d)) {\n            return Math.pow(_emptySize, 2);\n        } else if (_filtered[i]) {\n            return Math.pow(_symbolSize, 2);\n        } else {\n            return Math.pow(_excludedSize, 2);\n        }\n    }\n    _symbol.size(elementSize);\n\n    dc.override(_chart, '_filter', function (filter) {\n        if (!arguments.length) {\n            return _chart.__filter();\n        }\n\n        return _chart.__filter(dc.filters.RangedTwoDimensionalFilter(filter));\n    });\n\n    _chart.plotData = function () {\n        var symbols = _chart.chartBodyG().selectAll('path.symbol')\n            .data(_chart.data());\n\n        symbols\n            .enter()\n        .append('path')\n            .attr('class', 'symbol')\n            .attr('opacity', 0)\n            .attr('fill', _chart.getColor)\n            .attr('transform', _locator);\n\n        symbols.call(renderTitles, _chart.data());\n\n        symbols.each(function (d, i) {\n            _filtered[i] = !_chart.filter() || _chart.filter().isFiltered([d.key[0], d.key[1]]);\n        });\n\n        dc.transition(symbols, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('opacity', function (d, i) {\n                if (!_existenceAccessor(d)) {\n                    return _emptyOpacity;\n                } else if (_filtered[i]) {\n                    return _nonemptyOpacity;\n                } else {\n                    return _chart.excludedOpacity();\n                }\n            })\n            .attr('fill', function (d, i) {\n                if (_emptyColor && !_existenceAccessor(d)) {\n                    return _emptyColor;\n                } else if (_chart.excludedColor() && !_filtered[i]) {\n                    return _chart.excludedColor();\n                } else {\n                    return _chart.getColor(d);\n                }\n            })\n            .attr('transform', _locator)\n            .attr('d', _symbol);\n\n        dc.transition(symbols.exit(), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('opacity', 0).remove();\n    };\n\n    function renderTitles (symbol, d) {\n        if (_chart.renderTitle()) {\n            symbol.selectAll('title').remove();\n            symbol.append('title').text(function (d) {\n                return _chart.title()(d);\n            });\n        }\n    }\n\n    /**\n     * Get or set the existence accessor.  If a point exists, it is drawn with\n     * {@link dc.scatterPlot#symbolSize symbolSize} radius and\n     * opacity 1; if it does not exist, it is drawn with\n     * {@link dc.scatterPlot#emptySize emptySize} radius and opacity 0. By default,\n     * the existence accessor checks if the reduced value is truthy.\n     * @method existenceAccessor\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link dc.scatterPlot#symbolSize symbolSize}\n     * @see {@link dc.scatterPlot#emptySize emptySize}\n     * @example\n     * // default accessor\n     * chart.existenceAccessor(function (d) { return d.value; });\n     * @param {Function} [accessor]\n     * @returns {Function|dc.scatterPlot}\n     */\n    _chart.existenceAccessor = function (accessor) {\n        if (!arguments.length) {\n            return _existenceAccessor;\n        }\n        _existenceAccessor = accessor;\n        return this;\n    };\n\n    /**\n     * Get or set the symbol type used for each point. By default the symbol is a circle.\n     * Type can be a constant or an accessor.\n     * @method symbol\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_type d3.svg.symbol.type}\n     * @example\n     * // Circle type\n     * chart.symbol('circle');\n     * // Square type\n     * chart.symbol('square');\n     * @param {String|Function} [type='circle']\n     * @returns {String|Function|dc.scatterPlot}\n     */\n    _chart.symbol = function (type) {\n        if (!arguments.length) {\n            return _symbol.type();\n        }\n        _symbol.type(type);\n        return _chart;\n    };\n\n    /**\n     * Get or set the symbol generator. By default `dc.scatterPlot` will use\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol d3.svg.symbol()}\n     * to generate symbols. `dc.scatterPlot` will set the\n     * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size size accessor}\n     * on the symbol generator.\n     * @method customSymbol\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol d3.svg.symbol}\n     * @see {@link https://stackoverflow.com/questions/25332120/create-additional-d3-js-symbols Create additional D3.js symbols}\n     * @param {String|Function} [customSymbol=d3.svg.symbol()]\n     * @returns {String|Function|dc.scatterPlot}\n     */\n    _chart.customSymbol = function (customSymbol) {\n        if (!arguments.length) {\n            return _symbol;\n        }\n        _symbol = customSymbol;\n        _symbol.size(elementSize);\n        return _chart;\n    };\n\n    /**\n     * Set or get radius for symbols.\n     * @method symbolSize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [symbolSize=3]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.symbolSize = function (symbolSize) {\n        if (!arguments.length) {\n            return _symbolSize;\n        }\n        _symbolSize = symbolSize;\n        return _chart;\n    };\n\n    /**\n     * Set or get radius for highlighted symbols.\n     * @method highlightedSize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [highlightedSize=5]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.highlightedSize = function (highlightedSize) {\n        if (!arguments.length) {\n            return _highlightedSize;\n        }\n        _highlightedSize = highlightedSize;\n        return _chart;\n    };\n\n    /**\n     * Set or get size for symbols excluded from this chart's filter. If null, no\n     * special size is applied for symbols based on their filter status.\n     * @method excludedSize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [excludedSize=null]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.excludedSize = function (excludedSize) {\n        if (!arguments.length) {\n            return _excludedSize;\n        }\n        _excludedSize = excludedSize;\n        return _chart;\n    };\n\n    /**\n     * Set or get color for symbols excluded from this chart's filter. If null, no\n     * special color is applied for symbols based on their filter status.\n     * @method excludedColor\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [excludedColor=null]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.excludedColor = function (excludedColor) {\n        if (!arguments.length) {\n            return _excludedColor;\n        }\n        _excludedColor = excludedColor;\n        return _chart;\n    };\n\n    /**\n     * Set or get opacity for symbols excluded from this chart's filter.\n     * @method excludedOpacity\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [excludedOpacity=1.0]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.excludedOpacity = function (excludedOpacity) {\n        if (!arguments.length) {\n            return _excludedOpacity;\n        }\n        _excludedOpacity = excludedOpacity;\n        return _chart;\n    };\n\n    /**\n     * Set or get radius for symbols when the group is empty.\n     * @method emptySize\n     * @memberof dc.scatterPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#symbol_size d3.svg.symbol.size}\n     * @param {Number} [emptySize=0]\n     * @returns {Number|dc.scatterPlot}\n     */\n    _chart.hiddenSize = _chart.emptySize = function (emptySize) {\n        if (!arguments.length) {\n            return _emptySize;\n        }\n        _emptySize = emptySize;\n        return _chart;\n    };\n\n    /**\n     * Set or get color for symbols when the group is empty. If null, just use the\n     * {@link dc.colorMixin#colors colorMixin.colors} color scale zero value.\n     * @name emptyColor\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {String} [emptyColor=null]\n     * @return {String}\n     * @return {dc.scatterPlot}/\n     */\n    _chart.emptyColor = function (emptyColor) {\n        if (!arguments.length) {\n            return _emptyColor;\n        }\n        _emptyColor = emptyColor;\n        return _chart;\n    };\n\n    /**\n     * Set or get opacity for symbols when the group is empty.\n     * @name emptyOpacity\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [emptyOpacity=0]\n     * @return {Number}\n     * @return {dc.scatterPlot}\n     */\n    _chart.emptyOpacity = function (emptyOpacity) {\n        if (!arguments.length) {\n            return _emptyOpacity;\n        }\n        _emptyOpacity = emptyOpacity;\n        return _chart;\n    };\n\n    /**\n     * Set or get opacity for symbols when the group is not empty.\n     * @name nonemptyOpacity\n     * @memberof dc.scatterPlot\n     * @instance\n     * @param {Number} [nonemptyOpacity=1]\n     * @return {Number}\n     * @return {dc.scatterPlot}\n     */\n    _chart.nonemptyOpacity = function (nonemptyOpacity) {\n        if (!arguments.length) {\n            return _emptyOpacity;\n        }\n        _nonemptyOpacity = nonemptyOpacity;\n        return _chart;\n    };\n\n    _chart.legendables = function () {\n        return [{chart: _chart, name: _chart._groupName, color: _chart.getColor()}];\n    };\n\n    _chart.legendHighlight = function (d) {\n        resizeSymbolsWhere(function (symbol) {\n            return symbol.attr('fill') === d.color;\n        }, _highlightedSize);\n        _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return d3.select(this).attr('fill') !== d.color;\n        }).classed('fadeout', true);\n    };\n\n    _chart.legendReset = function (d) {\n        resizeSymbolsWhere(function (symbol) {\n            return symbol.attr('fill') === d.color;\n        }, _symbolSize);\n        _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return d3.select(this).attr('fill') !== d.color;\n        }).classed('fadeout', false);\n    };\n\n    function resizeSymbolsWhere (condition, size) {\n        var symbols = _chart.chartBodyG().selectAll('.chart-body path.symbol').filter(function () {\n            return condition(d3.select(this));\n        });\n        var oldSize = _symbol.size();\n        _symbol.size(Math.pow(size, 2));\n        dc.transition(symbols, _chart.transitionDuration(), _chart.transitionDelay()).attr('d', _symbol);\n        _symbol.size(oldSize);\n    }\n\n    _chart.setHandlePaths = function () {\n        // no handle paths for poly-brushes\n    };\n\n    _chart.extendBrush = function () {\n        var extent = _chart.brush().extent();\n        if (_chart.round()) {\n            extent[0] = extent[0].map(_chart.round());\n            extent[1] = extent[1].map(_chart.round());\n\n            _chart.g().select('.brush')\n                .call(_chart.brush().extent(extent));\n        }\n        return extent;\n    };\n\n    _chart.brushIsEmpty = function (extent) {\n        return _chart.brush().empty() || !extent || extent[0][0] >= extent[1][0] || extent[0][1] >= extent[1][1];\n    };\n\n    _chart._brushing = function () {\n        var extent = _chart.extendBrush();\n\n        _chart.redrawBrush(_chart.g());\n\n        if (_chart.brushIsEmpty(extent)) {\n            dc.events.trigger(function () {\n                _chart.filter(null);\n                _chart.redrawGroup();\n            });\n\n        } else {\n            var ranged2DFilter = dc.filters.RangedTwoDimensionalFilter(extent);\n            dc.events.trigger(function () {\n                _chart.filter(null);\n                _chart.filter(ranged2DFilter);\n                _chart.redrawGroup();\n            }, dc.constants.EVENT_DELAY);\n\n        }\n    };\n\n    _chart.setBrushY = function (gBrush) {\n        gBrush.call(_chart.brush().y(_chart.y()));\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A display of a single numeric value.\n * Unlike other charts, you do not need to set a dimension. Instead a group object must be provided and\n * a valueAccessor that returns a single value.\n * @class numberDisplay\n * @memberof dc\n * @mixes dc.baseMixin\n * @example\n * // create a number display under #chart-container1 element using the default global chart group\n * var display1 = dc.numberDisplay('#chart-container1');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.numberDisplay}\n */\ndc.numberDisplay = function (parent, chartGroup) {\n    var SPAN_CLASS = 'number-display';\n    var _formatNumber = d3.format('.2s');\n    var _chart = dc.baseMixin({});\n    var _html = {one: '', some: '', none: ''};\n    var _lastValue;\n\n    // dimension not required\n    _chart._mandatoryAttributes(['group']);\n\n    // default to ordering by value, to emulate old group.top(1) behavior when multiple groups\n    _chart.ordering(function (kv) { return kv.value; });\n\n    /**\n     * Gets or sets an optional object specifying HTML templates to use depending on the number\n     * displayed.  The text `%number` will be replaced with the current value.\n     * - one: HTML template to use if the number is 1\n     * - zero: HTML template to use if the number is 0\n     * - some: HTML template to use otherwise\n     * @method html\n     * @memberof dc.numberDisplay\n     * @instance\n     * @example\n     * numberWidget.html({\n     *      one:'%number record',\n     *      some:'%number records',\n     *      none:'no records'})\n     * @param {{one:String, some:String, none:String}} [html={one: '', some: '', none: ''}]\n     * @returns {{one:String, some:String, none:String}|dc.numberDisplay}\n     */\n    _chart.html = function (html) {\n        if (!arguments.length) {\n            return _html;\n        }\n        if (html.none) {\n            _html.none = html.none;//if none available\n        } else if (html.one) {\n            _html.none = html.one;//if none not available use one\n        } else if (html.some) {\n            _html.none = html.some;//if none and one not available use some\n        }\n        if (html.one) {\n            _html.one = html.one;//if one available\n        } else if (html.some) {\n            _html.one = html.some;//if one not available use some\n        }\n        if (html.some) {\n            _html.some = html.some;//if some available\n        } else if (html.one) {\n            _html.some = html.one;//if some not available use one\n        }\n        return _chart;\n    };\n\n    /**\n     * Calculate and return the underlying value of the display.\n     * @method value\n     * @memberof dc.numberDisplay\n     * @instance\n     * @returns {Number}\n     */\n    _chart.value = function () {\n        return _chart.data();\n    };\n\n    function maxBin (all) {\n        if (!all.length) {\n            return null;\n        }\n        var sorted = _chart._computeOrderedGroups(all);\n        return sorted[sorted.length - 1];\n    }\n    _chart.data(function (group) {\n        var valObj = group.value ? group.value() : maxBin(group.all());\n        return _chart.valueAccessor()(valObj);\n    });\n\n    _chart.transitionDuration(250); // good default\n    _chart.transitionDelay(0);\n\n    _chart._doRender = function () {\n        var newValue = _chart.value(),\n            span = _chart.selectAll('.' + SPAN_CLASS);\n\n        if (span.empty()) {\n            span = span.data([0])\n                .enter()\n                .append('span')\n                .attr('class', SPAN_CLASS);\n        }\n\n        span.transition()\n            .duration(_chart.transitionDuration())\n            .delay(_chart.transitionDelay())\n            .ease('quad-out-in')\n            .tween('text', function () {\n                // [XA] don't try and interpolate from Infinity, else this breaks.\n                var interpStart = isFinite(_lastValue) ? _lastValue : 0;\n                var interp = d3.interpolateNumber(interpStart || 0, newValue);\n                _lastValue = newValue;\n                return function (t) {\n                    var html = null, num = _chart.formatNumber()(interp(t));\n                    if (newValue === 0 && (_html.none !== '')) {\n                        html = _html.none;\n                    } else if (newValue === 1 && (_html.one !== '')) {\n                        html = _html.one;\n                    } else if (_html.some !== '') {\n                        html = _html.some;\n                    }\n                    this.innerHTML = html ? html.replace('%number', num) : num;\n                };\n            });\n    };\n\n    _chart._doRedraw = function () {\n        return _chart._doRender();\n    };\n\n    /**\n     * Get or set a function to format the value for the display.\n     * @method formatNumber\n     * @memberof dc.numberDisplay\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Formatting.md d3.format}\n     * @param {Function} [formatter=d3.format('.2s')]\n     * @returns {Function|dc.numberDisplay}\n     */\n    _chart.formatNumber = function (formatter) {\n        if (!arguments.length) {\n            return _formatNumber;\n        }\n        _formatNumber = formatter;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * A heat map is matrix that represents the values of two dimensions of data using colors.\n * @class heatMap\n * @memberof dc\n * @mixes dc.colorMixin\n * @mixes dc.marginMixin\n * @mixes dc.baseMixin\n * @example\n * // create a heat map under #chart-container1 element using the default global chart group\n * var heatMap1 = dc.heatMap('#chart-container1');\n * // create a heat map under #chart-container2 element using chart group A\n * var heatMap2 = dc.heatMap('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.heatMap}\n */\ndc.heatMap = function (parent, chartGroup) {\n\n    var DEFAULT_BORDER_RADIUS = 6.75;\n\n    var _chartBody;\n\n    var _cols;\n    var _rows;\n    var _colOrdering = d3.ascending;\n    var _rowOrdering = d3.ascending;\n    var _colScale = d3.scale.ordinal();\n    var _rowScale = d3.scale.ordinal();\n\n    var _xBorderRadius = DEFAULT_BORDER_RADIUS;\n    var _yBorderRadius = DEFAULT_BORDER_RADIUS;\n\n    var _chart = dc.colorMixin(dc.marginMixin(dc.baseMixin({})));\n    _chart._mandatoryAttributes(['group']);\n    _chart.title(_chart.colorAccessor());\n\n    var _colsLabel = function (d) {\n        return d;\n    };\n    var _rowsLabel = function (d) {\n        return d;\n    };\n\n    /**\n     * Set or get the column label function. The chart class uses this function to render\n     * column labels on the X axis. It is passed the column name.\n     * @method colsLabel\n     * @memberof dc.heatMap\n     * @instance\n     * @example\n     * // the default label function just returns the name\n     * chart.colsLabel(function(d) { return d; });\n     * @param  {Function} [labelFunction=function(d) { return d; }]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.colsLabel = function (labelFunction) {\n        if (!arguments.length) {\n            return _colsLabel;\n        }\n        _colsLabel = labelFunction;\n        return _chart;\n    };\n\n    /**\n     * Set or get the row label function. The chart class uses this function to render\n     * row labels on the Y axis. It is passed the row name.\n     * @method rowsLabel\n     * @memberof dc.heatMap\n     * @instance\n     * @example\n     * // the default label function just returns the name\n     * chart.rowsLabel(function(d) { return d; });\n     * @param  {Function} [labelFunction=function(d) { return d; }]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.rowsLabel = function (labelFunction) {\n        if (!arguments.length) {\n            return _rowsLabel;\n        }\n        _rowsLabel = labelFunction;\n        return _chart;\n    };\n\n    var _xAxisOnClick = function (d) { filterAxis(0, d); };\n    var _yAxisOnClick = function (d) { filterAxis(1, d); };\n    var _boxOnClick = function (d) {\n        var filter = d.key;\n        dc.events.trigger(function () {\n            _chart.filter(filter);\n            _chart.redrawGroup();\n        });\n    };\n\n    function filterAxis (axis, value) {\n        var cellsOnAxis = _chart.selectAll('.box-group').filter(function (d) {\n            return d.key[axis] === value;\n        });\n        var unfilteredCellsOnAxis = cellsOnAxis.filter(function (d) {\n            return !_chart.hasFilter(d.key);\n        });\n        dc.events.trigger(function () {\n            var selection = unfilteredCellsOnAxis.empty() ? cellsOnAxis : unfilteredCellsOnAxis;\n            var filters = selection.data().map(function (kv) {\n                return dc.filters.TwoDimensionalFilter(kv.key);\n            });\n            _chart._filter([filters]);\n            _chart.redrawGroup();\n        });\n    }\n\n    dc.override(_chart, 'filter', function (filter) {\n        if (!arguments.length) {\n            return _chart._filter();\n        }\n\n        return _chart._filter(dc.filters.TwoDimensionalFilter(filter));\n    });\n\n    /**\n     * Gets or sets the values used to create the rows of the heatmap, as an array. By default, all\n     * the values will be fetched from the data using the value accessor.\n     * @method rows\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Array<String|Number>} [rows]\n     * @returns {Array<String|Number>|dc.heatMap}\n     */\n\n    _chart.rows = function (rows) {\n        if (!arguments.length) {\n            return _rows;\n        }\n        _rows = rows;\n        return _chart;\n    };\n\n    /**\n     #### .rowOrdering([orderFunction])\n     Get or set an accessor to order the rows.  Default is d3.ascending.\n     */\n    _chart.rowOrdering = function (_) {\n        if (!arguments.length) {\n            return _rowOrdering;\n        }\n        _rowOrdering = _;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the keys used to create the columns of the heatmap, as an array. By default, all\n     * the values will be fetched from the data using the key accessor.\n     * @method cols\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Array<String|Number>} [cols]\n     * @returns {Array<String|Number>|dc.heatMap}\n     */\n    _chart.cols = function (cols) {\n        if (!arguments.length) {\n            return _cols;\n        }\n        _cols = cols;\n        return _chart;\n    };\n\n    /**\n     #### .colOrdering([orderFunction])\n     Get or set an accessor to order the cols.  Default is ascending.\n     */\n    _chart.colOrdering = function (_) {\n        if (!arguments.length) {\n            return _colOrdering;\n        }\n        _colOrdering = _;\n        return _chart;\n    };\n\n    _chart._doRender = function () {\n        _chart.resetSvg();\n\n        _chartBody = _chart.svg()\n            .append('g')\n            .attr('class', 'heatmap')\n            .attr('transform', 'translate(' + _chart.margins().left + ',' + _chart.margins().top + ')');\n\n        return _chart._doRedraw();\n    };\n\n    _chart._doRedraw = function () {\n        var data = _chart.data(),\n            rows = _chart.rows() || data.map(_chart.valueAccessor()),\n            cols = _chart.cols() || data.map(_chart.keyAccessor());\n        if (_rowOrdering) {\n            rows = rows.sort(_rowOrdering);\n        }\n        if (_colOrdering) {\n            cols = cols.sort(_colOrdering);\n        }\n        rows = _rowScale.domain(rows);\n        cols = _colScale.domain(cols);\n\n        var rowCount = rows.domain().length,\n            colCount = cols.domain().length,\n            boxWidth = Math.floor(_chart.effectiveWidth() / colCount),\n            boxHeight = Math.floor(_chart.effectiveHeight() / rowCount);\n\n        cols.rangeRoundBands([0, _chart.effectiveWidth()]);\n        rows.rangeRoundBands([_chart.effectiveHeight(), 0]);\n\n        var boxes = _chartBody.selectAll('g.box-group').data(_chart.data(), function (d, i) {\n            return _chart.keyAccessor()(d, i) + '\\0' + _chart.valueAccessor()(d, i);\n        });\n        var gEnter = boxes.enter().append('g')\n            .attr('class', 'box-group');\n\n        gEnter.append('rect')\n            .attr('class', 'heat-box')\n            .attr('fill', 'white')\n            .on('click', _chart.boxOnClick());\n\n        if (_chart.renderTitle()) {\n            gEnter.append('title');\n            boxes.select('title').text(_chart.title());\n        }\n\n        dc.transition(boxes.select('rect'), _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('x', function (d, i) { return cols(_chart.keyAccessor()(d, i)); })\n            .attr('y', function (d, i) { return rows(_chart.valueAccessor()(d, i)); })\n            .attr('rx', _xBorderRadius)\n            .attr('ry', _yBorderRadius)\n            .attr('fill', _chart.getColor)\n            .attr('width', boxWidth)\n            .attr('height', boxHeight);\n\n        boxes.exit().remove();\n\n        var gCols = _chartBody.select('g.cols');\n        if (gCols.empty()) {\n            gCols = _chartBody.append('g').attr('class', 'cols axis');\n        }\n        var gColsText = gCols.selectAll('text').data(cols.domain());\n        gColsText.enter().append('text')\n              .attr('x', function (d) { return cols(d) + boxWidth / 2; })\n              .style('text-anchor', 'middle')\n              .attr('y', _chart.effectiveHeight())\n              .attr('dy', 12)\n              .on('click', _chart.xAxisOnClick())\n              .text(_chart.colsLabel());\n        dc.transition(gColsText, _chart.transitionDuration(), _chart.transitionDelay())\n               .text(_chart.colsLabel())\n               .attr('x', function (d) { return cols(d) + boxWidth / 2; })\n               .attr('y', _chart.effectiveHeight());\n        gColsText.exit().remove();\n        var gRows = _chartBody.select('g.rows');\n        if (gRows.empty()) {\n            gRows = _chartBody.append('g').attr('class', 'rows axis');\n        }\n        var gRowsText = gRows.selectAll('text').data(rows.domain());\n        gRowsText.enter().append('text')\n              .attr('dy', 6)\n              .style('text-anchor', 'end')\n              .attr('x', 0)\n              .attr('dx', -2)\n              .on('click', _chart.yAxisOnClick())\n              .text(_chart.rowsLabel());\n        dc.transition(gRowsText, _chart.transitionDuration(), _chart.transitionDelay())\n              .text(_chart.rowsLabel())\n              .attr('y', function (d) { return rows(d) + boxHeight / 2; });\n        gRowsText.exit().remove();\n\n        if (_chart.hasFilter()) {\n            _chart.selectAll('g.box-group').each(function (d) {\n                if (_chart.isSelectedNode(d)) {\n                    _chart.highlightSelected(this);\n                } else {\n                    _chart.fadeDeselected(this);\n                }\n            });\n        } else {\n            _chart.selectAll('g.box-group').each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the handler that fires when an individual cell is clicked in the heatmap.\n     * By default, filtering of the cell will be toggled.\n     * @method boxOnClick\n     * @memberof dc.heatMap\n     * @instance\n     * @example\n     * // default box on click handler\n     * chart.boxOnClick(function (d) {\n     *     var filter = d.key;\n     *     dc.events.trigger(function () {\n     *         _chart.filter(filter);\n     *         _chart.redrawGroup();\n     *     });\n     * });\n     * @param  {Function} [handler]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.boxOnClick = function (handler) {\n        if (!arguments.length) {\n            return _boxOnClick;\n        }\n        _boxOnClick = handler;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the handler that fires when a column tick is clicked in the x axis.\n     * By default, if any cells in the column are unselected, the whole column will be selected,\n     * otherwise the whole column will be unselected.\n     * @method xAxisOnClick\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Function} [handler]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.xAxisOnClick = function (handler) {\n        if (!arguments.length) {\n            return _xAxisOnClick;\n        }\n        _xAxisOnClick = handler;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the handler that fires when a row tick is clicked in the y axis.\n     * By default, if any cells in the row are unselected, the whole row will be selected,\n     * otherwise the whole row will be unselected.\n     * @method yAxisOnClick\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Function} [handler]\n     * @returns {Function|dc.heatMap}\n     */\n    _chart.yAxisOnClick = function (handler) {\n        if (!arguments.length) {\n            return _yAxisOnClick;\n        }\n        _yAxisOnClick = handler;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the X border radius.  Set to 0 to get full rectangles.\n     * @method xBorderRadius\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Number} [xBorderRadius=6.75]\n     * @returns {Number|dc.heatMap}\n     */\n    _chart.xBorderRadius = function (xBorderRadius) {\n        if (!arguments.length) {\n            return _xBorderRadius;\n        }\n        _xBorderRadius = xBorderRadius;\n        return _chart;\n    };\n\n    /**\n     * Gets or sets the Y border radius.  Set to 0 to get full rectangles.\n     * @method yBorderRadius\n     * @memberof dc.heatMap\n     * @instance\n     * @param  {Number} [yBorderRadius=6.75]\n     * @returns {Number|dc.heatMap}\n     */\n    _chart.yBorderRadius = function (yBorderRadius) {\n        if (!arguments.length) {\n            return _yBorderRadius;\n        }\n        _yBorderRadius = yBorderRadius;\n        return _chart;\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(d.key);\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n// https://github.com/d3/d3-plugins/blob/master/box/box.js\n(function () {\n\n    // Inspired by http://informationandvisualization.de/blog/box-plot\n    d3.box = function () {\n        var width = 1,\n            height = 1,\n            duration = 0,\n            delay = 0,\n            domain = null,\n            value = Number,\n            whiskers = boxWhiskers,\n            quartiles = boxQuartiles,\n            tickFormat = null;\n\n        // For each small multiple…\n        function box (g) {\n            g.each(function (d, i) {\n                d = d.map(value).sort(d3.ascending);\n                var g = d3.select(this),\n                    n = d.length,\n                    min = d[0],\n                    max = d[n - 1];\n\n                // Compute quartiles. Must return exactly 3 elements.\n                var quartileData = d.quartiles = quartiles(d);\n\n                // Compute whiskers. Must return exactly 2 elements, or null.\n                var whiskerIndices = whiskers && whiskers.call(this, d, i),\n                    whiskerData = whiskerIndices && whiskerIndices.map(function (i) { return d[i]; });\n\n                // Compute outliers. If no whiskers are specified, all data are 'outliers'.\n                // We compute the outliers as indices, so that we can join across transitions!\n                var outlierIndices = whiskerIndices ?\n                    d3.range(0, whiskerIndices[0]).concat(d3.range(whiskerIndices[1] + 1, n)) : d3.range(n);\n\n                // Compute the new x-scale.\n                var x1 = d3.scale.linear()\n                    .domain(domain && domain.call(this, d, i) || [min, max])\n                    .range([height, 0]);\n\n                // Retrieve the old x-scale, if this is an update.\n                var x0 = this.__chart__ || d3.scale.linear()\n                    .domain([0, Infinity])\n                    .range(x1.range());\n\n                // Stash the new scale.\n                this.__chart__ = x1;\n\n                // Note: the box, median, and box tick elements are fixed in number,\n                // so we only have to handle enter and update. In contrast, the outliers\n                // and other elements are variable, so we need to exit them! Variable\n                // elements also fade in and out.\n\n                // Update center line: the vertical line spanning the whiskers.\n                var center = g.selectAll('line.center')\n                    .data(whiskerData ? [whiskerData] : []);\n\n                center.enter().insert('line', 'rect')\n                    .attr('class', 'center')\n                    .attr('x1', width / 2)\n                    .attr('y1', function (d) { return x0(d[0]); })\n                    .attr('x2', width / 2)\n                    .attr('y2', function (d) { return x0(d[1]); })\n                    .style('opacity', 1e-6)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .style('opacity', 1)\n                    .attr('y1', function (d) { return x1(d[0]); })\n                    .attr('y2', function (d) { return x1(d[1]); });\n\n                center.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .style('opacity', 1)\n                    .attr('x1', width / 2)\n                    .attr('x2', width / 2)\n                    .attr('y1', function (d) { return x1(d[0]); })\n                    .attr('y2', function (d) { return x1(d[1]); });\n\n                center.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .style('opacity', 1e-6)\n                    .attr('y1', function (d) { return x1(d[0]); })\n                    .attr('y2', function (d) { return x1(d[1]); })\n                    .remove();\n\n                // Update innerquartile box.\n                var box = g.selectAll('rect.box')\n                    .data([quartileData]);\n\n                box.enter().append('rect')\n                    .attr('class', 'box')\n                    .attr('x', 0)\n                    .attr('y', function (d) { return x0(d[2]); })\n                    .attr('width', width)\n                    .attr('height', function (d) { return x0(d[0]) - x0(d[2]); })\n                  .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', function (d) { return x1(d[2]); })\n                    .attr('height', function (d) { return x1(d[0]) - x1(d[2]); });\n\n                box.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('width', width)\n                    .attr('y', function (d) { return x1(d[2]); })\n                    .attr('height', function (d) { return x1(d[0]) - x1(d[2]); });\n\n                // Update median line.\n                var medianLine = g.selectAll('line.median')\n                    .data([quartileData[1]]);\n\n                medianLine.enter().append('line')\n                    .attr('class', 'median')\n                    .attr('x1', 0)\n                    .attr('y1', x0)\n                    .attr('x2', width)\n                    .attr('y2', x0)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y1', x1)\n                    .attr('y2', x1);\n\n                medianLine.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('x1', 0)\n                    .attr('x2', width)\n                    .attr('y1', x1)\n                    .attr('y2', x1);\n\n                // Update whiskers.\n                var whisker = g.selectAll('line.whisker')\n                    .data(whiskerData || []);\n\n                whisker.enter().insert('line', 'circle, text')\n                    .attr('class', 'whisker')\n                    .attr('x1', 0)\n                    .attr('y1', x0)\n                    .attr('x2', width)\n                    .attr('y2', x0)\n                    .style('opacity', 1e-6)\n                  .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y1', x1)\n                    .attr('y2', x1)\n                    .style('opacity', 1);\n\n                whisker.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('x1', 0)\n                    .attr('x2', width)\n                    .attr('y1', x1)\n                    .attr('y2', x1)\n                    .style('opacity', 1);\n\n                whisker.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y1', x1)\n                    .attr('y2', x1)\n                    .style('opacity', 1e-6)\n                    .remove();\n\n                // Update outliers.\n                var outlier = g.selectAll('circle.outlier')\n                    .data(outlierIndices, Number);\n\n                outlier.enter().insert('circle', 'text')\n                    .attr('class', 'outlier')\n                    .attr('r', 5)\n                    .attr('cx', width / 2)\n                    .attr('cy', function (i) { return x0(d[i]); })\n                    .style('opacity', 1e-6)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('cy', function (i) { return x1(d[i]); })\n                    .style('opacity', 1);\n\n                outlier.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('cx', width / 2)\n                    .attr('cy', function (i) { return x1(d[i]); })\n                    .style('opacity', 1);\n\n                outlier.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('cy', function (i) { return x1(d[i]); })\n                    .style('opacity', 1e-6)\n                    .remove();\n\n                // Compute the tick format.\n                var format = tickFormat || x1.tickFormat(8);\n\n                // Update box ticks.\n                var boxTick = g.selectAll('text.box')\n                    .data(quartileData);\n\n                boxTick.enter().append('text')\n                    .attr('class', 'box')\n                    .attr('dy', '.3em')\n                    .attr('dx', function (d, i) { return i & 1 ? 6 : -6; })\n                    .attr('x', function (d, i) { return i & 1 ? width : 0; })\n                    .attr('y', x0)\n                    .attr('text-anchor', function (d, i) { return i & 1 ? 'start' : 'end'; })\n                    .text(format)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', x1);\n\n                boxTick.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .text(format)\n                    .attr('x', function (d, i) { return i & 1 ? width : 0; })\n                    .attr('y', x1);\n\n                // Update whisker ticks. These are handled separately from the box\n                // ticks because they may or may not exist, and we want don't want\n                // to join box ticks pre-transition with whisker ticks post-.\n                var whiskerTick = g.selectAll('text.whisker')\n                    .data(whiskerData || []);\n\n                whiskerTick.enter().append('text')\n                    .attr('class', 'whisker')\n                    .attr('dy', '.3em')\n                    .attr('dx', 6)\n                    .attr('x', width)\n                    .attr('y', x0)\n                    .text(format)\n                    .style('opacity', 1e-6)\n                    .transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', x1)\n                    .style('opacity', 1);\n\n                whiskerTick.transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .text(format)\n                    .attr('x', width)\n                    .attr('y', x1)\n                    .style('opacity', 1);\n\n                whiskerTick.exit().transition()\n                    .duration(duration)\n                    .delay(delay)\n                    .attr('y', x1)\n                    .style('opacity', 1e-6)\n                    .remove();\n            });\n            d3.timer.flush();\n        }\n\n        box.width = function (x) {\n            if (!arguments.length) {\n                return width;\n            }\n            width = x;\n            return box;\n        };\n\n        box.height = function (x) {\n            if (!arguments.length) {\n                return height;\n            }\n            height = x;\n            return box;\n        };\n\n        box.tickFormat = function (x) {\n            if (!arguments.length) {\n                return tickFormat;\n            }\n            tickFormat = x;\n            return box;\n        };\n\n        box.duration = function (x) {\n            if (!arguments.length) {\n                return duration;\n            }\n            duration = x;\n            return box;\n        };\n\n        box.domain = function (x) {\n            if (!arguments.length) {\n                return domain;\n            }\n            domain = x === null ? x : d3.functor(x);\n            return box;\n        };\n\n        box.value = function (x) {\n            if (!arguments.length) {\n                return value;\n            }\n            value = x;\n            return box;\n        };\n\n        box.whiskers = function (x) {\n            if (!arguments.length) {\n                return whiskers;\n            }\n            whiskers = x;\n            return box;\n        };\n\n        box.quartiles = function (x) {\n            if (!arguments.length) {\n                return quartiles;\n            }\n            quartiles = x;\n            return box;\n        };\n\n        return box;\n    };\n\n    function boxWhiskers (d) {\n        return [0, d.length - 1];\n    }\n\n    function boxQuartiles (d) {\n        return [\n            d3.quantile(d, 0.25),\n            d3.quantile(d, 0.5),\n            d3.quantile(d, 0.75)\n        ];\n    }\n\n})();\n\n\n/**\n * A box plot is a chart that depicts numerical data via their quartile ranges.\n *\n * Examples:\n * - {@link http://dc-js.github.io/dc.js/examples/box-plot-time.html Box plot time example}\n * - {@link http://dc-js.github.io/dc.js/examples/box-plot.html Box plot example}\n * @class boxPlot\n * @memberof dc\n * @mixes dc.coordinateGridMixin\n * @example\n * // create a box plot under #chart-container1 element using the default global chart group\n * var boxPlot1 = dc.boxPlot('#chart-container1');\n * // create a box plot under #chart-container2 element using chart group A\n * var boxPlot2 = dc.boxPlot('#chart-container2', 'chartGroupA');\n * @param {String|node|d3.selection} parent - Any valid\n * {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Selections.md#selecting-elements d3 single selector} specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this chart instance should be placed in.\n * Interaction with a chart will only trigger events and redraws within the chart's group.\n * @returns {dc.boxPlot}\n */\ndc.boxPlot = function (parent, chartGroup) {\n    var _chart = dc.coordinateGridMixin({});\n\n    // Returns a function to compute the interquartile range.\n    function DEFAULT_WHISKERS_IQR (k) {\n        return function (d) {\n            var q1 = d.quartiles[0],\n                q3 = d.quartiles[2],\n                iqr = (q3 - q1) * k,\n                i = -1,\n                j = d.length;\n            do { ++i; } while (d[i] < q1 - iqr);\n            do { --j; } while (d[j] > q3 + iqr);\n            return [i, j];\n        };\n    }\n\n    var _whiskerIqrFactor = 1.5;\n    var _whiskersIqr = DEFAULT_WHISKERS_IQR;\n    var _whiskers = _whiskersIqr(_whiskerIqrFactor);\n\n    var _box = d3.box();\n    var _tickFormat = null;\n\n    var _boxWidth = function (innerChartWidth, xUnits) {\n        if (_chart.isOrdinal()) {\n            return _chart.x().rangeBand();\n        } else {\n            return innerChartWidth / (1 + _chart.boxPadding()) / xUnits;\n        }\n    };\n\n    // default padding to handle min/max whisker text\n    _chart.yAxisPadding(12);\n\n    // default to ordinal\n    _chart.x(d3.scale.ordinal());\n    _chart.xUnits(dc.units.ordinal);\n\n    // valueAccessor should return an array of values that can be coerced into numbers\n    // or if data is overloaded for a static array of arrays, it should be `Number`.\n    // Empty arrays are not included.\n    _chart.data(function (group) {\n        return group.all().map(function (d) {\n            d.map = function (accessor) { return accessor.call(d, d); };\n            return d;\n        }).filter(function (d) {\n            var values = _chart.valueAccessor()(d);\n            return values.length !== 0;\n        });\n    });\n\n    /**\n     * Get or set the spacing between boxes as a fraction of box size. Valid values are within 0-1.\n     * See the {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3 docs}\n     * for a visual description of how the padding is applied.\n     * @method boxPadding\n     * @memberof dc.boxPlot\n     * @instance\n     * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Ordinal-Scales.md#ordinal_rangeBands d3.scale.ordinal.rangeBands}\n     * @param {Number} [padding=0.8]\n     * @returns {Number|dc.boxPlot}\n     */\n    _chart.boxPadding = _chart._rangeBandPadding;\n    _chart.boxPadding(0.8);\n\n    /**\n     * Get or set the outer padding on an ordinal box chart. This setting has no effect on non-ordinal charts\n     * or on charts with a custom {@link dc.boxPlot#boxWidth .boxWidth}. Will pad the width by\n     * `padding * barWidth` on each side of the chart.\n     * @method outerPadding\n     * @memberof dc.boxPlot\n     * @instance\n     * @param {Number} [padding=0.5]\n     * @returns {Number|dc.boxPlot}\n     */\n    _chart.outerPadding = _chart._outerRangeBandPadding;\n    _chart.outerPadding(0.5);\n\n    /**\n     * Get or set the numerical width of the boxplot box. The width may also be a function taking as\n     * parameters the chart width excluding the right and left margins, as well as the number of x\n     * units.\n     * @example\n     * // Using numerical parameter\n     * chart.boxWidth(10);\n     * // Using function\n     * chart.boxWidth((innerChartWidth, xUnits) { ... });\n     * @method boxWidth\n     * @memberof dc.boxPlot\n     * @instance\n     * @param {Number|Function} [boxWidth=0.5]\n     * @returns {Number|Function|dc.boxPlot}\n     */\n    _chart.boxWidth = function (boxWidth) {\n        if (!arguments.length) {\n            return _boxWidth;\n        }\n        _boxWidth = d3.functor(boxWidth);\n        return _chart;\n    };\n\n    var boxTransform = function (d, i) {\n        var xOffset = _chart.x()(_chart.keyAccessor()(d, i));\n        return 'translate(' + xOffset + ', 0)';\n    };\n\n    _chart._preprocessData = function () {\n        if (_chart.elasticX()) {\n            _chart.x().domain([]);\n        }\n    };\n\n    _chart.plotData = function () {\n        var _calculatedBoxWidth = _boxWidth(_chart.effectiveWidth(), _chart.xUnitCount());\n\n        _box.whiskers(_whiskers)\n            .width(_calculatedBoxWidth)\n            .height(_chart.effectiveHeight())\n            .value(_chart.valueAccessor())\n            .domain(_chart.y().domain())\n            .duration(_chart.transitionDuration())\n            .tickFormat(_tickFormat);\n\n        var boxesG = _chart.chartBodyG().selectAll('g.box').data(_chart.data(), _chart.keyAccessor());\n\n        renderBoxes(boxesG);\n        updateBoxes(boxesG);\n        removeBoxes(boxesG);\n\n        _chart.fadeDeselectedArea();\n    };\n\n    function renderBoxes (boxesG) {\n        var boxesGEnter = boxesG.enter().append('g');\n\n        boxesGEnter\n            .attr('class', 'box')\n            .attr('transform', boxTransform)\n            .call(_box)\n            .on('click', function (d) {\n                _chart.filter(_chart.keyAccessor()(d));\n                _chart.redrawGroup();\n            });\n    }\n\n    function updateBoxes (boxesG) {\n        dc.transition(boxesG, _chart.transitionDuration(), _chart.transitionDelay())\n            .attr('transform', boxTransform)\n            .call(_box)\n            .each(function () {\n                d3.select(this).select('rect.box').attr('fill', _chart.getColor);\n            });\n    }\n\n    function removeBoxes (boxesG) {\n        boxesG.exit().remove().call(_box);\n    }\n\n    _chart.fadeDeselectedArea = function () {\n        if (_chart.hasFilter()) {\n            if (_chart.isOrdinal()) {\n                _chart.g().selectAll('g.box').each(function (d) {\n                    if (_chart.isSelectedNode(d)) {\n                        _chart.highlightSelected(this);\n                    } else {\n                        _chart.fadeDeselected(this);\n                    }\n                });\n            } else {\n                var extent = _chart.brush().extent();\n                var start = extent[0];\n                var end = extent[1];\n                var keyAccessor = _chart.keyAccessor();\n                _chart.g().selectAll('g.box').each(function (d) {\n                    var key = keyAccessor(d);\n                    if (key < start || key >= end) {\n                        _chart.fadeDeselected(this);\n                    } else {\n                        _chart.highlightSelected(this);\n                    }\n                });\n            }\n        } else {\n            _chart.g().selectAll('g.box').each(function () {\n                _chart.resetHighlight(this);\n            });\n        }\n    };\n\n    _chart.isSelectedNode = function (d) {\n        return _chart.hasFilter(_chart.keyAccessor()(d));\n    };\n\n    _chart.yAxisMin = function () {\n        var min = d3.min(_chart.data(), function (e) {\n            return d3.min(_chart.valueAccessor()(e));\n        });\n        return dc.utils.subtract(min, _chart.yAxisPadding());\n    };\n\n    _chart.yAxisMax = function () {\n        var max = d3.max(_chart.data(), function (e) {\n            return d3.max(_chart.valueAccessor()(e));\n        });\n        return dc.utils.add(max, _chart.yAxisPadding());\n    };\n\n    /**\n     * Set the numerical format of the boxplot median, whiskers and quartile labels. Defaults to\n     * integer formatting.\n     * @example\n     * // format ticks to 2 decimal places\n     * chart.tickFormat(d3.format('.2f'));\n     * @method tickFormat\n     * @memberof dc.boxPlot\n     * @instance\n     * @param {Function} [tickFormat]\n     * @returns {Number|Function|dc.boxPlot}\n     */\n    _chart.tickFormat = function (tickFormat) {\n        if (!arguments.length) {\n            return _tickFormat;\n        }\n        _tickFormat = tickFormat;\n        return _chart;\n    };\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n/**\n * The select menu is a simple widget designed to filter a dimension by selecting an option from\n * an HTML `<select/>` menu. The menu can be optionally turned into a multiselect.\n * @class selectMenu\n * @memberof dc\n * @mixes dc.baseMixin\n * @example\n * // create a select menu under #select-container using the default global chart group\n * var select = dc.selectMenu('#select-container')\n *                .dimension(states)\n *                .group(stateGroup);\n * // the option text can be set via the title() function\n * // by default the option text is '`key`: `value`'\n * select.title(function (d){\n *     return 'STATE: ' + d.key;\n * })\n * @param {String|node|d3.selection|dc.compositeChart} parent - Any valid\n * [d3 single selector](https://github.com/mbostock/d3/wiki/Selections#selecting-elements) specifying\n * a dom block element such as a div; or a dom element or d3 selection.\n * @param {String} [chartGroup] - The name of the chart group this widget should be placed in.\n * Interaction with the widget will only trigger events and redraws within its group.\n * @returns {selectMenu}\n **/\ndc.selectMenu = function (parent, chartGroup) {\n    var SELECT_CSS_CLASS = 'dc-select-menu';\n    var OPTION_CSS_CLASS = 'dc-select-option';\n\n    var _chart = dc.baseMixin({});\n\n    var _select;\n    var _promptText = 'Select all';\n    var _multiple = false;\n    var _promptValue = null;\n    var _numberVisible = null;\n    var _order = function (a, b) {\n        return _chart.keyAccessor()(a) > _chart.keyAccessor()(b) ?\n             1 : _chart.keyAccessor()(b) > _chart.keyAccessor()(a) ?\n            -1 : 0;\n    };\n\n    var _filterDisplayed = function (d) {\n        return _chart.valueAccessor()(d) > 0;\n    };\n\n    _chart.data(function (group) {\n        return group.all().filter(_filterDisplayed);\n    });\n\n    _chart._doRender = function () {\n        _chart.select('select').remove();\n        _select = _chart.root().append('select')\n                        .classed(SELECT_CSS_CLASS, true);\n        _select.append('option').text(_promptText).attr('value', '');\n\n        _chart._doRedraw();\n        return _chart;\n    };\n\n    _chart._doRedraw = function () {\n        setAttributes();\n        renderOptions();\n        // select the option(s) corresponding to current filter(s)\n        if (_chart.hasFilter() && _multiple) {\n            _select.selectAll('option')\n                .property('selected', function (d) {\n                    return d && _chart.filters().indexOf(String(_chart.keyAccessor()(d))) >= 0;\n                });\n        } else if (_chart.hasFilter()) {\n            _select.property('value', _chart.filter());\n        } else {\n            _select.property('value', '');\n        }\n        return _chart;\n    };\n\n    function renderOptions () {\n        var options = _select.selectAll('option.' + OPTION_CSS_CLASS)\n          .data(_chart.data(), function (d) { return _chart.keyAccessor()(d); });\n\n        options.enter()\n              .append('option')\n              .classed(OPTION_CSS_CLASS, true)\n              .attr('value', function (d) { return _chart.keyAccessor()(d); });\n\n        options.text(_chart.title());\n        options.exit().remove();\n        _select.selectAll('option.' + OPTION_CSS_CLASS).sort(_order);\n\n        _select.on('change', onChange);\n        return options;\n    }\n\n    function onChange (d, i) {\n        var values;\n        var target = d3.event.target;\n        if (target.selectedOptions) {\n            var selectedOptions = Array.prototype.slice.call(target.selectedOptions);\n            values = selectedOptions.map(function (d) {\n                return d.value;\n            });\n        } else { // IE and other browsers do not support selectedOptions\n            // adapted from this polyfill: https://gist.github.com/brettz9/4212217\n            var options = [].slice.call(d3.event.target.options);\n            values = options.filter(function (option) {\n                return option.selected;\n            }).map(function (option) {\n                return option.value;\n            });\n        }\n        // console.log(values);\n        // check if only prompt option is selected\n        if (values.length === 1 && values[0] === '') {\n            values = _promptValue || null;\n        } else if (!_multiple && values.length === 1) {\n            values = values[0];\n        }\n        _chart.onChange(values);\n    }\n\n    _chart.onChange = function (val) {\n        if (val && _multiple) {\n            _chart.replaceFilter([val]);\n        } else if (val) {\n            _chart.replaceFilter(val);\n        } else {\n            _chart.filterAll();\n        }\n        dc.events.trigger(function () {\n            _chart.redrawGroup();\n        });\n    };\n\n    function setAttributes () {\n        if (_multiple) {\n            _select.attr('multiple', true);\n        } else {\n            _select.attr('multiple', null);\n        }\n        if (_numberVisible !== null) {\n            _select.attr('size', _numberVisible);\n        } else {\n            _select.attr('size', null);\n        }\n    }\n\n    /**\n     * Get or set the function that controls the ordering of option tags in the\n     * select menu. By default options are ordered by the group key in ascending\n     * order.\n     * @name order\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {Function} [order]\n     * @example\n     * // order by the group's value\n     * chart.order(function (a,b) {\n     *     return a.value > b.value ? 1 : b.value > a.value ? -1 : 0;\n     * });\n     **/\n    _chart.order = function (order) {\n        if (!arguments.length) {\n            return _order;\n        }\n        _order = order;\n        return _chart;\n    };\n\n    /**\n     * Get or set the text displayed in the options used to prompt selection.\n     * @name promptText\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {String} [promptText='Select all']\n     * @example\n     * chart.promptText('All states');\n     **/\n    _chart.promptText = function (_) {\n        if (!arguments.length) {\n            return _promptText;\n        }\n        _promptText = _;\n        return _chart;\n    };\n\n    /**\n     * Get or set the function that filters option tags prior to display. By default options\n     * with a value of < 1 are not displayed.\n     * @name filterDisplayed\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {function} [filterDisplayed]\n     * @example\n     * // display all options override the `filterDisplayed` function:\n     * chart.filterDisplayed(function () {\n     *     return true;\n     * });\n     **/\n    _chart.filterDisplayed = function (filterDisplayed) {\n        if (!arguments.length) {\n            return _filterDisplayed;\n        }\n        _filterDisplayed = filterDisplayed;\n        return _chart;\n    };\n\n    /**\n     * Controls the type of select menu. Setting it to true converts the underlying\n     * HTML tag into a multiple select.\n     * @name multiple\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {boolean} [multiple=false]\n     * @example\n     * chart.multiple(true);\n     **/\n    _chart.multiple = function (multiple) {\n        if (!arguments.length) {\n            return _multiple;\n        }\n        _multiple = multiple;\n\n        return _chart;\n    };\n\n    /**\n     * Controls the default value to be used for\n     * [dimension.filter](https://github.com/crossfilter/crossfilter/wiki/API-Reference#dimension_filter)\n     * when only the prompt value is selected. If `null` (the default), no filtering will occur when\n     * just the prompt is selected.\n     * @name promptValue\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {?*} [promptValue=null]\n     **/\n    _chart.promptValue = function (promptValue) {\n        if (!arguments.length) {\n            return _promptValue;\n        }\n        _promptValue = promptValue;\n\n        return _chart;\n    };\n\n    /**\n     * Controls the number of items to show in the select menu, when `.multiple()` is true. This\n     * controls the [`size` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#Attributes) of\n     * the `select` element. If `null` (the default), uses the browser's default height.\n     * @name numberItems\n     * @memberof dc.selectMenu\n     * @instance\n     * @param {?number} [numberVisible=null]\n     * @example\n     * chart.numberVisible(10);\n     **/\n    _chart.numberVisible = function (numberVisible) {\n        if (!arguments.length) {\n            return _numberVisible;\n        }\n        _numberVisible = numberVisible;\n\n        return _chart;\n    };\n\n    _chart.size = dc.logger.deprecate(_chart.numberVisible, 'selectMenu.size is ambiguous - use numberVisible instead');\n\n    return _chart.anchor(parent, chartGroup);\n};\n\n// Renamed functions\n\ndc.abstractBubbleChart = dc.bubbleMixin;\ndc.baseChart = dc.baseMixin;\ndc.capped = dc.capMixin;\ndc.colorChart = dc.colorMixin;\ndc.coordinateGridChart = dc.coordinateGridMixin;\ndc.marginable = dc.marginMixin;\ndc.stackableChart = dc.stackMixin;\n\n// Expose d3 and crossfilter, so that clients in browserify\n// case can obtain them if they need them.\ndc.d3 = d3;\ndc.crossfilter = crossfilter;\n\nreturn dc;}\n    if(typeof define === \"function\" && define.amd) {\n        define([\"d3\", \"crossfilter2\"], _dc);\n    } else if(typeof module === \"object\" && module.exports) {\n        var _d3 = require('d3');\n        var _crossfilter = require('crossfilter2');\n        // When using npm + browserify, 'crossfilter' is a function,\n        // since package.json specifies index.js as main function, and it\n        // does special handling. When using bower + browserify,\n        // there's no main in bower.json (in fact, there's no bower.json),\n        // so we need to fix it.\n        if (typeof _crossfilter !== \"function\") {\n            _crossfilter = _crossfilter.crossfilter;\n        }\n        module.exports = _dc(_d3, _crossfilter);\n    } else {\n        this.dc = _dc(d3, crossfilter);\n    }\n}\n)();\n\n//# sourceMappingURL=dc.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/dc/dc.js\n// module id = 270\n// module chunks = 0 1","!function() {\n  var d3 = {\n    version: \"3.5.17\"\n  };\n  var d3_arraySlice = [].slice, d3_array = function(list) {\n    return d3_arraySlice.call(list);\n  };\n  var d3_document = this.document;\n  function d3_documentElement(node) {\n    return node && (node.ownerDocument || node.document || node).documentElement;\n  }\n  function d3_window(node) {\n    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\n  }\n  if (d3_document) {\n    try {\n      d3_array(d3_document.documentElement.childNodes)[0].nodeType;\n    } catch (e) {\n      d3_array = function(list) {\n        var i = list.length, array = new Array(i);\n        while (i--) array[i] = list[i];\n        return array;\n      };\n    }\n  }\n  if (!Date.now) Date.now = function() {\n    return +new Date();\n  };\n  if (d3_document) {\n    try {\n      d3_document.createElement(\"DIV\").style.setProperty(\"opacity\", 0, \"\");\n    } catch (error) {\n      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\n      d3_element_prototype.setAttribute = function(name, value) {\n        d3_element_setAttribute.call(this, name, value + \"\");\n      };\n      d3_element_prototype.setAttributeNS = function(space, local, value) {\n        d3_element_setAttributeNS.call(this, space, local, value + \"\");\n      };\n      d3_style_prototype.setProperty = function(name, value, priority) {\n        d3_style_setProperty.call(this, name, value + \"\", priority);\n      };\n    }\n  }\n  d3.ascending = d3_ascending;\n  function d3_ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n  d3.descending = function(a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  };\n  d3.min = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n    }\n    return a;\n  };\n  d3.max = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n    }\n    return a;\n  };\n  d3.extent = function(array, f) {\n    var i = -1, n = array.length, a, b, c;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    }\n    return [ a, c ];\n  };\n  function d3_number(x) {\n    return x === null ? NaN : +x;\n  }\n  function d3_numeric(x) {\n    return !isNaN(x);\n  }\n  d3.sum = function(array, f) {\n    var s = 0, n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = +array[i])) s += a;\n    } else {\n      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\n    }\n    return s;\n  };\n  d3.mean = function(array, f) {\n    var s = 0, n = array.length, a, i = -1, j = n;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;\n    }\n    if (j) return s / j;\n  };\n  d3.quantile = function(values, p) {\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\n    return e ? v + e * (values[h] - v) : v;\n  };\n  d3.median = function(array, f) {\n    var numbers = [], n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\n    }\n    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\n  };\n  d3.variance = function(array, f) {\n    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\n    if (arguments.length === 1) {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(array[i]))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    } else {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    }\n    if (j > 1) return s / (j - 1);\n  };\n  d3.deviation = function() {\n    var v = d3.variance.apply(this, arguments);\n    return v ? Math.sqrt(v) : v;\n  };\n  function d3_bisector(compare) {\n    return {\n      left: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;\n        }\n        return lo;\n      },\n      right: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  var d3_bisect = d3_bisector(d3_ascending);\n  d3.bisectLeft = d3_bisect.left;\n  d3.bisect = d3.bisectRight = d3_bisect.right;\n  d3.bisector = function(f) {\n    return d3_bisector(f.length === 1 ? function(d, x) {\n      return d3_ascending(f(d), x);\n    } : f);\n  };\n  d3.shuffle = function(array, i0, i1) {\n    if ((m = arguments.length) < 3) {\n      i1 = array.length;\n      if (m < 2) i0 = 0;\n    }\n    var m = i1 - i0, t, i;\n    while (m) {\n      i = Math.random() * m-- | 0;\n      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\n    }\n    return array;\n  };\n  d3.permute = function(array, indexes) {\n    var i = indexes.length, permutes = new Array(i);\n    while (i--) permutes[i] = array[indexes[i]];\n    return permutes;\n  };\n  d3.pairs = function(array) {\n    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);\n    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];\n    return pairs;\n  };\n  d3.transpose = function(matrix) {\n    if (!(n = matrix.length)) return [];\n    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {\n      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {\n        row[j] = matrix[j][i];\n      }\n    }\n    return transpose;\n  };\n  function d3_transposeLength(d) {\n    return d.length;\n  }\n  d3.zip = function() {\n    return d3.transpose(arguments);\n  };\n  d3.keys = function(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  };\n  d3.values = function(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  };\n  d3.entries = function(map) {\n    var entries = [];\n    for (var key in map) entries.push({\n      key: key,\n      value: map[key]\n    });\n    return entries;\n  };\n  d3.merge = function(arrays) {\n    var n = arrays.length, m, i = -1, j = 0, merged, array;\n    while (++i < n) j += arrays[i].length;\n    merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  };\n  var abs = Math.abs;\n  d3.range = function(start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n    return range;\n  };\n  function d3_range_integerScale(x) {\n    var k = 1;\n    while (x * k % 1) k *= 10;\n    return k;\n  }\n  function d3_class(ctor, properties) {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  }\n  d3.map = function(object, f) {\n    var map = new d3_Map();\n    if (object instanceof d3_Map) {\n      object.forEach(function(key, value) {\n        map.set(key, value);\n      });\n    } else if (Array.isArray(object)) {\n      var i = -1, n = object.length, o;\n      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n    } else {\n      for (var key in object) map.set(key, object[key]);\n    }\n    return map;\n  };\n  function d3_Map() {\n    this._ = Object.create(null);\n  }\n  var d3_map_proto = \"__proto__\", d3_map_zero = \"\\x00\";\n  d3_class(d3_Map, {\n    has: d3_map_has,\n    get: function(key) {\n      return this._[d3_map_escape(key)];\n    },\n    set: function(key, value) {\n      return this._[d3_map_escape(key)] = value;\n    },\n    remove: d3_map_remove,\n    keys: d3_map_keys,\n    values: function() {\n      var values = [];\n      for (var key in this._) values.push(this._[key]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var key in this._) entries.push({\n        key: d3_map_unescape(key),\n        value: this._[key]\n      });\n      return entries;\n    },\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n    }\n  });\n  function d3_map_escape(key) {\n    return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n  }\n  function d3_map_unescape(key) {\n    return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n  }\n  function d3_map_has(key) {\n    return d3_map_escape(key) in this._;\n  }\n  function d3_map_remove(key) {\n    return (key = d3_map_escape(key)) in this._ && delete this._[key];\n  }\n  function d3_map_keys() {\n    var keys = [];\n    for (var key in this._) keys.push(d3_map_unescape(key));\n    return keys;\n  }\n  function d3_map_size() {\n    var size = 0;\n    for (var key in this._) ++size;\n    return size;\n  }\n  function d3_map_empty() {\n    for (var key in this._) return false;\n    return true;\n  }\n  d3.nest = function() {\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\n    function map(mapType, array, depth) {\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n          values.push(object);\n        } else {\n          valuesByKey.set(keyValue, [ object ]);\n        }\n      }\n      if (mapType) {\n        object = mapType();\n        setter = function(keyValue, values) {\n          object.set(keyValue, map(mapType, values, depth));\n        };\n      } else {\n        object = {};\n        setter = function(keyValue, values) {\n          object[keyValue] = map(mapType, values, depth);\n        };\n      }\n      valuesByKey.forEach(setter);\n      return object;\n    }\n    function entries(map, depth) {\n      if (depth >= keys.length) return map;\n      var array = [], sortKey = sortKeys[depth++];\n      map.forEach(function(key, keyMap) {\n        array.push({\n          key: key,\n          values: entries(keyMap, depth)\n        });\n      });\n      return sortKey ? array.sort(function(a, b) {\n        return sortKey(a.key, b.key);\n      }) : array;\n    }\n    nest.map = function(array, mapType) {\n      return map(mapType, array, 0);\n    };\n    nest.entries = function(array) {\n      return entries(map(d3.map, array, 0), 0);\n    };\n    nest.key = function(d) {\n      keys.push(d);\n      return nest;\n    };\n    nest.sortKeys = function(order) {\n      sortKeys[keys.length - 1] = order;\n      return nest;\n    };\n    nest.sortValues = function(order) {\n      sortValues = order;\n      return nest;\n    };\n    nest.rollup = function(f) {\n      rollup = f;\n      return nest;\n    };\n    return nest;\n  };\n  d3.set = function(array) {\n    var set = new d3_Set();\n    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\n    return set;\n  };\n  function d3_Set() {\n    this._ = Object.create(null);\n  }\n  d3_class(d3_Set, {\n    has: d3_map_has,\n    add: function(key) {\n      this._[d3_map_escape(key += \"\")] = true;\n      return key;\n    },\n    remove: d3_map_remove,\n    values: d3_map_keys,\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key));\n    }\n  });\n  d3.behavior = {};\n  function d3_identity(d) {\n    return d;\n  }\n  d3.rebind = function(target, source) {\n    var i = 1, n = arguments.length, method;\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n    return target;\n  };\n  function d3_rebind(target, source, method) {\n    return function() {\n      var value = method.apply(source, arguments);\n      return value === source ? target : value;\n    };\n  }\n  function d3_vendorSymbol(object, name) {\n    if (name in object) return name;\n    name = name.charAt(0).toUpperCase() + name.slice(1);\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n      var prefixName = d3_vendorPrefixes[i] + name;\n      if (prefixName in object) return prefixName;\n    }\n  }\n  var d3_vendorPrefixes = [ \"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\" ];\n  function d3_noop() {}\n  d3.dispatch = function() {\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    return dispatch;\n  };\n  function d3_dispatch() {}\n  d3_dispatch.prototype.on = function(type, listener) {\n    var i = type.indexOf(\".\"), name = \"\";\n    if (i >= 0) {\n      name = type.slice(i + 1);\n      type = type.slice(0, i);\n    }\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n    if (arguments.length === 2) {\n      if (listener == null) for (type in this) {\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\n      }\n      return this;\n    }\n  };\n  function d3_dispatch_event(dispatch) {\n    var listeners = [], listenerByName = new d3_Map();\n    function event() {\n      var z = listeners, i = -1, n = z.length, l;\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n      return dispatch;\n    }\n    event.on = function(name, listener) {\n      var l = listenerByName.get(name), i;\n      if (arguments.length < 2) return l && l.on;\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      }\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n    return event;\n  }\n  d3.event = null;\n  function d3_eventPreventDefault() {\n    d3.event.preventDefault();\n  }\n  function d3_eventSource() {\n    var e = d3.event, s;\n    while (s = e.sourceEvent) e = s;\n    return e;\n  }\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    dispatch.of = function(thiz, argumentz) {\n      return function(e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n    return dispatch;\n  }\n  d3.requote = function(s) {\n    return s.replace(d3_requote_re, \"\\\\$&\");\n  };\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  var d3_subclass = {}.__proto__ ? function(object, prototype) {\n    object.__proto__ = prototype;\n  } : function(object, prototype) {\n    for (var property in prototype) object[property] = prototype[property];\n  };\n  function d3_selection(groups) {\n    d3_subclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n  var d3_select = function(s, n) {\n    return n.querySelector(s);\n  }, d3_selectAll = function(s, n) {\n    return n.querySelectorAll(s);\n  }, d3_selectMatches = function(n, s) {\n    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n    d3_selectMatches = function(n, s) {\n      return d3_selectMatcher.call(n, s);\n    };\n    return d3_selectMatches(n, s);\n  };\n  if (typeof Sizzle === \"function\") {\n    d3_select = function(s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n    d3_selectAll = Sizzle;\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n  d3.selection = function() {\n    return d3.select(d3_document.documentElement);\n  };\n  var d3_selectionPrototype = d3.selection.prototype = [];\n  d3_selectionPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, group, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selector(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_select(selector, this);\n    };\n  }\n  d3_selectionPrototype.selectAll = function(selector) {\n    var subgroups = [], subgroup, node;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selectorAll(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_selectAll(selector, this);\n    };\n  }\n  var d3_nsXhtml = \"http://www.w3.org/1999/xhtml\";\n  var d3_nsPrefix = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: d3_nsXhtml,\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function(name) {\n      var i = name.indexOf(\":\"), prefix = name;\n      if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n  d3_selectionPrototype.attr = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      }\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_attr(name, value));\n  };\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\n    }\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\n    }\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, \" \");\n  }\n  d3_selectionPrototype.classed = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;\n        if (value = node.classList) {\n          while (++i < n) if (!value.contains(name[i])) return false;\n        } else {\n          value = node.getAttribute(\"class\");\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n        }\n        return true;\n      }\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_classed(name, value));\n  };\n  function d3_selection_classedRe(name) {\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n  }\n  function d3_selection_classes(name) {\n    return (name + \"\").trim().split(/^|\\s+/);\n  }\n  function d3_selection_classed(name, value) {\n    name = d3_selection_classes(name).map(d3_selection_classedName);\n    var n = name.length;\n    function classedConstant() {\n      var i = -1;\n      while (++i < n) name[i](this, value);\n    }\n    function classedFunction() {\n      var i = -1, x = value.apply(this, arguments);\n      while (++i < n) name[i](this, x);\n    }\n    return typeof value === \"function\" ? classedFunction : classedConstant;\n  }\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function(node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.getAttribute(\"class\") || \"\";\n      if (value) {\n        re.lastIndex = 0;\n        if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n      } else {\n        node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n      }\n    };\n  }\n  d3_selectionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n        return this;\n      }\n      if (n < 2) {\n        var node = this.node();\n        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n      }\n      priority = \"\";\n    }\n    return this.each(d3_selection_style(name, value, priority));\n  };\n  function d3_selection_style(name, value, priority) {\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\n    }\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n  }\n  d3_selectionPrototype.property = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") return this.node()[name];\n      for (value in name) this.each(d3_selection_property(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_property(name, value));\n  };\n  function d3_selection_property(name, value) {\n    function propertyNull() {\n      delete this[name];\n    }\n    function propertyConstant() {\n      this[name] = value;\n    }\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name]; else this[name] = x;\n    }\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n  }\n  d3_selectionPrototype.text = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.textContent = \"\";\n    } : function() {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n  d3_selectionPrototype.html = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.innerHTML = \"\";\n    } : function() {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n  d3_selectionPrototype.append = function(name) {\n    name = d3_selection_creator(name);\n    return this.select(function() {\n      return this.appendChild(name.apply(this, arguments));\n    });\n  };\n  function d3_selection_creator(name) {\n    function create() {\n      var document = this.ownerDocument, namespace = this.namespaceURI;\n      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);\n    }\n    function createNS() {\n      return this.ownerDocument.createElementNS(name.space, name.local);\n    }\n    return typeof name === \"function\" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\n  }\n  d3_selectionPrototype.insert = function(name, before) {\n    name = d3_selection_creator(name);\n    before = d3_selection_selector(before);\n    return this.select(function() {\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n    });\n  };\n  d3_selectionPrototype.remove = function() {\n    return this.each(d3_selectionRemove);\n  };\n  function d3_selectionRemove() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  }\n  d3_selectionPrototype.data = function(value, key) {\n    var i = -1, n = this.length, group, node;\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n      return value;\n    }\n    function bind(group, groupData) {\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\n      if (key) {\n        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;\n        for (i = -1; ++i < n; ) {\n          if (node = group[i]) {\n            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\n              exitNodes[i] = node;\n            } else {\n              nodeByKeyValue.set(keyValue, node);\n            }\n            keyValues[i] = keyValue;\n          }\n        }\n        for (i = -1; ++i < m; ) {\n          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          } else if (node !== true) {\n            updateNodes[i] = node;\n            node.__data__ = nodeData;\n          }\n          nodeByKeyValue.set(keyValue, true);\n        }\n        for (i = -1; ++i < n; ) {\n          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0; ) {\n          node = group[i];\n          nodeData = groupData[i];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n        }\n        for (;i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        }\n        for (;i < n; ++i) {\n          exitNodes[i] = group[i];\n        }\n      }\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\n    if (typeof value === \"function\") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n    update.enter = function() {\n      return enter;\n    };\n    update.exit = function() {\n      return exit;\n    };\n    return update;\n  };\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n  d3_selectionPrototype.datum = function(value) {\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n  };\n  d3_selectionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_filter(selector) {\n    return function() {\n      return d3_selectMatches(this, selector);\n    };\n  }\n  d3_selectionPrototype.order = function() {\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n    return this;\n  };\n  d3_selectionPrototype.sort = function(comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\n    return this.order();\n  };\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3_ascending;\n    return function(a, b) {\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n    };\n  }\n  d3_selectionPrototype.each = function(callback) {\n    return d3_selection_each(this, function(node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n    return groups;\n  }\n  d3_selectionPrototype.call = function(callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n  d3_selectionPrototype.empty = function() {\n    return !this.node();\n  };\n  d3_selectionPrototype.node = function() {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n    return null;\n  };\n  d3_selectionPrototype.size = function() {\n    var n = 0;\n    d3_selection_each(this, function() {\n      ++n;\n    });\n    return n;\n  };\n  function d3_selection_enter(selection) {\n    d3_subclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n  d3_selection_enterPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\n    for (var j = -1, m = this.length; ++j < m; ) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  d3_selection_enterPrototype.insert = function(name, before) {\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n    return d3_selectionPrototype.insert.call(this, name, before);\n  };\n  function d3_selection_enterInsertBefore(enter) {\n    var i0, j0;\n    return function(d, i, j) {\n      var group = enter[j].update, n = group.length, node;\n      if (j != j0) j0 = j, i0 = 0;\n      if (i >= i0) i0 = i + 1;\n      while (!(node = group[i0]) && ++i0 < n) ;\n      return node;\n    };\n  }\n  d3.select = function(node) {\n    var group;\n    if (typeof node === \"string\") {\n      group = [ d3_select(node, d3_document) ];\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = [ node ];\n      group.parentNode = d3_documentElement(node);\n    }\n    return d3_selection([ group ]);\n  };\n  d3.selectAll = function(nodes) {\n    var group;\n    if (typeof nodes === \"string\") {\n      group = d3_array(d3_selectAll(nodes, d3_document));\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = d3_array(nodes);\n      group.parentNode = null;\n    }\n    return d3_selection([ group ]);\n  };\n  d3_selectionPrototype.on = function(type, listener, capture) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof type !== \"string\") {\n        if (n < 2) listener = false;\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n        return this;\n      }\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n      capture = false;\n    }\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n  function d3_selection_on(type, listener, capture) {\n    var name = \"__on\" + type, i = type.indexOf(\".\"), wrap = d3_selection_onListener;\n    if (i > 0) type = type.slice(0, i);\n    var filter = d3_selection_onFilters.get(type);\n    if (filter) type = filter, wrap = d3_selection_onFilter;\n    function onRemove() {\n      var l = this[name];\n      if (l) {\n        this.removeEventListener(type, l, l.$);\n        delete this[name];\n      }\n    }\n    function onAdd() {\n      var l = wrap(listener, d3_array(arguments));\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = l, l.$ = capture);\n      l._ = listener;\n    }\n    function removeAll() {\n      var re = new RegExp(\"^__on([^.]+)\" + d3.requote(type) + \"$\"), match;\n      for (var name in this) {\n        if (match = name.match(re)) {\n          var l = this[name];\n          this.removeEventListener(match[1], l, l.$);\n          delete this[name];\n        }\n      }\n    }\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n  }\n  var d3_selection_onFilters = d3.map({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  });\n  if (d3_document) {\n    d3_selection_onFilters.forEach(function(k) {\n      if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n    });\n  }\n  function d3_selection_onListener(listener, argumentz) {\n    return function(e) {\n      var o = d3.event;\n      d3.event = e;\n      argumentz[0] = this.__data__;\n      try {\n        listener.apply(this, argumentz);\n      } finally {\n        d3.event = o;\n      }\n    };\n  }\n  function d3_selection_onFilter(listener, argumentz) {\n    var l = d3_selection_onListener(listener, argumentz);\n    return function(e) {\n      var target = this, related = e.relatedTarget;\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n        l.call(target, e);\n      }\n    };\n  }\n  var d3_event_dragSelect, d3_event_dragId = 0;\n  function d3_event_dragSuppress(node) {\n    var name = \".dragsuppress-\" + ++d3_event_dragId, click = \"click\" + name, w = d3.select(d3_window(node)).on(\"touchmove\" + name, d3_eventPreventDefault).on(\"dragstart\" + name, d3_eventPreventDefault).on(\"selectstart\" + name, d3_eventPreventDefault);\n    if (d3_event_dragSelect == null) {\n      d3_event_dragSelect = \"onselectstart\" in node ? false : d3_vendorSymbol(node.style, \"userSelect\");\n    }\n    if (d3_event_dragSelect) {\n      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];\n      style[d3_event_dragSelect] = \"none\";\n    }\n    return function(suppressClick) {\n      w.on(name, null);\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n      if (suppressClick) {\n        var off = function() {\n          w.on(click, null);\n        };\n        w.on(click, function() {\n          d3_eventPreventDefault();\n          off();\n        }, true);\n        setTimeout(off, 0);\n      }\n    };\n  }\n  d3.mouse = function(container) {\n    return d3_mousePoint(container, d3_eventSource());\n  };\n  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n  function d3_mousePoint(container, e) {\n    if (e.changedTouches) e = e.changedTouches[0];\n    var svg = container.ownerSVGElement || container;\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n      if (d3_mouse_bug44083 < 0) {\n        var window = d3_window(container);\n        if (window.scrollX || window.scrollY) {\n          svg = d3.select(\"body\").append(\"svg\").style({\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            margin: 0,\n            padding: 0,\n            border: \"none\"\n          }, \"important\");\n          var ctm = svg[0][0].getScreenCTM();\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\n          svg.remove();\n        }\n      }\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, \n      point.y = e.clientY;\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [ point.x, point.y ];\n    }\n    var rect = container.getBoundingClientRect();\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\n  }\n  d3.touch = function(container, touches, identifier) {\n    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\n    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\n      if ((touch = touches[i]).identifier === identifier) {\n        return d3_mousePoint(container, touch);\n      }\n    }\n  };\n  d3.behavior.drag = function() {\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, \"mousemove\", \"mouseup\"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, \"touchmove\", \"touchend\");\n    function drag() {\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", touchstart);\n    }\n    function dragstart(id, position, subject, move, end) {\n      return function() {\n        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = \".drag\" + (dragId == null ? \"\" : \"-\" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);\n        if (origin) {\n          dragOffset = origin.apply(that, arguments);\n          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\n        } else {\n          dragOffset = [ 0, 0 ];\n        }\n        dispatch({\n          type: \"dragstart\"\n        });\n        function moved() {\n          var position1 = position(parent, dragId), dx, dy;\n          if (!position1) return;\n          dx = position1[0] - position0[0];\n          dy = position1[1] - position0[1];\n          dragged |= dx | dy;\n          position0 = position1;\n          dispatch({\n            type: \"drag\",\n            x: position1[0] + dragOffset[0],\n            y: position1[1] + dragOffset[1],\n            dx: dx,\n            dy: dy\n          });\n        }\n        function ended() {\n          if (!position(parent, dragId)) return;\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\n          dragRestore(dragged);\n          dispatch({\n            type: \"dragend\"\n          });\n        }\n      };\n    }\n    drag.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n    return d3.rebind(drag, event, \"on\");\n  };\n  function d3_behavior_dragTouchId() {\n    return d3.event.changedTouches[0].identifier;\n  }\n  d3.touches = function(container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function(touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;\n  function d3_sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n  function d3_cross2d(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n  }\n  function d3_acos(x) {\n    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n  }\n  function d3_asin(x) {\n    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n  }\n  function d3_sinh(x) {\n    return ((x = Math.exp(x)) - 1 / x) / 2;\n  }\n  function d3_cosh(x) {\n    return ((x = Math.exp(x)) + 1 / x) / 2;\n  }\n  function d3_tanh(x) {\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n  }\n  function d3_haversin(x) {\n    return (x = Math.sin(x / 2)) * x;\n  }\n  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;\n  d3.interpolateZoom = function(p0, p1) {\n    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < ε2) {\n      S = Math.log(w1 / w0) / ρ;\n      i = function(t) {\n        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n      S = (r1 - r0) / ρ;\n      i = function(t) {\n        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));\n        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];\n      };\n    }\n    i.duration = S * 1e3;\n    return i;\n  };\n  d3.behavior.zoom = function() {\n    var view = {\n      x: 0,\n      y: 0,\n      k: 1\n    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = \"mousedown.zoom\", mousemove = \"mousemove.zoom\", mouseup = \"mouseup.zoom\", mousewheelTimer, touchstart = \"touchstart.zoom\", touchtime, event = d3_eventDispatch(zoom, \"zoomstart\", \"zoom\", \"zoomend\"), x0, x1, y0, y1;\n    if (!d3_behavior_zoomWheel) {\n      d3_behavior_zoomWheel = \"onwheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\n      }, \"wheel\") : \"onmousewheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return d3.event.wheelDelta;\n      }, \"mousewheel\") : (d3_behavior_zoomDelta = function() {\n        return -d3.event.detail;\n      }, \"MozMousePixelScroll\");\n    }\n    function zoom(g) {\n      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + \".zoom\", mousewheeled).on(\"dblclick.zoom\", dblclicked).on(touchstart, touchstarted);\n    }\n    zoom.event = function(g) {\n      g.each(function() {\n        var dispatch = event.of(this, arguments), view1 = view;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.zoom\", function() {\n            view = this.__chart__ || {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            zoomstarted(dispatch);\n          }).tween(\"zoom:zoom\", function() {\n            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);\n            return function(t) {\n              var l = i(t), k = dx / l[2];\n              this.__chart__ = view = {\n                x: cx - l[0] * k,\n                y: cy - l[1] * k,\n                k: k\n              };\n              zoomed(dispatch);\n            };\n          }).each(\"interrupt.zoom\", function() {\n            zoomended(dispatch);\n          }).each(\"end.zoom\", function() {\n            zoomended(dispatch);\n          });\n        } else {\n          this.__chart__ = view;\n          zoomstarted(dispatch);\n          zoomed(dispatch);\n          zoomended(dispatch);\n        }\n      });\n    };\n    zoom.translate = function(_) {\n      if (!arguments.length) return [ view.x, view.y ];\n      view = {\n        x: +_[0],\n        y: +_[1],\n        k: view.k\n      };\n      rescale();\n      return zoom;\n    };\n    zoom.scale = function(_) {\n      if (!arguments.length) return view.k;\n      view = {\n        x: view.x,\n        y: view.y,\n        k: null\n      };\n      scaleTo(+_);\n      rescale();\n      return zoom;\n    };\n    zoom.scaleExtent = function(_) {\n      if (!arguments.length) return scaleExtent;\n      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.center = function(_) {\n      if (!arguments.length) return center;\n      center = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.size = function(_) {\n      if (!arguments.length) return size;\n      size = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.duration = function(_) {\n      if (!arguments.length) return duration;\n      duration = +_;\n      return zoom;\n    };\n    zoom.x = function(z) {\n      if (!arguments.length) return x1;\n      x1 = z;\n      x0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    zoom.y = function(z) {\n      if (!arguments.length) return y1;\n      y1 = z;\n      y0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    function location(p) {\n      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];\n    }\n    function point(l) {\n      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\n    }\n    function scaleTo(s) {\n      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n    }\n    function translateTo(p, l) {\n      l = point(l);\n      view.x += p[0] - l[0];\n      view.y += p[1] - l[1];\n    }\n    function zoomTo(that, p, l, k) {\n      that.__chart__ = {\n        x: view.x,\n        y: view.y,\n        k: view.k\n      };\n      scaleTo(Math.pow(2, k));\n      translateTo(center0 = p, l);\n      that = d3.select(that);\n      if (duration > 0) that = that.transition().duration(duration);\n      that.call(zoom.event);\n    }\n    function rescale() {\n      if (x1) x1.domain(x0.range().map(function(x) {\n        return (x - view.x) / view.k;\n      }).map(x0.invert));\n      if (y1) y1.domain(y0.range().map(function(y) {\n        return (y - view.y) / view.k;\n      }).map(y0.invert));\n    }\n    function zoomstarted(dispatch) {\n      if (!zooming++) dispatch({\n        type: \"zoomstart\"\n      });\n    }\n    function zoomed(dispatch) {\n      rescale();\n      dispatch({\n        type: \"zoom\",\n        scale: view.k,\n        translate: [ view.x, view.y ]\n      });\n    }\n    function zoomended(dispatch) {\n      if (!--zooming) dispatch({\n        type: \"zoomend\"\n      }), center0 = null;\n    }\n    function mousedowned() {\n      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);\n      d3_selection_interrupt.call(that);\n      zoomstarted(dispatch);\n      function moved() {\n        dragged = 1;\n        translateTo(d3.mouse(that), location0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        subject.on(mousemove, null).on(mouseup, null);\n        dragRestore(dragged);\n        zoomended(dispatch);\n      }\n    }\n    function touchstarted() {\n      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = \".zoom-\" + d3.event.changedTouches[0].identifier, touchmove = \"touchmove\" + zoomName, touchend = \"touchend\" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);\n      started();\n      zoomstarted(dispatch);\n      subject.on(mousedown, null).on(touchstart, started);\n      function relocate() {\n        var touches = d3.touches(that);\n        scale0 = view.k;\n        touches.forEach(function(t) {\n          if (t.identifier in locations0) locations0[t.identifier] = location(t);\n        });\n        return touches;\n      }\n      function started() {\n        var target = d3.event.target;\n        d3.select(target).on(touchmove, moved).on(touchend, ended);\n        targets.push(target);\n        var changed = d3.event.changedTouches;\n        for (var i = 0, n = changed.length; i < n; ++i) {\n          locations0[changed[i].identifier] = null;\n        }\n        var touches = relocate(), now = Date.now();\n        if (touches.length === 1) {\n          if (now - touchtime < 500) {\n            var p = touches[0];\n            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\n            d3_eventPreventDefault();\n          }\n          touchtime = now;\n        } else if (touches.length > 1) {\n          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\n          distance0 = dx * dx + dy * dy;\n        }\n      }\n      function moved() {\n        var touches = d3.touches(that), p0, l0, p1, l1;\n        d3_selection_interrupt.call(that);\n        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\n          p1 = touches[i];\n          if (l1 = locations0[p1.identifier]) {\n            if (l0) break;\n            p0 = p1, l0 = l1;\n          }\n        }\n        if (l1) {\n          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);\n          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\n          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\n          scaleTo(scale1 * scale0);\n        }\n        touchtime = null;\n        translateTo(p0, l0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        if (d3.event.touches.length) {\n          var changed = d3.event.changedTouches;\n          for (var i = 0, n = changed.length; i < n; ++i) {\n            delete locations0[changed[i].identifier];\n          }\n          for (var identifier in locations0) {\n            return void relocate();\n          }\n        }\n        d3.selectAll(targets).on(zoomName, null);\n        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\n        dragRestore();\n        zoomended(dispatch);\n      }\n    }\n    function mousewheeled() {\n      var dispatch = event.of(this, arguments);\n      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), \n      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\n      mousewheelTimer = setTimeout(function() {\n        mousewheelTimer = null;\n        zoomended(dispatch);\n      }, 50);\n      d3_eventPreventDefault();\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\n      translateTo(center0, translate0);\n      zoomed(dispatch);\n    }\n    function dblclicked() {\n      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;\n      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\n    }\n    return d3.rebind(zoom, event, \"on\");\n  };\n  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\n  d3.color = d3_color;\n  function d3_color() {}\n  d3_color.prototype.toString = function() {\n    return this.rgb() + \"\";\n  };\n  d3.hsl = d3_hsl;\n  function d3_hsl(h, s, l) {\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n  }\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n  d3_hslPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, this.l / k);\n  };\n  d3_hslPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, k * this.l);\n  };\n  d3_hslPrototype.rgb = function() {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n    function v(h) {\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n  d3.hcl = d3_hcl;\n  function d3_hcl(h, c, l) {\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n  }\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n  d3_hclPrototype.brighter = function(k) {\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.darker = function(k) {\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.rgb = function() {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n  function d3_hcl_lab(h, c, l) {\n    if (isNaN(h)) h = 0;\n    if (isNaN(c)) c = 0;\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n  d3.lab = d3_lab;\n  function d3_lab(l, a, b) {\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n  }\n  var d3_lab_K = 18;\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\n  d3_labPrototype.brighter = function(k) {\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.darker = function(k) {\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.rgb = function() {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n  }\n  function d3_lab_hcl(l, a, b) {\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n  }\n  function d3_lab_xyz(x) {\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n  function d3_xyz_lab(x) {\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n  }\n  d3.rgb = d3_rgb;\n  function d3_rgb(r, g, b) {\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n  }\n  function d3_rgbNumber(value) {\n    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n  }\n  function d3_rgbString(value) {\n    return d3_rgbNumber(value) + \"\";\n  }\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n  d3_rgbPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    var r = this.r, g = this.g, b = this.b, i = 30;\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n  };\n  d3_rgbPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\n  };\n  d3_rgbPrototype.hsl = function() {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n  d3_rgbPrototype.toString = function() {\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n  function d3_rgb_hex(v) {\n    return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0, g = 0, b = 0, m1, m2, color;\n    m1 = /([a-z]+)\\((.*)\\)/.exec(format = format.toLowerCase());\n    if (m1) {\n      m2 = m1[2].split(\",\");\n      switch (m1[1]) {\n       case \"hsl\":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n       case \"rgb\":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n        }\n      }\n    }\n    if (color = d3_rgb_names.get(format)) {\n      return rgb(color.r, color.g, color.b);\n    }\n    if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n      if (format.length === 4) {\n        r = (color & 3840) >> 4;\n        r = r >> 4 | r;\n        g = color & 240;\n        g = g >> 4 | g;\n        b = color & 15;\n        b = b << 4 | b;\n      } else if (format.length === 7) {\n        r = (color & 16711680) >> 16;\n        g = (color & 65280) >> 8;\n        b = color & 255;\n      }\n    }\n    return rgb(r, g, b);\n  }\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      h = NaN;\n      s = l > 0 && l < 1 ? 0 : h;\n    }\n    return new d3_hsl(h, s, l);\n  }\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n  }\n  function d3_rgb_parseNumber(c) {\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n  }\n  var d3_rgb_names = d3.map({\n    aliceblue: 15792383,\n    antiquewhite: 16444375,\n    aqua: 65535,\n    aquamarine: 8388564,\n    azure: 15794175,\n    beige: 16119260,\n    bisque: 16770244,\n    black: 0,\n    blanchedalmond: 16772045,\n    blue: 255,\n    blueviolet: 9055202,\n    brown: 10824234,\n    burlywood: 14596231,\n    cadetblue: 6266528,\n    chartreuse: 8388352,\n    chocolate: 13789470,\n    coral: 16744272,\n    cornflowerblue: 6591981,\n    cornsilk: 16775388,\n    crimson: 14423100,\n    cyan: 65535,\n    darkblue: 139,\n    darkcyan: 35723,\n    darkgoldenrod: 12092939,\n    darkgray: 11119017,\n    darkgreen: 25600,\n    darkgrey: 11119017,\n    darkkhaki: 12433259,\n    darkmagenta: 9109643,\n    darkolivegreen: 5597999,\n    darkorange: 16747520,\n    darkorchid: 10040012,\n    darkred: 9109504,\n    darksalmon: 15308410,\n    darkseagreen: 9419919,\n    darkslateblue: 4734347,\n    darkslategray: 3100495,\n    darkslategrey: 3100495,\n    darkturquoise: 52945,\n    darkviolet: 9699539,\n    deeppink: 16716947,\n    deepskyblue: 49151,\n    dimgray: 6908265,\n    dimgrey: 6908265,\n    dodgerblue: 2003199,\n    firebrick: 11674146,\n    floralwhite: 16775920,\n    forestgreen: 2263842,\n    fuchsia: 16711935,\n    gainsboro: 14474460,\n    ghostwhite: 16316671,\n    gold: 16766720,\n    goldenrod: 14329120,\n    gray: 8421504,\n    green: 32768,\n    greenyellow: 11403055,\n    grey: 8421504,\n    honeydew: 15794160,\n    hotpink: 16738740,\n    indianred: 13458524,\n    indigo: 4915330,\n    ivory: 16777200,\n    khaki: 15787660,\n    lavender: 15132410,\n    lavenderblush: 16773365,\n    lawngreen: 8190976,\n    lemonchiffon: 16775885,\n    lightblue: 11393254,\n    lightcoral: 15761536,\n    lightcyan: 14745599,\n    lightgoldenrodyellow: 16448210,\n    lightgray: 13882323,\n    lightgreen: 9498256,\n    lightgrey: 13882323,\n    lightpink: 16758465,\n    lightsalmon: 16752762,\n    lightseagreen: 2142890,\n    lightskyblue: 8900346,\n    lightslategray: 7833753,\n    lightslategrey: 7833753,\n    lightsteelblue: 11584734,\n    lightyellow: 16777184,\n    lime: 65280,\n    limegreen: 3329330,\n    linen: 16445670,\n    magenta: 16711935,\n    maroon: 8388608,\n    mediumaquamarine: 6737322,\n    mediumblue: 205,\n    mediumorchid: 12211667,\n    mediumpurple: 9662683,\n    mediumseagreen: 3978097,\n    mediumslateblue: 8087790,\n    mediumspringgreen: 64154,\n    mediumturquoise: 4772300,\n    mediumvioletred: 13047173,\n    midnightblue: 1644912,\n    mintcream: 16121850,\n    mistyrose: 16770273,\n    moccasin: 16770229,\n    navajowhite: 16768685,\n    navy: 128,\n    oldlace: 16643558,\n    olive: 8421376,\n    olivedrab: 7048739,\n    orange: 16753920,\n    orangered: 16729344,\n    orchid: 14315734,\n    palegoldenrod: 15657130,\n    palegreen: 10025880,\n    paleturquoise: 11529966,\n    palevioletred: 14381203,\n    papayawhip: 16773077,\n    peachpuff: 16767673,\n    peru: 13468991,\n    pink: 16761035,\n    plum: 14524637,\n    powderblue: 11591910,\n    purple: 8388736,\n    rebeccapurple: 6697881,\n    red: 16711680,\n    rosybrown: 12357519,\n    royalblue: 4286945,\n    saddlebrown: 9127187,\n    salmon: 16416882,\n    sandybrown: 16032864,\n    seagreen: 3050327,\n    seashell: 16774638,\n    sienna: 10506797,\n    silver: 12632256,\n    skyblue: 8900331,\n    slateblue: 6970061,\n    slategray: 7372944,\n    slategrey: 7372944,\n    snow: 16775930,\n    springgreen: 65407,\n    steelblue: 4620980,\n    tan: 13808780,\n    teal: 32896,\n    thistle: 14204888,\n    tomato: 16737095,\n    turquoise: 4251856,\n    violet: 15631086,\n    wheat: 16113331,\n    white: 16777215,\n    whitesmoke: 16119285,\n    yellow: 16776960,\n    yellowgreen: 10145074\n  });\n  d3_rgb_names.forEach(function(key, value) {\n    d3_rgb_names.set(key, d3_rgbNumber(value));\n  });\n  function d3_functor(v) {\n    return typeof v === \"function\" ? v : function() {\n      return v;\n    };\n  }\n  d3.functor = d3_functor;\n  d3.xhr = d3_xhrType(d3_identity);\n  function d3_xhrType(response) {\n    return function(url, mimeType, callback) {\n      if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, \n      mimeType = null;\n      return d3_xhr(url, mimeType, response, callback);\n    };\n  }\n  function d3_xhr(url, mimeType, response, callback) {\n    var xhr = {}, dispatch = d3.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"), headers = {}, request = new XMLHttpRequest(), responseType = null;\n    if (this.XDomainRequest && !(\"withCredentials\" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\n      request.readyState > 3 && respond();\n    };\n    function respond() {\n      var status = request.status, result;\n      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n        try {\n          result = response.call(xhr, request);\n        } catch (e) {\n          dispatch.error.call(xhr, e);\n          return;\n        }\n        dispatch.load.call(xhr, result);\n      } else {\n        dispatch.error.call(xhr, request);\n      }\n    }\n    request.onprogress = function(event) {\n      var o = d3.event;\n      d3.event = event;\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n    xhr.header = function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name]; else headers[name] = value + \"\";\n      return xhr;\n    };\n    xhr.mimeType = function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return xhr;\n    };\n    xhr.responseType = function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return xhr;\n    };\n    xhr.response = function(value) {\n      response = value;\n      return xhr;\n    };\n    [ \"get\", \"post\" ].forEach(function(method) {\n      xhr[method] = function() {\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\n      };\n    });\n    xhr.send = function(method, data, callback) {\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (responseType != null) request.responseType = responseType;\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function(request) {\n        callback(null, request);\n      });\n      dispatch.beforesend.call(xhr, request);\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n    xhr.abort = function() {\n      request.abort();\n      return xhr;\n    };\n    d3.rebind(xhr, dispatch, \"on\");\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  }\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function(error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n  function d3_xhrHasResponse(request) {\n    var type = request.responseType;\n    return type && type !== \"text\" ? request.response : request.responseText;\n  }\n  d3.dsv = function(delimiter, mimeType) {\n    var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"), delimiterCode = delimiter.charCodeAt(0);\n    function dsv(url, row, callback) {\n      if (arguments.length < 3) callback = row, row = null;\n      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\n      xhr.row = function(_) {\n        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\n      };\n      return xhr;\n    }\n    function response(request) {\n      return dsv.parse(request.responseText);\n    }\n    function typedResponse(f) {\n      return function(request) {\n        return dsv.parse(request.responseText, f);\n      };\n    }\n    dsv.parse = function(text, f) {\n      var o;\n      return dsv.parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function(\"d\", \"return {\" + row.map(function(name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n        o = f ? function(row, i) {\n          return f(a(row), i);\n        } : a;\n      });\n    };\n    dsv.parseRows = function(text, f) {\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\n      function token() {\n        if (I >= N) return EOF;\n        if (eol) return eol = false, EOL;\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, '\"');\n        }\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n        return text.slice(j);\n      }\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n      return rows;\n    };\n    dsv.format = function(rows) {\n      if (Array.isArray(rows[0])) return dsv.formatRows(rows);\n      var fieldSet = new d3_Set(), fields = [];\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!fieldSet.has(field)) {\n            fields.push(fieldSet.add(field));\n          }\n        }\n      });\n      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    };\n    dsv.formatRows = function(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n    function formatValue(text) {\n      return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\n    }\n    return dsv;\n  };\n  d3.csv = d3.dsv(\",\", \"text/csv\");\n  d3.tsv = d3.dsv(\"\t\", \"text/tab-separated-values\");\n  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, \"requestAnimationFrame\")] || function(callback) {\n    setTimeout(callback, 17);\n  };\n  d3.timer = function() {\n    d3_timer.apply(this, arguments);\n  };\n  function d3_timer(callback, delay, then) {\n    var n = arguments.length;\n    if (n < 2) delay = 0;\n    if (n < 3) then = Date.now();\n    var time = then + delay, timer = {\n      c: callback,\n      t: time,\n      n: null\n    };\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\n    d3_timer_queueTail = timer;\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n    return timer;\n  }\n  function d3_timer_step() {\n    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n  d3.timer.flush = function() {\n    d3_timer_mark();\n    d3_timer_sweep();\n  };\n  function d3_timer_mark() {\n    var now = Date.now(), timer = d3_timer_queueHead;\n    while (timer) {\n      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\n      timer = timer.n;\n    }\n    return now;\n  }\n  function d3_timer_sweep() {\n    var t0, t1 = d3_timer_queueHead, time = Infinity;\n    while (t1) {\n      if (t1.c) {\n        if (t1.t < time) time = t1.t;\n        t1 = (t0 = t1).n;\n      } else {\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n      }\n    }\n    d3_timer_queueTail = t0;\n    return time;\n  }\n  function d3_format_precision(x, p) {\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n  }\n  d3.round = function(x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n  var d3_formatPrefixes = [ \"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\" ].map(d3_formatPrefix);\n  d3.formatPrefix = function(value, precision) {\n    var i = 0;\n    if (value = +value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n    }\n    return d3_formatPrefixes[8 + i / 3];\n  };\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function(d) {\n        return d / k;\n      } : function(d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n  function d3_locale_numberFormat(locale) {\n    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {\n      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\n      }\n      return t.reverse().join(locale_thousands);\n    } : d3_identity;\n    return function(specifier) {\n      var match = d3_format_re.exec(specifier), fill = match[1] || \" \", align = match[2] || \">\", sign = match[3] || \"-\", symbol = match[4] || \"\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = \"\", suffix = \"\", integer = false, exponent = true;\n      if (precision) precision = +precision.substring(1);\n      if (zfill || fill === \"0\" && align === \"=\") {\n        zfill = fill = \"0\";\n        align = \"=\";\n      }\n      switch (type) {\n       case \"n\":\n        comma = true;\n        type = \"g\";\n        break;\n\n       case \"%\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"f\";\n        break;\n\n       case \"p\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"r\";\n        break;\n\n       case \"b\":\n       case \"o\":\n       case \"x\":\n       case \"X\":\n        if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n\n       case \"c\":\n        exponent = false;\n\n       case \"d\":\n        integer = true;\n        precision = 0;\n        break;\n\n       case \"s\":\n        scale = -1;\n        type = \"r\";\n        break;\n      }\n      if (symbol === \"$\") prefix = locale_currency[0], suffix = locale_currency[1];\n      if (type == \"r\" && !precision) type = \"g\";\n      if (precision != null) {\n        if (type == \"g\") precision = Math.max(1, Math.min(21, precision)); else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n      }\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      var zcomma = zfill && comma;\n      return function(value) {\n        var fullSuffix = suffix;\n        if (integer && value % 1) return \"\";\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign === \"-\" ? \"\" : sign;\n        if (scale < 0) {\n          var unit = d3.formatPrefix(value, precision);\n          value = unit.scale(value);\n          fullSuffix = unit.symbol + suffix;\n        } else {\n          value *= scale;\n        }\n        value = type(value, precision);\n        var i = value.lastIndexOf(\".\"), before, after;\n        if (i < 0) {\n          var j = exponent ? value.lastIndexOf(\"e\") : -1;\n          if (j < 0) before = value, after = \"\"; else before = value.substring(0, j), after = value.substring(j);\n        } else {\n          before = value.substring(0, i);\n          after = locale_decimal + value.substring(i + 1);\n        }\n        if (!zfill && comma) before = formatGroup(before, Infinity);\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\n        negative += prefix;\n        value = before + after;\n        return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n      };\n    };\n  }\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n  var d3_format_types = d3.map({\n    b: function(x) {\n      return x.toString(2);\n    },\n    c: function(x) {\n      return String.fromCharCode(x);\n    },\n    o: function(x) {\n      return x.toString(8);\n    },\n    x: function(x) {\n      return x.toString(16);\n    },\n    X: function(x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function(x, p) {\n      return x.toPrecision(p);\n    },\n    e: function(x, p) {\n      return x.toExponential(p);\n    },\n    f: function(x, p) {\n      return x.toFixed(p);\n    },\n    r: function(x, p) {\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n    }\n  });\n  function d3_format_typeDefault(x) {\n    return x + \"\";\n  }\n  var d3_time = d3.time = {}, d3_date = Date;\n  function d3_date_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n  d3_date_utc.prototype = {\n    getDate: function() {\n      return this._.getUTCDate();\n    },\n    getDay: function() {\n      return this._.getUTCDay();\n    },\n    getFullYear: function() {\n      return this._.getUTCFullYear();\n    },\n    getHours: function() {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function() {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function() {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function() {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function() {\n      return this._.getUTCSeconds();\n    },\n    getTime: function() {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function() {\n      return 0;\n    },\n    valueOf: function() {\n      return this._.valueOf();\n    },\n    setDate: function() {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function() {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function() {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function() {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function() {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function() {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function() {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function() {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function() {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date), d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n    function ceil(date) {\n      step(date = local(new d3_date(date - 1)), 1);\n      return date;\n    }\n    function offset(date, k) {\n      step(date = new d3_date(+date), k);\n      return date;\n    }\n    function range(t0, t1, dt) {\n      var time = ceil(t0), times = [];\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\n      }\n      return times;\n    }\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_date = Date;\n      }\n    }\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n  function d3_time_interval_utc(method) {\n    return function(date, k) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_date = Date;\n      }\n    };\n  }\n  d3_time.year = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(date) {\n    return date.getFullYear();\n  });\n  d3_time.years = d3_time.year.range;\n  d3_time.years.utc = d3_time.year.utc.range;\n  d3_time.day = d3_time_interval(function(date) {\n    var day = new d3_date(2e3, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n  d3_time.days = d3_time.day.range;\n  d3_time.days.utc = d3_time.day.utc.range;\n  d3_time.dayOfYear = function(date) {\n    var year = d3_time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n  [ \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\" ].forEach(function(day, i) {\n    i = 7 - i;\n    var interval = d3_time[day] = d3_time_interval(function(date) {\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function(date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3_time[day + \"s\"] = interval.range;\n    d3_time[day + \"s\"].utc = interval.utc.range;\n    d3_time[day + \"OfYear\"] = function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3_time.week = d3_time.sunday;\n  d3_time.weeks = d3_time.sunday.range;\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\n  d3_time.weekOfYear = d3_time.sundayOfYear;\n  function d3_locale_timeFormat(locale) {\n    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\n    function d3_time_format(template) {\n      var n = template.length;\n      function format(date) {\n        var string = [], i = -1, j = 0, c, p, f;\n        while (++i < n) {\n          if (template.charCodeAt(i) === 37) {\n            string.push(template.slice(j, i));\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n        string.push(template.slice(j, i));\n        return string.join(\"\");\n      }\n      format.parse = function(string) {\n        var d = {\n          y: 1900,\n          m: 0,\n          d: 1,\n          H: 0,\n          M: 0,\n          S: 0,\n          L: 0,\n          Z: null\n        }, i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null;\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();\n        if (\"j\" in d) date.setFullYear(d.y, 0, d.j); else if (\"W\" in d || \"U\" in d) {\n          if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n          date.setFullYear(d.y, 0, 1);\n          date.setFullYear(d.y, 0, \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n        } else date.setFullYear(d.y, d.m, d.d);\n        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\n        return localZ ? date._ : date;\n      };\n      format.toString = function() {\n        return template;\n      };\n      return format;\n    }\n    function d3_time_parse(date, template, string, j) {\n      var c, p, t, i = 0, n = template.length, m = string.length;\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n        if (c === 37) {\n          t = template.charAt(i++);\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n      return j;\n    }\n    d3_time_format.utc = function(template) {\n      var local = d3_time_format(template);\n      function format(date) {\n        try {\n          d3_date = d3_date_utc;\n          var utc = new d3_date();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_date = Date;\n        }\n      }\n      format.parse = function(string) {\n        try {\n          d3_date = d3_date_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_date = Date;\n        }\n      };\n      format.toString = local.toString;\n      return format;\n    };\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n    locale_periods.forEach(function(p, i) {\n      d3_time_periodLookup.set(p.toLowerCase(), i);\n    });\n    var d3_time_formats = {\n      a: function(d) {\n        return locale_shortDays[d.getDay()];\n      },\n      A: function(d) {\n        return locale_days[d.getDay()];\n      },\n      b: function(d) {\n        return locale_shortMonths[d.getMonth()];\n      },\n      B: function(d) {\n        return locale_months[d.getMonth()];\n      },\n      c: d3_time_format(locale_dateTime),\n      d: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      e: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      H: function(d, p) {\n        return d3_time_formatPad(d.getHours(), p, 2);\n      },\n      I: function(d, p) {\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n      },\n      j: function(d, p) {\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n      },\n      L: function(d, p) {\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\n      },\n      m: function(d, p) {\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\n      },\n      M: function(d, p) {\n        return d3_time_formatPad(d.getMinutes(), p, 2);\n      },\n      p: function(d) {\n        return locale_periods[+(d.getHours() >= 12)];\n      },\n      S: function(d, p) {\n        return d3_time_formatPad(d.getSeconds(), p, 2);\n      },\n      U: function(d, p) {\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n      },\n      w: function(d) {\n        return d.getDay();\n      },\n      W: function(d, p) {\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n      },\n      x: d3_time_format(locale_date),\n      X: d3_time_format(locale_time),\n      y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n      },\n      Y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n      },\n      Z: d3_time_zone,\n      \"%\": function() {\n        return \"%\";\n      }\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      j: d3_time_parseDayOfYear,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      U: d3_time_parseWeekNumberSunday,\n      w: d3_time_parseWeekdayNumber,\n      W: d3_time_parseWeekNumberMonday,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n      Z: d3_time_parseZone,\n      \"%\": d3_time_parseLiteralPercent\n    };\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (date.p = n, i);\n    }\n    return d3_time_format;\n  }\n  var d3_time_formatPads = {\n    \"-\": \"\",\n    _: \" \",\n    \"0\": \"0\"\n  }, d3_time_numberRe = /^\\s*\\d+/, d3_time_percentRe = /^%/;\n  function d3_time_formatPad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\", string = (sign ? -value : value) + \"\", length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n  function d3_time_formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n  }\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(), i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n  function d3_time_parseWeekdayNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 1));\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberSunday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberMonday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 4));\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n  }\n  function d3_time_parseZone(date, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, \n    i + 5) : -1;\n  }\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2e3);\n  }\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n  }\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseDayOfYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(), zs = z > 0 ? \"-\" : \"+\", zh = abs(z) / 60 | 0, zm = abs(z) % 60;\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n  }\n  function d3_time_parseLiteralPercent(date, string, i) {\n    d3_time_percentRe.lastIndex = 0;\n    var n = d3_time_percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n  function d3_time_formatMulti(formats) {\n    var n = formats.length, i = -1;\n    while (++i < n) formats[i][0] = this(formats[i][0]);\n    return function(date) {\n      var i = 0, f = formats[i];\n      while (!f[1](date)) f = formats[++i];\n      return f[0](date);\n    };\n  }\n  d3.locale = function(locale) {\n    return {\n      numberFormat: d3_locale_numberFormat(locale),\n      timeFormat: d3_locale_timeFormat(locale)\n    };\n  };\n  var d3_locale_enUS = d3.locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [ 3 ],\n    currency: [ \"$\", \"\" ],\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [ \"AM\", \"PM\" ],\n    days: [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ],\n    shortDays: [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ],\n    months: [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\n    shortMonths: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]\n  });\n  d3.format = d3_locale_enUS.numberFormat;\n  d3.geo = {};\n  function d3_adder() {}\n  d3_adder.prototype = {\n    s: 0,\n    t: 0,\n    add: function(y) {\n      d3_adderSum(y, this.t, d3_adderTemp);\n      d3_adderSum(d3_adderTemp.s, this.s, this);\n      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\n    },\n    reset: function() {\n      this.s = this.t = 0;\n    },\n    valueOf: function() {\n      return this.s;\n    }\n  };\n  var d3_adderTemp = new d3_adder();\n  function d3_adderSum(a, b, o) {\n    var x = o.s = a + b, bv = x - a, av = x - bv;\n    o.t = a - av + (b - bv);\n  }\n  d3.geo.stream = function(object, listener) {\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n  var d3_geo_streamObjectType = {\n    Feature: function(feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function(object, listener) {\n      var features = object.features, i = -1, n = features.length;\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function(object, listener) {\n      listener.sphere();\n    },\n    Point: function(object, listener) {\n      object = object.coordinates;\n      listener.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\n    },\n    LineString: function(object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n    },\n    Polygon: function(object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n    },\n    GeometryCollection: function(object, listener) {\n      var geometries = object.geometries, i = -1, n = geometries.length;\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n    }\n  };\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1, n = coordinates.length - closed, coordinate;\n    listener.lineStart();\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n    listener.lineEnd();\n  }\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1, n = coordinates.length;\n    listener.polygonStart();\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n    listener.polygonEnd();\n  }\n  d3.geo.area = function(object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\n  var d3_geo_area = {\n    sphere: function() {\n      d3_geo_areaSum += 4 * π;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_areaRingSum.reset();\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function() {\n      var area = 2 * d3_geo_areaRingSum;\n      d3_geo_areaSum += area < 0 ? 4 * π + area : area;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n  function d3_geo_areaRingStart() {\n    var λ00, φ00, λ0, cosφ0, sinφ0;\n    d3_geo_area.point = function(λ, φ) {\n      d3_geo_area.point = nextPoint;\n      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), \n      sinφ0 = Math.sin(φ);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      φ = φ * d3_radians / 2 + π / 4;\n      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);\n      d3_geo_areaRingSum.add(Math.atan2(v, u));\n      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\n    }\n    d3_geo_area.lineEnd = function() {\n      nextPoint(λ00, φ00);\n    };\n  }\n  function d3_geo_cartesian(spherical) {\n    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);\n    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];\n  }\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function d3_geo_cartesianCross(a, b) {\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\n  }\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n  function d3_geo_cartesianScale(vector, k) {\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\n  }\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n  function d3_geo_spherical(cartesian) {\n    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];\n  }\n  function d3_geo_sphericalEqual(a, b) {\n    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;\n  }\n  d3.geo.bounds = function() {\n    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;\n    var bound = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        bound.point = ringPoint;\n        bound.lineStart = ringStart;\n        bound.lineEnd = ringEnd;\n        dλSum = 0;\n        d3_geo_area.polygonStart();\n      },\n      polygonEnd: function() {\n        d3_geo_area.polygonEnd();\n        bound.point = point;\n        bound.lineStart = lineStart;\n        bound.lineEnd = lineEnd;\n        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;\n        range[0] = λ0, range[1] = λ1;\n      }\n    };\n    function point(λ, φ) {\n      ranges.push(range = [ λ0 = λ, λ1 = λ ]);\n      if (φ < φ0) φ0 = φ;\n      if (φ > φ1) φ1 = φ;\n    }\n    function linePoint(λ, φ) {\n      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);\n      if (p0) {\n        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);\n        d3_geo_cartesianNormalize(inflection);\n        inflection = d3_geo_spherical(inflection);\n        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;\n        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = inflection[1] * d3_degrees;\n          if (φi > φ1) φ1 = φi;\n        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = -inflection[1] * d3_degrees;\n          if (φi < φ0) φ0 = φi;\n        } else {\n          if (φ < φ0) φ0 = φ;\n          if (φ > φ1) φ1 = φ;\n        }\n        if (antimeridian) {\n          if (λ < λ_) {\n            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n          } else {\n            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n          }\n        } else {\n          if (λ1 >= λ0) {\n            if (λ < λ0) λ0 = λ;\n            if (λ > λ1) λ1 = λ;\n          } else {\n            if (λ > λ_) {\n              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n            } else {\n              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n            }\n          }\n        }\n      } else {\n        point(λ, φ);\n      }\n      p0 = p, λ_ = λ;\n    }\n    function lineStart() {\n      bound.point = linePoint;\n    }\n    function lineEnd() {\n      range[0] = λ0, range[1] = λ1;\n      bound.point = point;\n      p0 = null;\n    }\n    function ringPoint(λ, φ) {\n      if (p0) {\n        var dλ = λ - λ_;\n        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;\n      } else λ__ = λ, φ__ = φ;\n      d3_geo_area.point(λ, φ);\n      linePoint(λ, φ);\n    }\n    function ringStart() {\n      d3_geo_area.lineStart();\n    }\n    function ringEnd() {\n      ringPoint(λ__, φ__);\n      d3_geo_area.lineEnd();\n      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);\n      range[0] = λ0, range[1] = λ1;\n      p0 = null;\n    }\n    function angle(λ0, λ1) {\n      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;\n    }\n    function compareRanges(a, b) {\n      return a[0] - b[0];\n    }\n    function withinRange(x, range) {\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    return function(feature) {\n      φ1 = λ1 = -(λ0 = φ0 = Infinity);\n      ranges = [];\n      d3.geo.stream(feature, bound);\n      var n = ranges.length;\n      if (n) {\n        ranges.sort(compareRanges);\n        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {\n          b = ranges[i];\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n          } else {\n            merged.push(a = b);\n          }\n        }\n        var best = -Infinity, dλ;\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n          b = merged[i];\n          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];\n        }\n      }\n      ranges = range = null;\n      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];\n    };\n  }();\n  d3.geo.centroid = function(object) {\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\n    if (m < ε2) {\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\n      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n      m = x * x + y * y + z * z;\n      if (m < ε2) return [ NaN, NaN ];\n    }\n    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];\n  };\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  };\n  function d3_geo_centroidPoint(λ, φ) {\n    λ *= d3_radians;\n    var cosφ = Math.cos(φ *= d3_radians);\n    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));\n  }\n  function d3_geo_centroidPointXYZ(x, y, z) {\n    ++d3_geo_centroidW0;\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n  }\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroid.point = nextPoint;\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  }\n  function d3_geo_centroidRingStart() {\n    var λ00, φ00, x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ00 = λ, φ00 = φ;\n      d3_geo_centroid.point = nextPoint;\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    d3_geo_centroid.lineEnd = function() {\n      nextPoint(λ00, φ00);\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n      d3_geo_centroid.point = d3_geo_centroidPoint;\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);\n      d3_geo_centroidX2 += v * cx;\n      d3_geo_centroidY2 += v * cy;\n      d3_geo_centroidZ2 += v * cz;\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function(x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n  function d3_true() {\n    return true;\n  }\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n    var subject = [], clip = [];\n    segments.forEach(function(segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n, p0 = segment[0], p1 = segment[n];\n      if (d3_geo_sphericalEqual(p0, p1)) {\n        listener.lineStart();\n        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\n        listener.lineEnd();\n        return;\n      }\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(compare);\n    d3_geo_clipPolygonLinkCircular(subject);\n    d3_geo_clipPolygonLinkCircular(clip);\n    if (!subject.length) return;\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n      clip[i].e = entry = !entry;\n    }\n    var start = subject[0], points, point;\n    while (1) {\n      var current = start, isSubject = true;\n      while (current.v) if ((current = current.n) === start) return;\n      points = current.z;\n      listener.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.n.x, 1, listener);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.p.x, -1, listener);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      listener.lineEnd();\n    }\n  }\n  function d3_geo_clipPolygonLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n, i = 0, a = array[0], b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n    return function(rotate, listener) {\n      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n          if (segments.length) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n          } else if (clipStartInside) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function() {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n      function point(λ, φ) {\n        var point = rotate(λ, φ);\n        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);\n      }\n      function pointLine(λ, φ) {\n        var point = rotate(λ, φ);\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      var segments;\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;\n      function pointRing(λ, φ) {\n        ring.push([ λ, φ ]);\n        var point = rotate(λ, φ);\n        ringListener.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          var n = segment.length - 1, i = -1, point;\n          if (n > 0) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            while (++i < n) listener.point((point = segment[i])[0], point[1]);\n            listener.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n      return clip;\n    };\n  }\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n  function d3_geo_clipBufferListener() {\n    var lines = [], line;\n    return {\n      lineStart: function() {\n        lines.push(line = []);\n      },\n      point: function(λ, φ) {\n        line.push([ λ, φ ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function() {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      },\n      rejoin: function() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      }\n    };\n  }\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);\n  }\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);\n  function d3_geo_clipAntimeridianLine(listener) {\n    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;\n    return {\n      lineStart: function() {\n        listener.lineStart();\n        clean = 1;\n      },\n      point: function(λ1, φ1) {\n        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);\n        if (abs(dλ - π) < ε) {\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          listener.point(λ1, φ0);\n          clean = 0;\n        } else if (sλ0 !== sλ1 && dλ >= π) {\n          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\n          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          clean = 0;\n        }\n        listener.point(λ0 = λ1, φ0 = φ1);\n        sλ0 = sλ1;\n      },\n      lineEnd: function() {\n        listener.lineEnd();\n        λ0 = φ0 = NaN;\n      },\n      clean: function() {\n        return 2 - clean;\n      }\n    };\n  }\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\n    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);\n    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\n  }\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var φ;\n    if (from == null) {\n      φ = direction * halfπ;\n      listener.point(-π, φ);\n      listener.point(0, φ);\n      listener.point(π, φ);\n      listener.point(π, 0);\n      listener.point(π, -φ);\n      listener.point(0, -φ);\n      listener.point(-π, -φ);\n      listener.point(-π, 0);\n      listener.point(-π, φ);\n    } else if (abs(from[0] - to[0]) > ε) {\n      var s = from[0] < to[0] ? π : -π;\n      φ = direction * s / 2;\n      listener.point(-s, φ);\n      listener.point(0, φ);\n      listener.point(s, φ);\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n  function d3_geo_pointInPolygon(point, polygon) {\n    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;\n    d3_geo_areaRingSum.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      var ring = polygon[i], m = ring.length;\n      if (!m) continue;\n      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;\n      while (true) {\n        if (j === m) j = 0;\n        point = ring[j];\n        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;\n        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));\n        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;\n        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n          d3_geo_cartesianNormalize(arc);\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n          d3_geo_cartesianNormalize(intersection);\n          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ dλ >= 0 ? 1 : -1;\n          }\n        }\n        if (!j++) break;\n        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;\n      }\n    }\n    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;\n  }\n  function d3_geo_clipCircle(radius) {\n    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);\n    function visible(λ, φ) {\n      return Math.cos(λ) * Math.cos(φ) > cr;\n    }\n    function clipLine(listener) {\n      var point0, c0, v0, v00, clean;\n      return {\n        lineStart: function() {\n          v00 = v0 = false;\n          clean = 1;\n        },\n        point: function(λ, φ) {\n          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ε;\n              point1[1] += ε;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            clean = 0;\n            if (v) {\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              clean = 0;\n              if (smallRadius) {\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n              } else {\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n            listener.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function() {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        clean: function() {\n          return clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B);\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      q = d3_geo_spherical(q);\n      if (!two) return q;\n      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;\n      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;\n      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;\n      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;\n      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n        d3_geo_cartesianAdd(q1, A);\n        return [ q, d3_geo_spherical(q1) ];\n      }\n    }\n    function code(λ, φ) {\n      var r = smallRadius ? radius : π - radius, code = 0;\n      if (λ < -r) code |= 1; else if (λ > r) code |= 2;\n      if (φ < -r) code |= 4; else if (φ > r) code |= 8;\n      return code;\n    }\n  }\n  function d3_geom_clipLine(x0, y0, x1, y1) {\n    return function(line) {\n      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n      r = x0 - ax;\n      if (!dx && r > 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dx > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = x1 - ax;\n      if (!dx && r < 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dx > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      r = y0 - ay;\n      if (!dy && r > 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dy > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = y1 - ay;\n      if (!dy && r < 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dy > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      if (t0 > 0) line.a = {\n        x: ax + t0 * dx,\n        y: ay + t0 * dy\n      };\n      if (t1 < 1) line.b = {\n        x: ax + t1 * dx,\n        y: ay + t1 * dy\n      };\n      return line;\n    };\n  }\n  var d3_geo_clipExtentMAX = 1e9;\n  d3.geo.clipExtent = function() {\n    var x0, y0, x1, y1, stream, clip, clipExtent = {\n      stream: function(output) {\n        if (stream) stream.valid = false;\n        stream = clip(output);\n        stream.valid = true;\n        return stream;\n      },\n      extent: function(_) {\n        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n        if (stream) stream.valid = false, stream = null;\n        return clipExtent;\n      }\n    };\n    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);\n  };\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\n    return function(listener) {\n      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          listener = bufferListener;\n          segments = [];\n          polygon = [];\n          clean = true;\n        },\n        polygonEnd: function() {\n          listener = listener_;\n          segments = d3.merge(segments);\n          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;\n          if (inside || visible) {\n            listener.polygonStart();\n            if (inside) {\n              listener.lineStart();\n              interpolate(null, null, 1, listener);\n              listener.lineEnd();\n            }\n            if (visible) {\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n            }\n            listener.polygonEnd();\n          }\n          segments = polygon = ring = null;\n        }\n      };\n      function insidePolygon(p) {\n        var wn = 0, n = polygon.length, y = p[1];\n        for (var i = 0; i < n; ++i) {\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n            b = v[j];\n            if (a[1] <= y) {\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n            } else {\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n            }\n            a = b;\n          }\n        }\n        return wn !== 0;\n      }\n      function interpolate(from, to, direction, listener) {\n        var a = 0, a1 = 0;\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n          do {\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n          } while ((a = (a + direction + 4) % 4) !== a1);\n        } else {\n          listener.point(to[0], to[1]);\n        }\n      }\n      function pointVisible(x, y) {\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n      }\n      function point(x, y) {\n        if (pointVisible(x, y)) listener.point(x, y);\n      }\n      var x__, y__, v__, x_, y_, v_, first, clean;\n      function lineStart() {\n        clip.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferListener.rejoin();\n          segments.push(bufferListener.buffer());\n        }\n        clip.point = point;\n        if (v_) listener.lineEnd();\n      }\n      function linePoint(x, y) {\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n        var v = pointVisible(x, y);\n        if (polygon) ring.push([ x, y ]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            listener.lineStart();\n            listener.point(x, y);\n          }\n        } else {\n          if (v && v_) listener.point(x, y); else {\n            var l = {\n              a: {\n                x: x_,\n                y: y_\n              },\n              b: {\n                x: x,\n                y: y\n              }\n            };\n            if (clipLine(l)) {\n              if (!v_) {\n                listener.lineStart();\n                listener.point(l.a.x, l.a.y);\n              }\n              listener.point(l.b.x, l.b.y);\n              if (!v) listener.lineEnd();\n              clean = false;\n            } else if (v) {\n              listener.lineStart();\n              listener.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clip;\n    };\n    function corner(p, direction) {\n      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compare(a, b) {\n      return comparePoints(a.x, b.x);\n    }\n    function comparePoints(a, b) {\n      var ca = corner(a, 1), cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n  }\n  function d3_geo_conic(projectAt) {\n    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);\n    p.parallels = function(_) {\n      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];\n      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);\n    };\n    return p;\n  }\n  function d3_geo_conicEqualArea(φ0, φ1) {\n    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;\n    function forward(λ, φ) {\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\n      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = ρ0 - y;\n      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEqualArea = function() {\n    return d3_geo_conic(d3_geo_conicEqualArea);\n  }).raw = d3_geo_conicEqualArea;\n  d3.geo.albers = function() {\n    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);\n  };\n  d3.geo.albersUsa = function() {\n    var lower48 = d3.geo.albers();\n    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);\n    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);\n    var point, pointStream = {\n      point: function(x, y) {\n        point = [ x, y ];\n      }\n    }, lower48Point, alaskaPoint, hawaiiPoint;\n    function albersUsa(coordinates) {\n      var x = coordinates[0], y = coordinates[1];\n      point = null;\n      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\n      return point;\n    }\n    albersUsa.invert = function(coordinates) {\n      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n    };\n    albersUsa.stream = function(stream) {\n      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);\n      return {\n        point: function(x, y) {\n          lower48Stream.point(x, y);\n          alaskaStream.point(x, y);\n          hawaiiStream.point(x, y);\n        },\n        sphere: function() {\n          lower48Stream.sphere();\n          alaskaStream.sphere();\n          hawaiiStream.sphere();\n        },\n        lineStart: function() {\n          lower48Stream.lineStart();\n          alaskaStream.lineStart();\n          hawaiiStream.lineStart();\n        },\n        lineEnd: function() {\n          lower48Stream.lineEnd();\n          alaskaStream.lineEnd();\n          hawaiiStream.lineEnd();\n        },\n        polygonStart: function() {\n          lower48Stream.polygonStart();\n          alaskaStream.polygonStart();\n          hawaiiStream.polygonStart();\n        },\n        polygonEnd: function() {\n          lower48Stream.polygonEnd();\n          alaskaStream.polygonEnd();\n          hawaiiStream.polygonEnd();\n        }\n      };\n    };\n    albersUsa.precision = function(_) {\n      if (!arguments.length) return lower48.precision();\n      lower48.precision(_);\n      alaska.precision(_);\n      hawaii.precision(_);\n      return albersUsa;\n    };\n    albersUsa.scale = function(_) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(_);\n      alaska.scale(_ * .35);\n      hawaii.scale(_);\n      return albersUsa.translate(lower48.translate());\n    };\n    albersUsa.translate = function(_) {\n      if (!arguments.length) return lower48.translate();\n      var k = lower48.scale(), x = +_[0], y = +_[1];\n      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;\n      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      return albersUsa;\n    };\n    return albersUsa.scale(1070);\n  };\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathArea.point = function(x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    }\n    d3_geo_pathArea.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n  var d3_geo_pathBounds = {\n    point: d3_geo_pathBoundsPoint,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_pathBoundsPoint(x, y) {\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n  }\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointCircle = d3_geo_pathBufferCircle(_);\n        return stream;\n      },\n      result: function() {\n        if (buffer.length) {\n          var result = buffer.join(\"\");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n    function point(x, y) {\n      buffer.push(\"M\", x, \",\", y, pointCircle);\n    }\n    function pointLineStart(x, y) {\n      buffer.push(\"M\", x, \",\", y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      buffer.push(\"L\", x, \",\", y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      buffer.push(\"Z\");\n    }\n    return stream;\n  }\n  function d3_geo_pathBufferCircle(radius) {\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius + \"z\";\n  }\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    polygonStart: function() {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n  function d3_geo_pathCentroidPoint(x, y) {\n    d3_geo_centroidX0 += x;\n    d3_geo_centroidY0 += y;\n    ++d3_geo_centroidZ0;\n  }\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n  }\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      z = y0 * x - x0 * y;\n      d3_geo_centroidX2 += z * (x0 + x);\n      d3_geo_centroidY2 += z * (y0 + y);\n      d3_geo_centroidZ2 += z * 3;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n    d3_geo_pathCentroid.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  function d3_geo_pathContext(context) {\n    var pointRadius = 4.5;\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n    function point(x, y) {\n      context.moveTo(x + pointRadius, y);\n      context.arc(x, y, pointRadius, 0, τ);\n    }\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      context.closePath();\n    }\n    return stream;\n  }\n  function d3_geo_resample(project) {\n    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;\n    function resample(stream) {\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\n    }\n    function resampleNone(stream) {\n      return d3_geo_transformPoint(stream, function(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      });\n    }\n    function resampleRecursive(stream) {\n      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          stream.polygonStart();\n          resample.lineStart = ringStart;\n        },\n        polygonEnd: function() {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(λ, φ) {\n        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resample.point = ringPoint;\n        resample.lineEnd = ringEnd;\n      }\n      function ringPoint(λ, φ) {\n        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resample.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\n        resample.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resample;\n    }\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n      if (d2 > 4 * δ2 && depth--) {\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    resample.precision = function(_) {\n      if (!arguments.length) return Math.sqrt(δ2);\n      maxDepth = (δ2 = _ * _) > 0 && 16;\n      return resample;\n    };\n    return resample;\n  }\n  d3.geo.path = function() {\n    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\n    function path(object) {\n      if (object) {\n        if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n        d3.geo.stream(object, cacheStream);\n      }\n      return contextStream.result();\n    }\n    path.area = function(object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n    path.centroid = function(object) {\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\n    };\n    path.bounds = function(object) {\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\n    };\n    path.projection = function(_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return reset();\n    };\n    path.context = function(_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n      return reset();\n    };\n    path.pointRadius = function(_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n      return path;\n    };\n    function reset() {\n      cacheStream = null;\n      return path;\n    }\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function(x, y) {\n      return project([ x * d3_degrees, y * d3_degrees ]);\n    });\n    return function(stream) {\n      return d3_geo_projectionRadians(resample(stream));\n    };\n  }\n  d3.geo.transform = function(methods) {\n    return {\n      stream: function(stream) {\n        var transform = new d3_geo_transform(stream);\n        for (var k in methods) transform[k] = methods[k];\n        return transform;\n      }\n    };\n  };\n  function d3_geo_transform(stream) {\n    this.stream = stream;\n  }\n  d3_geo_transform.prototype = {\n    point: function(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function() {\n      this.stream.sphere();\n    },\n    lineStart: function() {\n      this.stream.lineStart();\n    },\n    lineEnd: function() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function() {\n      this.stream.polygonEnd();\n    }\n  };\n  function d3_geo_transformPoint(stream, point) {\n    return {\n      point: point,\n      sphere: function() {\n        stream.sphere();\n      },\n      lineStart: function() {\n        stream.lineStart();\n      },\n      lineEnd: function() {\n        stream.lineEnd();\n      },\n      polygonStart: function() {\n        stream.polygonStart();\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n      }\n    };\n  }\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function() {\n      return project;\n    })();\n  }\n  function d3_geo_projectionMutator(projectAt) {\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\n      x = project(x, y);\n      return [ x[0] * k + δx, δy - x[1] * k ];\n    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [ point[0] * k + δx, δy - point[1] * k ];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\n    }\n    projection.stream = function(output) {\n      if (stream) stream.valid = false;\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n      stream.valid = true;\n      return stream;\n    };\n    projection.clipAngle = function(_) {\n      if (!arguments.length) return clipAngle;\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n      return invalidate();\n    };\n    projection.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n      return invalidate();\n    };\n    projection.scale = function(_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n    projection.translate = function(_) {\n      if (!arguments.length) return [ x, y ];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n    projection.center = function(_) {\n      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];\n      λ = _[0] % 360 * d3_radians;\n      φ = _[1] % 360 * d3_radians;\n      return reset();\n    };\n    projection.rotate = function(_) {\n      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];\n      δλ = _[0] % 360 * d3_radians;\n      δφ = _[1] % 360 * d3_radians;\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n    d3.rebind(projection, projectResample, \"precision\");\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\n      var center = project(λ, φ);\n      δx = x - center[0] * k;\n      δy = y + center[1] * k;\n      return invalidate();\n    }\n    function invalidate() {\n      if (stream) stream.valid = false, stream = null;\n      return projection;\n    }\n    return function() {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n  function d3_geo_projectionRadians(stream) {\n    return d3_geo_transformPoint(stream, function(x, y) {\n      stream.point(x * d3_radians, y * d3_radians);\n    });\n  }\n  function d3_geo_equirectangular(λ, φ) {\n    return [ λ, φ ];\n  }\n  (d3.geo.equirectangular = function() {\n    return d3_geo_projection(d3_geo_equirectangular);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n  d3.geo.rotation = function(rotate) {\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    }\n    forward.invert = function(coordinates) {\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    };\n    return forward;\n  };\n  function d3_geo_identityRotation(λ, φ) {\n    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n  }\n  d3_geo_identityRotation.invert = d3_geo_equirectangular;\n  function d3_geo_rotation(δλ, δφ, δγ) {\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;\n  }\n  function d3_geo_forwardRotationλ(δλ) {\n    return function(λ, φ) {\n      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n    };\n  }\n  function d3_geo_rotationλ(δλ) {\n    var rotation = d3_geo_forwardRotationλ(δλ);\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\n    return rotation;\n  }\n  function d3_geo_rotationφγ(δφ, δγ) {\n    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);\n    function rotation(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;\n      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];\n    }\n    rotation.invert = function(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;\n      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];\n    };\n    return rotation;\n  }\n  d3.geo.circle = function() {\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\n    function circle() {\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\n      interpolate(null, null, 1, {\n        point: function(x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: \"Polygon\",\n        coordinates: [ ring ]\n      };\n    }\n    circle.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n    circle.angle = function(x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n    circle.precision = function(_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n    return circle.angle(90);\n  };\n  function d3_geo_circleInterpolate(radius, precision) {\n    var cr = Math.cos(radius), sr = Math.sin(radius);\n    return function(from, to, direction, listener) {\n      var step = direction * precision;\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * τ;\n      } else {\n        from = radius + direction * τ;\n        to = radius - .5 * step;\n      }\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\n      }\n    };\n  }\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = d3_acos(-a[1]);\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\n  }\n  d3.geo.distance = function(a, b) {\n    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;\n    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);\n  };\n  d3.geo.graticule = function() {\n    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n    function graticule() {\n      return {\n        type: \"MultiLineString\",\n        coordinates: lines()\n      };\n    }\n    function lines() {\n      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {\n        return abs(x % DX) > ε;\n      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {\n        return abs(y % DY) > ε;\n      }).map(y));\n    }\n    graticule.lines = function() {\n      return lines().map(function(coordinates) {\n        return {\n          type: \"LineString\",\n          coordinates: coordinates\n        };\n      });\n    };\n    graticule.outline = function() {\n      return {\n        type: \"Polygon\",\n        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]\n      };\n    };\n    graticule.extent = function(_) {\n      if (!arguments.length) return graticule.minorExtent();\n      return graticule.majorExtent(_).minorExtent(_);\n    };\n    graticule.majorExtent = function(_) {\n      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];\n      X0 = +_[0][0], X1 = +_[1][0];\n      Y0 = +_[0][1], Y1 = +_[1][1];\n      if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.minorExtent = function(_) {\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n      x0 = +_[0][0], x1 = +_[1][0];\n      y0 = +_[0][1], y1 = +_[1][1];\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.step = function(_) {\n      if (!arguments.length) return graticule.minorStep();\n      return graticule.majorStep(_).minorStep(_);\n    };\n    graticule.majorStep = function(_) {\n      if (!arguments.length) return [ DX, DY ];\n      DX = +_[0], DY = +_[1];\n      return graticule;\n    };\n    graticule.minorStep = function(_) {\n      if (!arguments.length) return [ dx, dy ];\n      dx = +_[0], dy = +_[1];\n      return graticule;\n    };\n    graticule.precision = function(_) {\n      if (!arguments.length) return precision;\n      precision = +_;\n      x = d3_geo_graticuleX(y0, y1, 90);\n      y = d3_geo_graticuleY(x0, x1, precision);\n      X = d3_geo_graticuleX(Y0, Y1, 90);\n      Y = d3_geo_graticuleY(X0, X1, precision);\n      return graticule;\n    };\n    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);\n  };\n  function d3_geo_graticuleX(y0, y1, dy) {\n    var y = d3.range(y0, y1 - ε, dy).concat(y1);\n    return function(x) {\n      return y.map(function(y) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_geo_graticuleY(x0, x1, dx) {\n    var x = d3.range(x0, x1 - ε, dx).concat(x1);\n    return function(y) {\n      return x.map(function(x) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_source(d) {\n    return d.source;\n  }\n  function d3_target(d) {\n    return d.target;\n  }\n  d3.geo.greatArc = function() {\n    var source = d3_source, source_, target = d3_target, target_;\n    function greatArc() {\n      return {\n        type: \"LineString\",\n        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]\n      };\n    }\n    greatArc.distance = function() {\n      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\n    };\n    greatArc.source = function(_) {\n      if (!arguments.length) return source;\n      source = _, source_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.target = function(_) {\n      if (!arguments.length) return target;\n      target = _, target_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.precision = function() {\n      return arguments.length ? greatArc : 0;\n    };\n    return greatArc;\n  };\n  d3.geo.interpolate = function(source, target) {\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n  };\n  function d3_geo_interpolate(x0, y0, x1, y1) {\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);\n    var interpolate = d ? function(t) {\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];\n    } : function() {\n      return [ x0 * d3_degrees, y0 * d3_degrees ];\n    };\n    interpolate.distance = d;\n    return interpolate;\n  }\n  d3.geo.length = function(object) {\n    d3_geo_lengthSum = 0;\n    d3.geo.stream(object, d3_geo_length);\n    return d3_geo_lengthSum;\n  };\n  var d3_geo_lengthSum;\n  var d3_geo_length = {\n    sphere: d3_noop,\n    point: d3_noop,\n    lineStart: d3_geo_lengthLineStart,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_lengthLineStart() {\n    var λ0, sinφ0, cosφ0;\n    d3_geo_length.point = function(λ, φ) {\n      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);\n      d3_geo_length.point = nextPoint;\n    };\n    d3_geo_length.lineEnd = function() {\n      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\n    };\n    function nextPoint(λ, φ) {\n      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);\n      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);\n      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;\n    }\n  }\n  function d3_geo_azimuthal(scale, angle) {\n    function azimuthal(λ, φ) {\n      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);\n      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];\n    }\n    azimuthal.invert = function(x, y) {\n      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);\n      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];\n    };\n    return azimuthal;\n  }\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {\n    return Math.sqrt(2 / (1 + cosλcosφ));\n  }, function(ρ) {\n    return 2 * Math.asin(ρ / 2);\n  });\n  (d3.geo.azimuthalEqualArea = function() {\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\n  }).raw = d3_geo_azimuthalEqualArea;\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {\n    var c = Math.acos(cosλcosφ);\n    return c && c / Math.sin(c);\n  }, d3_identity);\n  (d3.geo.azimuthalEquidistant = function() {\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\n  }).raw = d3_geo_azimuthalEquidistant;\n  function d3_geo_conicConformal(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), t = function(φ) {\n      return Math.tan(π / 4 + φ / 2);\n    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;\n    if (!n) return d3_geo_mercator;\n    function forward(λ, φ) {\n      if (F > 0) {\n        if (φ < -halfπ + ε) φ = -halfπ + ε;\n      } else {\n        if (φ > halfπ - ε) φ = halfπ - ε;\n      }\n      var ρ = F / Math.pow(t(φ), n);\n      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);\n      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];\n    };\n    return forward;\n  }\n  (d3.geo.conicConformal = function() {\n    return d3_geo_conic(d3_geo_conicConformal);\n  }).raw = d3_geo_conicConformal;\n  function d3_geo_conicEquidistant(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;\n    if (abs(n) < ε) return d3_geo_equirectangular;\n    function forward(λ, φ) {\n      var ρ = G - φ;\n      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = G - y;\n      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEquidistant = function() {\n    return d3_geo_conic(d3_geo_conicEquidistant);\n  }).raw = d3_geo_conicEquidistant;\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / cosλcosφ;\n  }, Math.atan);\n  (d3.geo.gnomonic = function() {\n    return d3_geo_projection(d3_geo_gnomonic);\n  }).raw = d3_geo_gnomonic;\n  function d3_geo_mercator(λ, φ) {\n    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];\n  }\n  d3_geo_mercator.invert = function(x, y) {\n    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];\n  };\n  function d3_geo_mercatorProjection(project) {\n    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\n    m.scale = function() {\n      var v = scale.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.translate = function() {\n      var v = translate.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.clipExtent = function(_) {\n      var v = clipExtent.apply(m, arguments);\n      if (v === m) {\n        if (clipAuto = _ == null) {\n          var k = π * scale(), t = translate();\n          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);\n        }\n      } else if (clipAuto) {\n        v = null;\n      }\n      return v;\n    };\n    return m.clipExtent(null);\n  }\n  (d3.geo.mercator = function() {\n    return d3_geo_mercatorProjection(d3_geo_mercator);\n  }).raw = d3_geo_mercator;\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\n    return 1;\n  }, Math.asin);\n  (d3.geo.orthographic = function() {\n    return d3_geo_projection(d3_geo_orthographic);\n  }).raw = d3_geo_orthographic;\n  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / (1 + cosλcosφ);\n  }, function(ρ) {\n    return 2 * Math.atan(ρ);\n  });\n  (d3.geo.stereographic = function() {\n    return d3_geo_projection(d3_geo_stereographic);\n  }).raw = d3_geo_stereographic;\n  function d3_geo_transverseMercator(λ, φ) {\n    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];\n  }\n  d3_geo_transverseMercator.invert = function(x, y) {\n    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];\n  };\n  (d3.geo.transverseMercator = function() {\n    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;\n    projection.center = function(_) {\n      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);\n    };\n    projection.rotate = function(_) {\n      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), \n      [ _[0], _[1], _[2] - 90 ]);\n    };\n    return rotate([ 0, 0, 90 ]);\n  }).raw = d3_geo_transverseMercator;\n  d3.geom = {};\n  function d3_geom_pointX(d) {\n    return d[0];\n  }\n  function d3_geom_pointY(d) {\n    return d[1];\n  }\n  d3.geom.hull = function(vertices) {\n    var x = d3_geom_pointX, y = d3_geom_pointY;\n    if (arguments.length) return hull(vertices);\n    function hull(data) {\n      if (data.length < 3) return [];\n      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];\n      for (i = 0; i < n; i++) {\n        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);\n      }\n      points.sort(d3_geom_hullOrder);\n      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);\n      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);\n      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\n      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\n      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\n      return polygon;\n    }\n    hull.x = function(_) {\n      return arguments.length ? (x = _, hull) : x;\n    };\n    hull.y = function(_) {\n      return arguments.length ? (y = _, hull) : y;\n    };\n    return hull;\n  };\n  function d3_geom_hullUpper(points) {\n    var n = points.length, hull = [ 0, 1 ], hs = 2;\n    for (var i = 2; i < n; i++) {\n      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\n      hull[hs++] = i;\n    }\n    return hull.slice(0, hs);\n  }\n  function d3_geom_hullOrder(a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  }\n  d3.geom.polygon = function(coordinates) {\n    d3_subclass(coordinates, d3_geom_polygonPrototype);\n    return coordinates;\n  };\n  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\n  d3_geom_polygonPrototype.area = function() {\n    var i = -1, n = this.length, a, b = this[n - 1], area = 0;\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      area += a[1] * b[0] - a[0] * b[1];\n    }\n    return area * .5;\n  };\n  d3_geom_polygonPrototype.centroid = function(k) {\n    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\n    if (!arguments.length) k = -1 / (6 * this.area());\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [ x * k, y * k ];\n  };\n  d3_geom_polygonPrototype.clip = function(subject) {\n    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = this[i];\n      c = input[(m = input.length - closed) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      if (closed) subject.push(subject[0]);\n      a = b;\n    }\n    return subject;\n  };\n  function d3_geom_polygonInside(p, a, b) {\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n  }\n  function d3_geom_polygonIntersect(c, d, a, b) {\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n    return [ x1 + ua * x21, y1 + ua * y21 ];\n  }\n  function d3_geom_polygonClosed(coordinates) {\n    var a = coordinates[0], b = coordinates[coordinates.length - 1];\n    return !(a[0] - b[0] || a[1] - b[1]);\n  }\n  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\n  function d3_geom_voronoiBeach() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.edge = this.site = this.circle = null;\n  }\n  function d3_geom_voronoiCreateBeach(site) {\n    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\n    beach.site = site;\n    return beach;\n  }\n  function d3_geom_voronoiDetachBeach(beach) {\n    d3_geom_voronoiDetachCircle(beach);\n    d3_geom_voronoiBeaches.remove(beach);\n    d3_geom_voronoiBeachPool.push(beach);\n    d3_geom_voronoiRedBlackNode(beach);\n  }\n  function d3_geom_voronoiRemoveBeach(beach) {\n    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\n      x: x,\n      y: y\n    }, previous = beach.P, next = beach.N, disappearing = [ beach ];\n    d3_geom_voronoiDetachBeach(beach);\n    var lArc = previous;\n    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {\n      previous = lArc.P;\n      disappearing.unshift(lArc);\n      d3_geom_voronoiDetachBeach(lArc);\n      lArc = previous;\n    }\n    disappearing.unshift(lArc);\n    d3_geom_voronoiDetachCircle(lArc);\n    var rArc = next;\n    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {\n      next = rArc.N;\n      disappearing.push(rArc);\n      d3_geom_voronoiDetachBeach(rArc);\n      rArc = next;\n    }\n    disappearing.push(rArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var nArcs = disappearing.length, iArc;\n    for (iArc = 1; iArc < nArcs; ++iArc) {\n      rArc = disappearing[iArc];\n      lArc = disappearing[iArc - 1];\n      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n    }\n    lArc = disappearing[0];\n    rArc = disappearing[nArcs - 1];\n    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiAddBeach(site) {\n    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\n    while (node) {\n      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\n      if (dxl > ε) node = node.L; else {\n        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\n        if (dxr > ε) {\n          if (!node.R) {\n            lArc = node;\n            break;\n          }\n          node = node.R;\n        } else {\n          if (dxl > -ε) {\n            lArc = node.P;\n            rArc = node;\n          } else if (dxr > -ε) {\n            lArc = node;\n            rArc = node.N;\n          } else {\n            lArc = rArc = node;\n          }\n          break;\n        }\n      }\n    }\n    var newArc = d3_geom_voronoiCreateBeach(site);\n    d3_geom_voronoiBeaches.insert(lArc, newArc);\n    if (!lArc && !rArc) return;\n    if (lArc === rArc) {\n      d3_geom_voronoiDetachCircle(lArc);\n      rArc = d3_geom_voronoiCreateBeach(lArc.site);\n      d3_geom_voronoiBeaches.insert(newArc, rArc);\n      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      d3_geom_voronoiAttachCircle(lArc);\n      d3_geom_voronoiAttachCircle(rArc);\n      return;\n    }\n    if (!rArc) {\n      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      return;\n    }\n    d3_geom_voronoiDetachCircle(lArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\n      x: (cy * hb - by * hc) / d + ax,\n      y: (bx * hc - cx * hb) / d + ay\n    };\n    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\n    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\n    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\n    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\n    if (!pby2) return rfocx;\n    var lArc = arc.P;\n    if (!lArc) return -Infinity;\n    site = lArc.site;\n    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\n    if (!plby2) return lfocx;\n    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n    return (rfocx + lfocx) / 2;\n  }\n  function d3_geom_voronoiRightBreakPoint(arc, directrix) {\n    var rArc = arc.N;\n    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n  }\n  function d3_geom_voronoiCell(site) {\n    this.site = site;\n    this.edges = [];\n  }\n  d3_geom_voronoiCell.prototype.prepare = function() {\n    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\n    while (iHalfEdge--) {\n      edge = halfEdges[iHalfEdge].edge;\n      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n    }\n    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n    return halfEdges.length;\n  };\n  function d3_geom_voronoiCloseCells(extent) {\n    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\n    while (iCell--) {\n      cell = cells[iCell];\n      if (!cell || !cell.prepare()) continue;\n      halfEdges = cell.edges;\n      nHalfEdges = halfEdges.length;\n      iHalfEdge = 0;\n      while (iHalfEdge < nHalfEdges) {\n        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {\n            x: x0,\n            y: abs(x2 - x0) < ε ? y2 : y1\n          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {\n            x: abs(y2 - y1) < ε ? x2 : x1,\n            y: y1\n          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {\n            x: x1,\n            y: abs(x2 - x1) < ε ? y2 : y0\n          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {\n            x: abs(y2 - y0) < ε ? x2 : x0,\n            y: y0\n          } : null), cell.site, null));\n          ++nHalfEdges;\n        }\n      }\n    }\n  }\n  function d3_geom_voronoiHalfEdgeOrder(a, b) {\n    return b.angle - a.angle;\n  }\n  function d3_geom_voronoiCircle() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.x = this.y = this.arc = this.site = this.cy = null;\n  }\n  function d3_geom_voronoiAttachCircle(arc) {\n    var lArc = arc.P, rArc = arc.N;\n    if (!lArc || !rArc) return;\n    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n    if (lSite === rSite) return;\n    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\n    var d = 2 * (ax * cy - ay * cx);\n    if (d >= -ε2) return;\n    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;\n    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\n    circle.arc = arc;\n    circle.site = cSite;\n    circle.x = x + bx;\n    circle.y = cy + Math.sqrt(x * x + y * y);\n    circle.cy = cy;\n    arc.circle = circle;\n    var before = null, node = d3_geom_voronoiCircles._;\n    while (node) {\n      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n        if (node.L) node = node.L; else {\n          before = node.P;\n          break;\n        }\n      } else {\n        if (node.R) node = node.R; else {\n          before = node;\n          break;\n        }\n      }\n    }\n    d3_geom_voronoiCircles.insert(before, circle);\n    if (!before) d3_geom_voronoiFirstCircle = circle;\n  }\n  function d3_geom_voronoiDetachCircle(arc) {\n    var circle = arc.circle;\n    if (circle) {\n      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\n      d3_geom_voronoiCircles.remove(circle);\n      d3_geom_voronoiCirclePool.push(circle);\n      d3_geom_voronoiRedBlackNode(circle);\n      arc.circle = null;\n    }\n  }\n  function d3_geom_voronoiClipEdges(extent) {\n    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;\n    while (i--) {\n      e = edges[i];\n      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {\n        e.a = e.b = null;\n        edges.splice(i, 1);\n      }\n    }\n  }\n  function d3_geom_voronoiConnectEdge(edge, extent) {\n    var vb = edge.b;\n    if (vb) return true;\n    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n    if (ry === ly) {\n      if (fx < x0 || fx >= x1) return;\n      if (lx > rx) {\n        if (!va) va = {\n          x: fx,\n          y: y0\n        }; else if (va.y >= y1) return;\n        vb = {\n          x: fx,\n          y: y1\n        };\n      } else {\n        if (!va) va = {\n          x: fx,\n          y: y1\n        }; else if (va.y < y0) return;\n        vb = {\n          x: fx,\n          y: y0\n        };\n      }\n    } else {\n      fm = (lx - rx) / (ry - ly);\n      fb = fy - fm * fx;\n      if (fm < -1 || fm > 1) {\n        if (lx > rx) {\n          if (!va) va = {\n            x: (y0 - fb) / fm,\n            y: y0\n          }; else if (va.y >= y1) return;\n          vb = {\n            x: (y1 - fb) / fm,\n            y: y1\n          };\n        } else {\n          if (!va) va = {\n            x: (y1 - fb) / fm,\n            y: y1\n          }; else if (va.y < y0) return;\n          vb = {\n            x: (y0 - fb) / fm,\n            y: y0\n          };\n        }\n      } else {\n        if (ly < ry) {\n          if (!va) va = {\n            x: x0,\n            y: fm * x0 + fb\n          }; else if (va.x >= x1) return;\n          vb = {\n            x: x1,\n            y: fm * x1 + fb\n          };\n        } else {\n          if (!va) va = {\n            x: x1,\n            y: fm * x1 + fb\n          }; else if (va.x < x0) return;\n          vb = {\n            x: x0,\n            y: fm * x0 + fb\n          };\n        }\n      }\n    }\n    edge.a = va;\n    edge.b = vb;\n    return true;\n  }\n  function d3_geom_voronoiEdge(lSite, rSite) {\n    this.l = lSite;\n    this.r = rSite;\n    this.a = this.b = null;\n  }\n  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, rSite);\n    d3_geom_voronoiEdges.push(edge);\n    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\n    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\n    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\n    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\n    return edge;\n  }\n  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, null);\n    edge.a = va;\n    edge.b = vb;\n    d3_geom_voronoiEdges.push(edge);\n    return edge;\n  }\n  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\n    if (!edge.a && !edge.b) {\n      edge.a = vertex;\n      edge.l = lSite;\n      edge.r = rSite;\n    } else if (edge.l === rSite) {\n      edge.b = vertex;\n    } else {\n      edge.a = vertex;\n    }\n  }\n  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\n    var va = edge.a, vb = edge.b;\n    this.edge = edge;\n    this.site = lSite;\n    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n  }\n  d3_geom_voronoiHalfEdge.prototype = {\n    start: function() {\n      return this.edge.l === this.site ? this.edge.a : this.edge.b;\n    },\n    end: function() {\n      return this.edge.l === this.site ? this.edge.b : this.edge.a;\n    }\n  };\n  function d3_geom_voronoiRedBlackTree() {\n    this._ = null;\n  }\n  function d3_geom_voronoiRedBlackNode(node) {\n    node.U = node.C = node.L = node.R = node.P = node.N = null;\n  }\n  d3_geom_voronoiRedBlackTree.prototype = {\n    insert: function(after, node) {\n      var parent, grandpa, uncle;\n      if (after) {\n        node.P = after;\n        node.N = after.N;\n        if (after.N) after.N.P = node;\n        after.N = node;\n        if (after.R) {\n          after = after.R;\n          while (after.L) after = after.L;\n          after.L = node;\n        } else {\n          after.R = node;\n        }\n        parent = after;\n      } else if (this._) {\n        after = d3_geom_voronoiRedBlackFirst(this._);\n        node.P = null;\n        node.N = after;\n        after.P = after.L = node;\n        parent = after;\n      } else {\n        node.P = node.N = null;\n        this._ = node;\n        parent = null;\n      }\n      node.L = node.R = null;\n      node.U = parent;\n      node.C = true;\n      after = node;\n      while (parent && parent.C) {\n        grandpa = parent.U;\n        if (parent === grandpa.L) {\n          uncle = grandpa.R;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.R) {\n              d3_geom_voronoiRedBlackRotateLeft(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, grandpa);\n          }\n        } else {\n          uncle = grandpa.L;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.L) {\n              d3_geom_voronoiRedBlackRotateRight(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\n          }\n        }\n        parent = after.U;\n      }\n      this._.C = false;\n    },\n    remove: function(node) {\n      if (node.N) node.N.P = node.P;\n      if (node.P) node.P.N = node.N;\n      node.N = node.P = null;\n      var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);\n      if (parent) {\n        if (parent.L === node) parent.L = next; else parent.R = next;\n      } else {\n        this._ = next;\n      }\n      if (left && right) {\n        red = next.C;\n        next.C = node.C;\n        next.L = left;\n        left.U = next;\n        if (next !== right) {\n          parent = next.U;\n          next.U = node.U;\n          node = next.R;\n          parent.L = node;\n          next.R = right;\n          right.U = next;\n        } else {\n          next.U = parent;\n          parent = next;\n          node = next.R;\n        }\n      } else {\n        red = node.C;\n        node = next;\n      }\n      if (node) node.U = parent;\n      if (red) return;\n      if (node && node.C) {\n        node.C = false;\n        return;\n      }\n      do {\n        if (node === this._) break;\n        if (node === parent.L) {\n          sibling = parent.R;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            sibling = parent.R;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.R || !sibling.R.C) {\n              sibling.L.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateRight(this, sibling);\n              sibling = parent.R;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.R.C = false;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            node = this._;\n            break;\n          }\n        } else {\n          sibling = parent.L;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            sibling = parent.L;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.L || !sibling.L.C) {\n              sibling.R.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateLeft(this, sibling);\n              sibling = parent.L;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.L.C = false;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            node = this._;\n            break;\n          }\n        }\n        sibling.C = true;\n        node = parent;\n        parent = parent.U;\n      } while (!node.C);\n      if (node) node.C = false;\n    }\n  };\n  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\n    var p = node, q = node.R, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.R = q.L;\n    if (p.R) p.R.U = p;\n    q.L = p;\n  }\n  function d3_geom_voronoiRedBlackRotateRight(tree, node) {\n    var p = node, q = node.L, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.L = q.R;\n    if (p.L) p.L.U = p;\n    q.R = p;\n  }\n  function d3_geom_voronoiRedBlackFirst(node) {\n    while (node.L) node = node.L;\n    return node;\n  }\n  function d3_geom_voronoi(sites, bbox) {\n    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;\n    d3_geom_voronoiEdges = [];\n    d3_geom_voronoiCells = new Array(sites.length);\n    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\n    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\n    while (true) {\n      circle = d3_geom_voronoiFirstCircle;\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n        if (site.x !== x0 || site.y !== y0) {\n          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\n          d3_geom_voronoiAddBeach(site);\n          x0 = site.x, y0 = site.y;\n        }\n        site = sites.pop();\n      } else if (circle) {\n        d3_geom_voronoiRemoveBeach(circle.arc);\n      } else {\n        break;\n      }\n    }\n    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\n    var diagram = {\n      cells: d3_geom_voronoiCells,\n      edges: d3_geom_voronoiEdges\n    };\n    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\n    return diagram;\n  }\n  function d3_geom_voronoiVertexOrder(a, b) {\n    return b.y - a.y || b.x - a.x;\n  }\n  d3.geom.voronoi = function(points) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\n    if (points) return voronoi(points);\n    function voronoi(data) {\n      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\n      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {\n          var s = e.start();\n          return [ s.x, s.y ];\n        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\n        polygon.point = data[i];\n      });\n      return polygons;\n    }\n    function sites(data) {\n      return data.map(function(d, i) {\n        return {\n          x: Math.round(fx(d, i) / ε) * ε,\n          y: Math.round(fy(d, i) / ε) * ε,\n          i: i\n        };\n      });\n    }\n    voronoi.links = function(data) {\n      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n        return edge.l && edge.r;\n      }).map(function(edge) {\n        return {\n          source: data[edge.l.i],\n          target: data[edge.r.i]\n        };\n      });\n    };\n    voronoi.triangles = function(data) {\n      var triangles = [];\n      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\n        while (++j < m) {\n          e0 = e1;\n          s0 = s1;\n          e1 = edges[j].edge;\n          s1 = e1.l === site ? e1.r : e1.l;\n          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n            triangles.push([ data[i], data[s0.i], data[s1.i] ]);\n          }\n        }\n      });\n      return triangles;\n    };\n    voronoi.x = function(_) {\n      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n    };\n    voronoi.y = function(_) {\n      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n    };\n    voronoi.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n      return voronoi;\n    };\n    voronoi.size = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);\n    };\n    return voronoi;\n  };\n  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\n  function d3_geom_voronoiTriangleArea(a, b, c) {\n    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n  }\n  d3.geom.delaunay = function(vertices) {\n    return d3.geom.voronoi().triangles(vertices);\n  };\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, compat;\n    if (compat = arguments.length) {\n      x = d3_geom_quadtreeCompatX;\n      y = d3_geom_quadtreeCompatY;\n      if (compat === 3) {\n        y2 = y1;\n        x2 = x1;\n        y1 = x1 = 0;\n      }\n      return quadtree(points);\n    }\n    function quadtree(data) {\n      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;\n      if (x1 != null) {\n        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n      } else {\n        x2_ = y2_ = -(x1_ = y1_ = Infinity);\n        xs = [], ys = [];\n        n = data.length;\n        if (compat) for (i = 0; i < n; ++i) {\n          d = data[i];\n          if (d.x < x1_) x1_ = d.x;\n          if (d.y < y1_) y1_ = d.y;\n          if (d.x > x2_) x2_ = d.x;\n          if (d.y > y2_) y2_ = d.y;\n          xs.push(d.x);\n          ys.push(d.y);\n        } else for (i = 0; i < n; ++i) {\n          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);\n          if (x_ < x1_) x1_ = x_;\n          if (y_ < y1_) y1_ = y_;\n          if (x_ > x2_) x2_ = x_;\n          if (y_ > y2_) y2_ = y_;\n          xs.push(x_);\n          ys.push(y_);\n        }\n      }\n      var dx = x2_ - x1_, dy = y2_ - y1_;\n      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;\n      function insert(n, d, x, y, x1, y1, x2, y2) {\n        if (isNaN(x) || isNaN(y)) return;\n        if (n.leaf) {\n          var nx = n.x, ny = n.y;\n          if (nx != null) {\n            if (abs(nx - x) + abs(ny - y) < .01) {\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            } else {\n              var nPoint = n.point;\n              n.x = n.y = n.point = null;\n              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            }\n          } else {\n            n.x = x, n.y = y, n.point = d;\n          }\n        } else {\n          insertChild(n, d, x, y, x1, y1, x2, y2);\n        }\n      }\n      function insertChild(n, d, x, y, x1, y1, x2, y2) {\n        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\n        n.leaf = false;\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n        if (right) x1 = xm; else x2 = xm;\n        if (below) y1 = ym; else y2 = ym;\n        insert(n, d, x, y, x1, y1, x2, y2);\n      }\n      var root = d3_geom_quadtreeNode();\n      root.add = function(d) {\n        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\n      };\n      root.visit = function(f) {\n        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\n      };\n      root.find = function(point) {\n        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\n      };\n      i = -1;\n      if (x1 == null) {\n        while (++i < n) {\n          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\n        }\n        --i;\n      } else data.forEach(root.add);\n      xs = ys = data = d = null;\n      return root;\n    }\n    quadtree.x = function(_) {\n      return arguments.length ? (x = _, quadtree) : x;\n    };\n    quadtree.y = function(_) {\n      return arguments.length ? (y = _, quadtree) : y;\n    };\n    quadtree.extent = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], \n      y2 = +_[1][1];\n      return quadtree;\n    };\n    quadtree.size = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\n      return quadtree;\n    };\n    return quadtree;\n  };\n  function d3_geom_quadtreeCompatX(d) {\n    return d.x;\n  }\n  function d3_geom_quadtreeCompatY(d) {\n    return d.y;\n  }\n  function d3_geom_quadtreeNode() {\n    return {\n      leaf: true,\n      nodes: [],\n      point: null,\n      x: null,\n      y: null\n    };\n  }\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n    if (!f(node, x1, y1, x2, y2)) {\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n    }\n  }\n  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\n    var minDistance2 = Infinity, closestPoint;\n    (function find(node, x1, y1, x2, y2) {\n      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\n      if (point = node.point) {\n        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\n        if (distance2 < minDistance2) {\n          var distance = Math.sqrt(minDistance2 = distance2);\n          x0 = x - distance, y0 = y - distance;\n          x3 = x + distance, y3 = y + distance;\n          closestPoint = point;\n        }\n      }\n      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;\n      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\n        if (node = children[i & 3]) switch (i & 3) {\n         case 0:\n          find(node, x1, y1, xm, ym);\n          break;\n\n         case 1:\n          find(node, xm, y1, x2, ym);\n          break;\n\n         case 2:\n          find(node, x1, ym, xm, y2);\n          break;\n\n         case 3:\n          find(node, xm, ym, x2, y2);\n          break;\n        }\n      }\n    })(root, x0, y0, x3, y3);\n    return closestPoint;\n  }\n  d3.interpolateRgb = d3_interpolateRgb;\n  function d3_interpolateRgb(a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\n    return function(t) {\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  }\n  d3.interpolateObject = d3_interpolateObject;\n  function d3_interpolateObject(a, b) {\n    var i = {}, c = {}, k;\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolate(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n    return function(t) {\n      for (k in i) c[k] = i[k](t);\n      return c;\n    };\n  }\n  d3.interpolateNumber = d3_interpolateNumber;\n  function d3_interpolateNumber(a, b) {\n    a = +a, b = +b;\n    return function(t) {\n      return a * (1 - t) + b * t;\n    };\n  }\n  d3.interpolateString = d3_interpolateString;\n  function d3_interpolateString(a, b) {\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\n    a = a + \"\", b = b + \"\";\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n      if ((bs = bm.index) > bi) {\n        bs = b.slice(bi, bs);\n        if (s[i]) s[i] += bs; else s[++i] = bs;\n      }\n      if ((am = am[0]) === (bm = bm[0])) {\n        if (s[i]) s[i] += bm; else s[++i] = bm;\n      } else {\n        s[++i] = null;\n        q.push({\n          i: i,\n          x: d3_interpolateNumber(am, bm)\n        });\n      }\n      bi = d3_interpolate_numberB.lastIndex;\n    }\n    if (bi < b.length) {\n      bs = b.slice(bi);\n      if (s[i]) s[i] += bs; else s[++i] = bs;\n    }\n    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {\n      return b(t) + \"\";\n    }) : function() {\n      return b;\n    } : (b = q.length, function(t) {\n      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    });\n  }\n  var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \"g\");\n  d3.interpolate = d3_interpolate;\n  function d3_interpolate(a, b) {\n    var i = d3.interpolators.length, f;\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\n    return f;\n  }\n  d3.interpolators = [ function(a, b) {\n    var t = typeof b;\n    return (t === \"string\" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\(|hsl\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \"object\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n  } ];\n  d3.interpolateArray = d3_interpolateArray;\n  function d3_interpolateArray(a, b) {\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\n    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\n    for (;i < na; ++i) c[i] = a[i];\n    for (;i < nb; ++i) c[i] = b[i];\n    return function(t) {\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\n      return c;\n    };\n  }\n  var d3_ease_default = function() {\n    return d3_identity;\n  };\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function() {\n      return d3_ease_quad;\n    },\n    cubic: function() {\n      return d3_ease_cubic;\n    },\n    sin: function() {\n      return d3_ease_sin;\n    },\n    exp: function() {\n      return d3_ease_exp;\n    },\n    circle: function() {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function() {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    \"in\": d3_identity,\n    out: d3_ease_reverse,\n    \"in-out\": d3_ease_reflect,\n    \"out-in\": function(f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n  d3.ease = function(name) {\n    var i = name.indexOf(\"-\"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : \"in\";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n  };\n  function d3_ease_clamp(f) {\n    return function(t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n  function d3_ease_reverse(f) {\n    return function(t) {\n      return 1 - f(1 - t);\n    };\n  }\n  function d3_ease_reflect(f) {\n    return function(t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  }\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t, t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n  function d3_ease_poly(e) {\n    return function(t) {\n      return Math.pow(t, e);\n    };\n  }\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * halfπ);\n  }\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = .45;\n    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;\n    return function(t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);\n    };\n  }\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function(t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n  d3.interpolateHcl = d3_interpolateHcl;\n  function d3_interpolateHcl(a, b) {\n    a = d3.hcl(a);\n    b = d3.hcl(b);\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\n    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateHsl = d3_interpolateHsl;\n  function d3_interpolateHsl(a, b) {\n    a = d3.hsl(a);\n    b = d3.hsl(b);\n    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\n    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateLab = d3_interpolateLab;\n  function d3_interpolateLab(a, b) {\n    a = d3.lab(a);\n    b = d3.lab(b);\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\n    return function(t) {\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n    };\n  }\n  d3.interpolateRound = d3_interpolateRound;\n  function d3_interpolateRound(a, b) {\n    b -= a;\n    return function(t) {\n      return Math.round(a + b * t);\n    };\n  }\n  d3.transform = function(string) {\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\n    return (d3.transform = function(string) {\n      if (string != null) {\n        g.setAttribute(\"transform\", string);\n        var t = g.transform.baseVal.consolidate();\n      }\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  };\n  function d3_transform(m) {\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [ m.e, m.f ];\n    this.scale = [ kx, ky ];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n  d3_transform.prototype.toString = function() {\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n  };\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n    return k;\n  }\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n  d3.interpolateTransform = d3_interpolateTransform;\n  function d3_interpolateTransformPop(s) {\n    return s.length ? s.pop() + \",\" : \"\";\n  }\n  function d3_interpolateTranslate(ta, tb, s, q) {\n    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\n      var i = s.push(\"translate(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ta[0], tb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push(\"translate(\" + tb + \")\");\n    }\n  }\n  function d3_interpolateRotate(ra, rb, s, q) {\n    if (ra !== rb) {\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"rotate(\", null, \")\") - 2,\n        x: d3_interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(d3_interpolateTransformPop(s) + \"rotate(\" + rb + \")\");\n    }\n  }\n  function d3_interpolateSkew(wa, wb, s, q) {\n    if (wa !== wb) {\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"skewX(\", null, \")\") - 2,\n        x: d3_interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(d3_interpolateTransformPop(s) + \"skewX(\" + wb + \")\");\n    }\n  }\n  function d3_interpolateScale(ka, kb, s, q) {\n    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\n      var i = s.push(d3_interpolateTransformPop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ka[0], kb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] !== 1 || kb[1] !== 1) {\n      s.push(d3_interpolateTransformPop(s) + \"scale(\" + kb + \")\");\n    }\n  }\n  function d3_interpolateTransform(a, b) {\n    var s = [], q = [];\n    a = d3.transform(a), b = d3.transform(b);\n    d3_interpolateTranslate(a.translate, b.translate, s, q);\n    d3_interpolateRotate(a.rotate, b.rotate, s, q);\n    d3_interpolateSkew(a.skew, b.skew, s, q);\n    d3_interpolateScale(a.scale, b.scale, s, q);\n    a = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  }\n  function d3_uninterpolateNumber(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return (x - a) / b;\n    };\n  }\n  function d3_uninterpolateClamp(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return Math.max(0, Math.min(1, (x - a) / b));\n    };\n  }\n  d3.layout = {};\n  d3.layout.bundle = function() {\n    return function(links) {\n      var paths = [], i = -1, n = links.length;\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n      return paths;\n    };\n  };\n  function d3_layout_bundlePath(link) {\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\n    while (start !== lca) {\n      start = start.parent;\n      points.push(start);\n    }\n    var k = points.length;\n    while (end !== lca) {\n      points.splice(k, 0, end);\n      end = end.parent;\n    }\n    return points;\n  }\n  function d3_layout_bundleAncestors(node) {\n    var ancestors = [], parent = node.parent;\n    while (parent != null) {\n      ancestors.push(node);\n      node = parent;\n      parent = parent.parent;\n    }\n    ancestors.push(node);\n    return ancestors;\n  }\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\n    if (a === b) return a;\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\n    while (aNode === bNode) {\n      sharedNode = aNode;\n      aNode = aNodes.pop();\n      bNode = bNodes.pop();\n    }\n    return sharedNode;\n  }\n  d3.layout.chord = function() {\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\n    function relayout() {\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\n      chords = [];\n      groups = [];\n      k = 0, i = -1;\n      while (++i < n) {\n        x = 0, j = -1;\n        while (++j < n) {\n          x += matrix[i][j];\n        }\n        groupSums.push(x);\n        subgroupIndex.push(d3.range(n));\n        k += x;\n      }\n      if (sortGroups) {\n        groupIndex.sort(function(a, b) {\n          return sortGroups(groupSums[a], groupSums[b]);\n        });\n      }\n      if (sortSubgroups) {\n        subgroupIndex.forEach(function(d, i) {\n          d.sort(function(a, b) {\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\n          });\n        });\n      }\n      k = (τ - padding * n) / k;\n      x = 0, i = -1;\n      while (++i < n) {\n        x0 = x, j = -1;\n        while (++j < n) {\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\n          subgroups[di + \"-\" + dj] = {\n            index: di,\n            subindex: dj,\n            startAngle: a0,\n            endAngle: a1,\n            value: v\n          };\n        }\n        groups[di] = {\n          index: di,\n          startAngle: x0,\n          endAngle: x,\n          value: groupSums[di]\n        };\n        x += padding;\n      }\n      i = -1;\n      while (++i < n) {\n        j = i - 1;\n        while (++j < n) {\n          var source = subgroups[i + \"-\" + j], target = subgroups[j + \"-\" + i];\n          if (source.value || target.value) {\n            chords.push(source.value < target.value ? {\n              source: target,\n              target: source\n            } : {\n              source: source,\n              target: target\n            });\n          }\n        }\n      }\n      if (sortChords) resort();\n    }\n    function resort() {\n      chords.sort(function(a, b) {\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n      });\n    }\n    chord.matrix = function(x) {\n      if (!arguments.length) return matrix;\n      n = (matrix = x) && matrix.length;\n      chords = groups = null;\n      return chord;\n    };\n    chord.padding = function(x) {\n      if (!arguments.length) return padding;\n      padding = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortGroups = function(x) {\n      if (!arguments.length) return sortGroups;\n      sortGroups = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortSubgroups = function(x) {\n      if (!arguments.length) return sortSubgroups;\n      sortSubgroups = x;\n      chords = null;\n      return chord;\n    };\n    chord.sortChords = function(x) {\n      if (!arguments.length) return sortChords;\n      sortChords = x;\n      if (chords) resort();\n      return chord;\n    };\n    chord.chords = function() {\n      if (!chords) relayout();\n      return chords;\n    };\n    chord.groups = function() {\n      if (!groups) relayout();\n      return groups;\n    };\n    return chord;\n  };\n  d3.layout.force = function() {\n    var force = {}, event = d3.dispatch(\"start\", \"tick\", \"end\"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\n    function repulse(node) {\n      return function(quad, x1, _, x2) {\n        if (quad.point !== node) {\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\n          if (dw * dw / theta2 < dn) {\n            if (dn < chargeDistance2) {\n              var k = quad.charge / dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n            }\n            return true;\n          }\n          if (quad.point && dn && dn < chargeDistance2) {\n            var k = quad.pointCharge / dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n          }\n        }\n        return !quad.charge;\n      };\n    }\n    force.tick = function() {\n      if ((alpha *= .99) < .005) {\n        timer = null;\n        event.end({\n          type: \"end\",\n          alpha: alpha = 0\n        });\n        return true;\n      }\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        s = o.source;\n        t = o.target;\n        x = t.x - s.x;\n        y = t.y - s.y;\n        if (l = x * x + y * y) {\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n          x *= l;\n          y *= l;\n          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\n          t.y -= y * k;\n          s.x += x * (k = 1 - k);\n          s.y += y * k;\n        }\n      }\n      if (k = alpha * gravity) {\n        x = size[0] / 2;\n        y = size[1] / 2;\n        i = -1;\n        if (k) while (++i < n) {\n          o = nodes[i];\n          o.x += (x - o.x) * k;\n          o.y += (y - o.y) * k;\n        }\n      }\n      if (charge) {\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n        i = -1;\n        while (++i < n) {\n          if (!(o = nodes[i]).fixed) {\n            q.visit(repulse(o));\n          }\n        }\n      }\n      i = -1;\n      while (++i < n) {\n        o = nodes[i];\n        if (o.fixed) {\n          o.x = o.px;\n          o.y = o.py;\n        } else {\n          o.x -= (o.px - (o.px = o.x)) * friction;\n          o.y -= (o.py - (o.py = o.y)) * friction;\n        }\n      }\n      event.tick({\n        type: \"tick\",\n        alpha: alpha\n      });\n    };\n    force.nodes = function(x) {\n      if (!arguments.length) return nodes;\n      nodes = x;\n      return force;\n    };\n    force.links = function(x) {\n      if (!arguments.length) return links;\n      links = x;\n      return force;\n    };\n    force.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return force;\n    };\n    force.linkDistance = function(x) {\n      if (!arguments.length) return linkDistance;\n      linkDistance = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.distance = force.linkDistance;\n    force.linkStrength = function(x) {\n      if (!arguments.length) return linkStrength;\n      linkStrength = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.friction = function(x) {\n      if (!arguments.length) return friction;\n      friction = +x;\n      return force;\n    };\n    force.charge = function(x) {\n      if (!arguments.length) return charge;\n      charge = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.chargeDistance = function(x) {\n      if (!arguments.length) return Math.sqrt(chargeDistance2);\n      chargeDistance2 = x * x;\n      return force;\n    };\n    force.gravity = function(x) {\n      if (!arguments.length) return gravity;\n      gravity = +x;\n      return force;\n    };\n    force.theta = function(x) {\n      if (!arguments.length) return Math.sqrt(theta2);\n      theta2 = x * x;\n      return force;\n    };\n    force.alpha = function(x) {\n      if (!arguments.length) return alpha;\n      x = +x;\n      if (alpha) {\n        if (x > 0) {\n          alpha = x;\n        } else {\n          timer.c = null, timer.t = NaN, timer = null;\n          event.end({\n            type: \"end\",\n            alpha: alpha = 0\n          });\n        }\n      } else if (x > 0) {\n        event.start({\n          type: \"start\",\n          alpha: alpha = x\n        });\n        timer = d3_timer(force.tick);\n      }\n      return force;\n    };\n    force.start = function() {\n      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\n      for (i = 0; i < n; ++i) {\n        (o = nodes[i]).index = i;\n        o.weight = 0;\n      }\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        if (typeof o.source == \"number\") o.source = nodes[o.source];\n        if (typeof o.target == \"number\") o.target = nodes[o.target];\n        ++o.source.weight;\n        ++o.target.weight;\n      }\n      for (i = 0; i < n; ++i) {\n        o = nodes[i];\n        if (isNaN(o.x)) o.x = position(\"x\", w);\n        if (isNaN(o.y)) o.y = position(\"y\", h);\n        if (isNaN(o.px)) o.px = o.x;\n        if (isNaN(o.py)) o.py = o.y;\n      }\n      distances = [];\n      if (typeof linkDistance === \"function\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\n      strengths = [];\n      if (typeof linkStrength === \"function\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\n      charges = [];\n      if (typeof charge === \"function\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\n      function position(dimension, size) {\n        if (!neighbors) {\n          neighbors = new Array(n);\n          for (j = 0; j < n; ++j) {\n            neighbors[j] = [];\n          }\n          for (j = 0; j < m; ++j) {\n            var o = links[j];\n            neighbors[o.source.index].push(o.target);\n            neighbors[o.target.index].push(o.source);\n          }\n        }\n        var candidates = neighbors[i], j = -1, l = candidates.length, x;\n        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\n        return Math.random() * size;\n      }\n      return force.resume();\n    };\n    force.resume = function() {\n      return force.alpha(.1);\n    };\n    force.stop = function() {\n      return force.alpha(0);\n    };\n    force.drag = function() {\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\", d3_layout_forceDragstart).on(\"drag.force\", dragmove).on(\"dragend.force\", d3_layout_forceDragend);\n      if (!arguments.length) return drag;\n      this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\n    };\n    function dragmove(d) {\n      d.px = d3.event.x, d.py = d3.event.y;\n      force.resume();\n    }\n    return d3.rebind(force, event, \"on\");\n  };\n  function d3_layout_forceDragstart(d) {\n    d.fixed |= 2;\n  }\n  function d3_layout_forceDragend(d) {\n    d.fixed &= ~6;\n  }\n  function d3_layout_forceMouseover(d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  }\n  function d3_layout_forceMouseout(d) {\n    d.fixed &= ~4;\n  }\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\n    var cx = 0, cy = 0;\n    quad.charge = 0;\n    if (!quad.leaf) {\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\n      while (++i < n) {\n        c = nodes[i];\n        if (c == null) continue;\n        d3_layout_forceAccumulate(c, alpha, charges);\n        quad.charge += c.charge;\n        cx += c.charge * c.cx;\n        cy += c.charge * c.cy;\n      }\n    }\n    if (quad.point) {\n      if (!quad.leaf) {\n        quad.point.x += Math.random() - .5;\n        quad.point.y += Math.random() - .5;\n      }\n      var k = alpha * charges[quad.point.index];\n      quad.charge += quad.pointCharge = k;\n      cx += k * quad.point.x;\n      cy += k * quad.point.y;\n    }\n    quad.cx = cx / quad.charge;\n    quad.cy = cy / quad.charge;\n  }\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\n  d3.layout.hierarchy = function() {\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\n    function hierarchy(root) {\n      var stack = [ root ], nodes = [], node;\n      root.depth = 0;\n      while ((node = stack.pop()) != null) {\n        nodes.push(node);\n        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n          var n, childs, child;\n          while (--n >= 0) {\n            stack.push(child = childs[n]);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n          if (value) node.value = 0;\n          node.children = childs;\n        } else {\n          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          delete node.children;\n        }\n      }\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var childs, parent;\n        if (sort && (childs = node.children)) childs.sort(sort);\n        if (value && (parent = node.parent)) parent.value += node.value;\n      });\n      return nodes;\n    }\n    hierarchy.sort = function(x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return hierarchy;\n    };\n    hierarchy.children = function(x) {\n      if (!arguments.length) return children;\n      children = x;\n      return hierarchy;\n    };\n    hierarchy.value = function(x) {\n      if (!arguments.length) return value;\n      value = x;\n      return hierarchy;\n    };\n    hierarchy.revalue = function(root) {\n      if (value) {\n        d3_layout_hierarchyVisitBefore(root, function(node) {\n          if (node.children) node.value = 0;\n        });\n        d3_layout_hierarchyVisitAfter(root, function(node) {\n          var parent;\n          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          if (parent = node.parent) parent.value += node.value;\n        });\n      }\n      return root;\n    };\n    return hierarchy;\n  };\n  function d3_layout_hierarchyRebind(object, hierarchy) {\n    d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n    object.nodes = object;\n    object.links = d3_layout_hierarchyLinks;\n    return object;\n  }\n  function d3_layout_hierarchyVisitBefore(node, callback) {\n    var nodes = [ node ];\n    while ((node = nodes.pop()) != null) {\n      callback(node);\n      if ((children = node.children) && (n = children.length)) {\n        var n, children;\n        while (--n >= 0) nodes.push(children[n]);\n      }\n    }\n  }\n  function d3_layout_hierarchyVisitAfter(node, callback) {\n    var nodes = [ node ], nodes2 = [];\n    while ((node = nodes.pop()) != null) {\n      nodes2.push(node);\n      if ((children = node.children) && (n = children.length)) {\n        var i = -1, n, children;\n        while (++i < n) nodes.push(children[i]);\n      }\n    }\n    while ((node = nodes2.pop()) != null) {\n      callback(node);\n    }\n  }\n  function d3_layout_hierarchyChildren(d) {\n    return d.children;\n  }\n  function d3_layout_hierarchyValue(d) {\n    return d.value;\n  }\n  function d3_layout_hierarchySort(a, b) {\n    return b.value - a.value;\n  }\n  function d3_layout_hierarchyLinks(nodes) {\n    return d3.merge(nodes.map(function(parent) {\n      return (parent.children || []).map(function(child) {\n        return {\n          source: parent,\n          target: child\n        };\n      });\n    }));\n  }\n  d3.layout.partition = function() {\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n      if (children && (n = children.length)) {\n        var i = -1, n, c, d;\n        dx = node.value ? dx / node.value : 0;\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n    function depth(node) {\n      var children = node.children, d = 0;\n      if (children && (n = children.length)) {\n        var i = -1, n;\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n      return 1 + d;\n    }\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n    partition.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n  d3.layout.pie = function() {\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;\n    function pie(data) {\n      var n = data.length, values = data.map(function(d, i) {\n        return +value.call(pie, d, i);\n      }), a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === \"function\" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\n        return values[j] - values[i];\n      } : function(i, j) {\n        return sort(data[i], data[j]);\n      });\n      index.forEach(function(i) {\n        arcs[i] = {\n          data: data[i],\n          value: v = values[i],\n          startAngle: a,\n          endAngle: a += v * k + pa,\n          padAngle: p\n        };\n      });\n      return arcs;\n    }\n    pie.value = function(_) {\n      if (!arguments.length) return value;\n      value = _;\n      return pie;\n    };\n    pie.sort = function(_) {\n      if (!arguments.length) return sort;\n      sort = _;\n      return pie;\n    };\n    pie.startAngle = function(_) {\n      if (!arguments.length) return startAngle;\n      startAngle = _;\n      return pie;\n    };\n    pie.endAngle = function(_) {\n      if (!arguments.length) return endAngle;\n      endAngle = _;\n      return pie;\n    };\n    pie.padAngle = function(_) {\n      if (!arguments.length) return padAngle;\n      padAngle = _;\n      return pie;\n    };\n    return pie;\n  };\n  var d3_layout_pieSortByValue = {};\n  d3.layout.stack = function() {\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\n    function stack(data, index) {\n      if (!(n = data.length)) return data;\n      var series = data.map(function(d, i) {\n        return values.call(stack, d, i);\n      });\n      var points = series.map(function(d) {\n        return d.map(function(v, i) {\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\n        });\n      });\n      var orders = order.call(stack, points, index);\n      series = d3.permute(series, orders);\n      points = d3.permute(points, orders);\n      var offsets = offset.call(stack, points, index);\n      var m = series[0].length, n, i, j, o;\n      for (j = 0; j < m; ++j) {\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n        for (i = 1; i < n; ++i) {\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n        }\n      }\n      return data;\n    }\n    stack.values = function(x) {\n      if (!arguments.length) return values;\n      values = x;\n      return stack;\n    };\n    stack.order = function(x) {\n      if (!arguments.length) return order;\n      order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n      return stack;\n    };\n    stack.offset = function(x) {\n      if (!arguments.length) return offset;\n      offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n      return stack;\n    };\n    stack.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      return stack;\n    };\n    stack.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      return stack;\n    };\n    stack.out = function(z) {\n      if (!arguments.length) return out;\n      out = z;\n      return stack;\n    };\n    return stack;\n  };\n  function d3_layout_stackX(d) {\n    return d.x;\n  }\n  function d3_layout_stackY(d) {\n    return d.y;\n  }\n  function d3_layout_stackOut(d, y0, y) {\n    d.y0 = y0;\n    d.y = y;\n  }\n  var d3_layout_stackOrders = d3.map({\n    \"inside-out\": function(data) {\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\n        return max[a] - max[b];\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\n      for (i = 0; i < n; ++i) {\n        j = index[i];\n        if (top < bottom) {\n          top += sums[j];\n          tops.push(j);\n        } else {\n          bottom += sums[j];\n          bottoms.push(j);\n        }\n      }\n      return bottoms.reverse().concat(tops);\n    },\n    reverse: function(data) {\n      return d3.range(data.length).reverse();\n    },\n    \"default\": d3_layout_stackOrderDefault\n  });\n  var d3_layout_stackOffsets = d3.map({\n    silhouette: function(data) {\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o > max) max = o;\n        sums.push(o);\n      }\n      for (j = 0; j < m; ++j) {\n        y0[j] = (max - sums[j]) / 2;\n      }\n      return y0;\n    },\n    wiggle: function(data) {\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\n      y0[0] = o = o0 = 0;\n      for (j = 1; j < m; ++j) {\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n          }\n          s2 += s3 * data[i][j][1];\n        }\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n        if (o < o0) o0 = o;\n      }\n      for (j = 0; j < m; ++j) y0[j] -= o0;\n      return y0;\n    },\n    expand: function(data) {\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\n      }\n      for (j = 0; j < m; ++j) y0[j] = 0;\n      return y0;\n    },\n    zero: d3_layout_stackOffsetZero\n  });\n  function d3_layout_stackOrderDefault(data) {\n    return d3.range(data.length);\n  }\n  function d3_layout_stackOffsetZero(data) {\n    var j = -1, m = data[0].length, y0 = [];\n    while (++j < m) y0[j] = 0;\n    return y0;\n  }\n  function d3_layout_stackMaxIndex(array) {\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\n    for (;i < n; ++i) {\n      if ((k = array[i][1]) > v) {\n        j = i;\n        v = k;\n      }\n    }\n    return j;\n  }\n  function d3_layout_stackReduceSum(d) {\n    return d.reduce(d3_layout_stackSum, 0);\n  }\n  function d3_layout_stackSum(p, d) {\n    return p + d[1];\n  }\n  d3.layout.histogram = function() {\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\n    function histogram(data, i) {\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\n      while (++i < m) {\n        bin = bins[i] = [];\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n        bin.y = 0;\n      }\n      if (m > 0) {\n        i = -1;\n        while (++i < n) {\n          x = values[i];\n          if (x >= range[0] && x <= range[1]) {\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n            bin.y += k;\n            bin.push(data[i]);\n          }\n        }\n      }\n      return bins;\n    }\n    histogram.value = function(x) {\n      if (!arguments.length) return valuer;\n      valuer = x;\n      return histogram;\n    };\n    histogram.range = function(x) {\n      if (!arguments.length) return ranger;\n      ranger = d3_functor(x);\n      return histogram;\n    };\n    histogram.bins = function(x) {\n      if (!arguments.length) return binner;\n      binner = typeof x === \"number\" ? function(range) {\n        return d3_layout_histogramBinFixed(range, x);\n      } : d3_functor(x);\n      return histogram;\n    };\n    histogram.frequency = function(x) {\n      if (!arguments.length) return frequency;\n      frequency = !!x;\n      return histogram;\n    };\n    return histogram;\n  };\n  function d3_layout_histogramBinSturges(range, values) {\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n  }\n  function d3_layout_histogramBinFixed(range, n) {\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\n    while (++x <= n) f[x] = m * x + b;\n    return f;\n  }\n  function d3_layout_histogramRange(values) {\n    return [ d3.min(values), d3.max(values) ];\n  }\n  d3.layout.pack = function() {\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;\n    function pack(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === \"function\" ? radius : function() {\n        return radius;\n      };\n      root.x = root.y = 0;\n      d3_layout_hierarchyVisitAfter(root, function(d) {\n        d.r = +r(d.value);\n      });\n      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n      if (padding) {\n        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r += dr;\n        });\n        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r -= dr;\n        });\n      }\n      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\n      return nodes;\n    }\n    pack.size = function(_) {\n      if (!arguments.length) return size;\n      size = _;\n      return pack;\n    };\n    pack.radius = function(_) {\n      if (!arguments.length) return radius;\n      radius = _ == null || typeof _ === \"function\" ? _ : +_;\n      return pack;\n    };\n    pack.padding = function(_) {\n      if (!arguments.length) return padding;\n      padding = +_;\n      return pack;\n    };\n    return d3_layout_hierarchyRebind(pack, hierarchy);\n  };\n  function d3_layout_packSort(a, b) {\n    return a.value - b.value;\n  }\n  function d3_layout_packInsert(a, b) {\n    var c = a._pack_next;\n    a._pack_next = b;\n    b._pack_prev = a;\n    b._pack_next = c;\n    c._pack_prev = b;\n  }\n  function d3_layout_packSplice(a, b) {\n    a._pack_next = b;\n    b._pack_prev = a;\n  }\n  function d3_layout_packIntersects(a, b) {\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\n    return .999 * dr * dr > dx * dx + dy * dy;\n  }\n  function d3_layout_packSiblings(node) {\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\n    function bound(node) {\n      xMin = Math.min(node.x - node.r, xMin);\n      xMax = Math.max(node.x + node.r, xMax);\n      yMin = Math.min(node.y - node.r, yMin);\n      yMax = Math.max(node.y + node.r, yMax);\n    }\n    nodes.forEach(d3_layout_packLink);\n    a = nodes[0];\n    a.x = -a.r;\n    a.y = 0;\n    bound(a);\n    if (n > 1) {\n      b = nodes[1];\n      b.x = b.r;\n      b.y = 0;\n      bound(b);\n      if (n > 2) {\n        c = nodes[2];\n        d3_layout_packPlace(a, b, c);\n        bound(c);\n        d3_layout_packInsert(a, c);\n        a._pack_prev = c;\n        d3_layout_packInsert(c, b);\n        b = a._pack_next;\n        for (i = 3; i < n; i++) {\n          d3_layout_packPlace(a, b, c = nodes[i]);\n          var isect = 0, s1 = 1, s2 = 1;\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n            if (d3_layout_packIntersects(j, c)) {\n              isect = 1;\n              break;\n            }\n          }\n          if (isect == 1) {\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n              if (d3_layout_packIntersects(k, c)) {\n                break;\n              }\n            }\n          }\n          if (isect) {\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\n            i--;\n          } else {\n            d3_layout_packInsert(a, c);\n            b = c;\n            bound(c);\n          }\n        }\n      }\n    }\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\n    for (i = 0; i < n; i++) {\n      c = nodes[i];\n      c.x -= cx;\n      c.y -= cy;\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n    }\n    node.r = cr;\n    nodes.forEach(d3_layout_packUnlink);\n  }\n  function d3_layout_packLink(node) {\n    node._pack_next = node._pack_prev = node;\n  }\n  function d3_layout_packUnlink(node) {\n    delete node._pack_next;\n    delete node._pack_prev;\n  }\n  function d3_layout_packTransform(node, x, y, k) {\n    var children = node.children;\n    node.x = x += k * node.x;\n    node.y = y += k * node.y;\n    node.r *= k;\n    if (children) {\n      var i = -1, n = children.length;\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n    }\n  }\n  function d3_layout_packPlace(a, b, c) {\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\n    if (db && (dx || dy)) {\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\n      da *= da;\n      db *= db;\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n      c.x = a.x + x * dx + y * dy;\n      c.y = a.y + x * dy - y * dx;\n    } else {\n      c.x = a.x + db;\n      c.y = a.y;\n    }\n  }\n  d3.layout.tree = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\n    function tree(d, i) {\n      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);\n      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\n      d3_layout_hierarchyVisitBefore(root1, secondWalk);\n      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {\n        var left = root0, right = root0, bottom = root0;\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n      return nodes;\n    }\n    function wrapTree(root0) {\n      var root1 = {\n        A: null,\n        children: [ root0 ]\n      }, queue = [ root1 ], node1;\n      while ((node1 = queue.pop()) != null) {\n        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\n          queue.push((children[i] = child = {\n            _: children[i],\n            parent: node1,\n            children: (child = children[i].children) && child.slice() || [],\n            A: null,\n            a: null,\n            z: 0,\n            m: 0,\n            c: 0,\n            s: 0,\n            t: null,\n            i: i\n          }).a = child);\n        }\n      }\n      return root1.children[0];\n    }\n    function firstWalk(v) {\n      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n      if (children.length) {\n        d3_layout_treeShift(v);\n        var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n        if (w) {\n          v.z = w.z + separation(v._, w._);\n          v.m = v.z - midpoint;\n        } else {\n          v.z = midpoint;\n        }\n      } else if (w) {\n        v.z = w.z + separation(v._, w._);\n      }\n      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n    }\n    function secondWalk(v) {\n      v._.x = v.z + v.parent.m;\n      v.m += v.parent.m;\n    }\n    function apportion(v, w, ancestor) {\n      if (w) {\n        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop.a = v;\n          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim.m;\n          sip += vip.m;\n          som += vom.m;\n          sop += vop.m;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop.t = vim;\n          vop.m += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom.t = vip;\n          vom.m += sip - som;\n          ancestor = v;\n        }\n      }\n      return ancestor;\n    }\n    function sizeNode(node) {\n      node.x *= size[0];\n      node.y = node.depth * size[1];\n    }\n    tree.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return tree;\n    };\n    tree.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null ? sizeNode : null;\n      return tree;\n    };\n    tree.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) == null ? null : sizeNode;\n      return tree;\n    };\n    return d3_layout_hierarchyRebind(tree, hierarchy);\n  };\n  function d3_layout_treeSeparation(a, b) {\n    return a.parent == b.parent ? 1 : 2;\n  }\n  function d3_layout_treeLeft(v) {\n    var children = v.children;\n    return children.length ? children[0] : v.t;\n  }\n  function d3_layout_treeRight(v) {\n    var children = v.children, n;\n    return (n = children.length) ? children[n - 1] : v.t;\n  }\n  function d3_layout_treeMove(wm, wp, shift) {\n    var change = shift / (wp.i - wm.i);\n    wp.c -= change;\n    wp.s += shift;\n    wm.c += change;\n    wp.z += shift;\n    wp.m += shift;\n  }\n  function d3_layout_treeShift(v) {\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\n    while (--i >= 0) {\n      w = children[i];\n      w.z += shift;\n      w.m += shift;\n      shift += w.s + (change += w.c);\n    }\n  }\n  function d3_layout_treeAncestor(vim, v, ancestor) {\n    return vim.a.parent === v.parent ? vim.a : ancestor;\n  }\n  d3.layout.cluster = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\n    function cluster(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var children = node.children;\n        if (children && children.length) {\n          node.x = d3_layout_clusterX(children);\n          node.y = d3_layout_clusterY(children);\n        } else {\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\n          node.y = 0;\n          previousNode = node;\n        }\n      });\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {\n        node.x = (node.x - root.x) * size[0];\n        node.y = (root.y - node.y) * size[1];\n      } : function(node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n      });\n      return nodes;\n    }\n    cluster.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return cluster;\n    };\n    cluster.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null;\n      return cluster;\n    };\n    cluster.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) != null;\n      return cluster;\n    };\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\n  };\n  function d3_layout_clusterY(children) {\n    return 1 + d3.max(children, function(child) {\n      return child.y;\n    });\n  }\n  function d3_layout_clusterX(children) {\n    return children.reduce(function(x, child) {\n      return x + child.x;\n    }, 0) / children.length;\n  }\n  function d3_layout_clusterLeft(node) {\n    var children = node.children;\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n  }\n  function d3_layout_clusterRight(node) {\n    var children = node.children, n;\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n  }\n  d3.layout.treemap = function() {\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \"squarify\", ratio = .5 * (1 + Math.sqrt(5));\n    function scale(children, k) {\n      var i = -1, n = children.length, child, area;\n      while (++i < n) {\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\n      }\n    }\n    function squarify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \"slice\" ? rect.dx : mode === \"dice\" ? rect.dy : mode === \"slice-dice\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while ((n = remaining.length) > 0) {\n          row.push(child = remaining[n - 1]);\n          row.area += child.area;\n          if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\n            remaining.pop();\n            best = score;\n          } else {\n            row.area -= row.pop().area;\n            position(row, u, rect, false);\n            u = Math.min(rect.dx, rect.dy);\n            row.length = row.area = 0;\n            best = Infinity;\n          }\n        }\n        if (row.length) {\n          position(row, u, rect, true);\n          row.length = row.area = 0;\n        }\n        children.forEach(squarify);\n      }\n    }\n    function stickify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), remaining = children.slice(), child, row = [];\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while (child = remaining.pop()) {\n          row.push(child);\n          row.area += child.area;\n          if (child.z != null) {\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n            row.length = row.area = 0;\n          }\n        }\n        children.forEach(stickify);\n      }\n    }\n    function worst(row, u) {\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\n      while (++i < n) {\n        if (!(r = row[i].area)) continue;\n        if (r < rmin) rmin = r;\n        if (r > rmax) rmax = r;\n      }\n      s *= s;\n      u *= u;\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n    }\n    function position(row, u, rect, flush) {\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\n      if (u == rect.dx) {\n        if (flush || v > rect.dy) v = rect.dy;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dy = v;\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n        }\n        o.z = true;\n        o.dx += rect.x + rect.dx - x;\n        rect.y += v;\n        rect.dy -= v;\n      } else {\n        if (flush || v > rect.dx) v = rect.dx;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dx = v;\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n        }\n        o.z = false;\n        o.dy += rect.y + rect.dy - y;\n        rect.x += v;\n        rect.dx -= v;\n      }\n    }\n    function treemap(d) {\n      var nodes = stickies || hierarchy(d), root = nodes[0];\n      root.x = root.y = 0;\n      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\n      if (stickies) hierarchy.revalue(root);\n      scale([ root ], root.dx * root.dy / root.value);\n      (stickies ? stickify : squarify)(root);\n      if (sticky) stickies = nodes;\n      return nodes;\n    }\n    treemap.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return treemap;\n    };\n    treemap.padding = function(x) {\n      if (!arguments.length) return padding;\n      function padFunction(node) {\n        var p = x.call(treemap, node, node.depth);\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [ p, p, p, p ] : p);\n      }\n      function padConstant(node) {\n        return d3_layout_treemapPad(node, x);\n      }\n      var type;\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [ x, x, x, x ], \n      padConstant) : padConstant;\n      return treemap;\n    };\n    treemap.round = function(x) {\n      if (!arguments.length) return round != Number;\n      round = x ? Math.round : Number;\n      return treemap;\n    };\n    treemap.sticky = function(x) {\n      if (!arguments.length) return sticky;\n      sticky = x;\n      stickies = null;\n      return treemap;\n    };\n    treemap.ratio = function(x) {\n      if (!arguments.length) return ratio;\n      ratio = x;\n      return treemap;\n    };\n    treemap.mode = function(x) {\n      if (!arguments.length) return mode;\n      mode = x + \"\";\n      return treemap;\n    };\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\n  };\n  function d3_layout_treemapPadNull(node) {\n    return {\n      x: node.x,\n      y: node.y,\n      dx: node.dx,\n      dy: node.dy\n    };\n  }\n  function d3_layout_treemapPad(node, padding) {\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\n    if (dx < 0) {\n      x += dx / 2;\n      dx = 0;\n    }\n    if (dy < 0) {\n      y += dy / 2;\n      dy = 0;\n    }\n    return {\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy\n    };\n  }\n  d3.random = {\n    normal: function(µ, σ) {\n      var n = arguments.length;\n      if (n < 2) σ = 1;\n      if (n < 1) µ = 0;\n      return function() {\n        var x, y, r;\n        do {\n          x = Math.random() * 2 - 1;\n          y = Math.random() * 2 - 1;\n          r = x * x + y * y;\n        } while (!r || r > 1);\n        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\n      };\n    },\n    logNormal: function() {\n      var random = d3.random.normal.apply(d3, arguments);\n      return function() {\n        return Math.exp(random());\n      };\n    },\n    bates: function(m) {\n      var random = d3.random.irwinHall(m);\n      return function() {\n        return random() / m;\n      };\n    },\n    irwinHall: function(m) {\n      return function() {\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\n        return s;\n      };\n    }\n  };\n  d3.scale = {};\n  function d3_scaleExtent(domain) {\n    var start = domain[0], stop = domain[domain.length - 1];\n    return start < stop ? [ start, stop ] : [ stop, start ];\n  }\n  function d3_scaleRange(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n  }\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\n    return function(x) {\n      return i(u(x));\n    };\n  }\n  function d3_scale_nice(domain, nice) {\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\n    if (x1 < x0) {\n      dx = i0, i0 = i1, i1 = dx;\n      dx = x0, x0 = x1, x1 = dx;\n    }\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n    return domain;\n  }\n  function d3_scale_niceStep(step) {\n    return step ? {\n      floor: function(x) {\n        return Math.floor(x / step) * step;\n      },\n      ceil: function(x) {\n        return Math.ceil(x / step) * step;\n      }\n    } : d3_scale_niceIdentity;\n  }\n  var d3_scale_niceIdentity = {\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\n    if (domain[k] < domain[0]) {\n      domain = domain.slice().reverse();\n      range = range.slice().reverse();\n    }\n    while (++j <= k) {\n      u.push(uninterpolate(domain[j - 1], domain[j]));\n      i.push(interpolate(range[j - 1], range[j]));\n    }\n    return function(x) {\n      var j = d3.bisect(domain, x, 1, k) - 1;\n      return i[j](u[j](x));\n    };\n  }\n  d3.scale.linear = function() {\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);\n  };\n  function d3_scale_linear(domain, range, interpolate, clamp) {\n    var output, input;\n    function rescale() {\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n      output = linear(domain, range, uninterpolate, interpolate);\n      input = linear(range, domain, uninterpolate, d3_interpolate);\n      return scale;\n    }\n    function scale(x) {\n      return output(x);\n    }\n    scale.invert = function(y) {\n      return input(y);\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(Number);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.rangeRound = function(x) {\n      return scale.range(x).interpolate(d3_interpolateRound);\n    };\n    scale.clamp = function(x) {\n      if (!arguments.length) return clamp;\n      clamp = x;\n      return rescale();\n    };\n    scale.interpolate = function(x) {\n      if (!arguments.length) return interpolate;\n      interpolate = x;\n      return rescale();\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      d3_scale_linearNice(domain, m);\n      return rescale();\n    };\n    scale.copy = function() {\n      return d3_scale_linear(domain, range, interpolate, clamp);\n    };\n    return rescale();\n  }\n  function d3_scale_linearRebind(scale, linear) {\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n  }\n  function d3_scale_linearNice(domain, m) {\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    return domain;\n  }\n  function d3_scale_linearTickRange(domain, m) {\n    if (m == null) m = 10;\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\n    extent[0] = Math.ceil(extent[0] / step) * step;\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n    extent[2] = step;\n    return extent;\n  }\n  function d3_scale_linearTicks(domain, m) {\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n  }\n  function d3_scale_linearTickFormat(domain, m, format) {\n    var range = d3_scale_linearTickRange(domain, m);\n    if (format) {\n      var match = d3_format_re.exec(format);\n      match.shift();\n      if (match[8] === \"s\") {\n        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\n        if (!match[7]) match[7] = \".\" + d3_scale_linearPrecision(prefix.scale(range[2]));\n        match[8] = \"f\";\n        format = d3.format(match.join(\"\"));\n        return function(d) {\n          return format(prefix.scale(d)) + prefix.symbol;\n        };\n      }\n      if (!match[7]) match[7] = \".\" + d3_scale_linearFormatPrecision(match[8], range);\n      format = match.join(\"\");\n    } else {\n      format = \",.\" + d3_scale_linearPrecision(range[2]) + \"f\";\n    }\n    return d3.format(format);\n  }\n  var d3_scale_linearFormatSignificant = {\n    s: 1,\n    g: 1,\n    p: 1,\n    r: 1,\n    e: 1\n  };\n  function d3_scale_linearPrecision(value) {\n    return -Math.floor(Math.log(value) / Math.LN10 + .01);\n  }\n  function d3_scale_linearFormatPrecision(type, range) {\n    var p = d3_scale_linearPrecision(range[2]);\n    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== \"e\") : p - (type === \"%\") * 2;\n  }\n  d3.scale.log = function() {\n    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);\n  };\n  function d3_scale_log(linear, base, positive, domain) {\n    function log(x) {\n      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\n    }\n    function pow(x) {\n      return positive ? Math.pow(base, x) : -Math.pow(base, -x);\n    }\n    function scale(x) {\n      return linear(log(x));\n    }\n    scale.invert = function(x) {\n      return pow(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      positive = x[0] >= 0;\n      linear.domain((domain = x.map(Number)).map(log));\n      return scale;\n    };\n    scale.base = function(_) {\n      if (!arguments.length) return base;\n      base = +_;\n      linear.domain(domain.map(log));\n      return scale;\n    };\n    scale.nice = function() {\n      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\n      linear.domain(niced);\n      domain = niced.map(pow);\n      return scale;\n    };\n    scale.ticks = function() {\n      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;\n      if (isFinite(j - i)) {\n        if (positive) {\n          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\n          ticks.push(pow(i));\n        } else {\n          ticks.push(pow(i));\n          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\n        }\n        for (i = 0; ticks[i] < u; i++) {}\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\n        ticks = ticks.slice(i, j);\n      }\n      return ticks;\n    };\n    scale.tickFormat = function(n, format) {\n      if (!arguments.length) return d3_scale_logFormat;\n      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== \"function\") format = d3.format(format);\n      var k = Math.max(1, base * n / scale.ticks().length);\n      return function(d) {\n        var i = d / pow(Math.round(log(d)));\n        if (i * base < base - .5) i *= base;\n        return i <= k ? format(d) : \"\";\n      };\n    };\n    scale.copy = function() {\n      return d3_scale_log(linear.copy(), base, positive, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  var d3_scale_logFormat = d3.format(\".0e\"), d3_scale_logNiceNegative = {\n    floor: function(x) {\n      return -Math.ceil(-x);\n    },\n    ceil: function(x) {\n      return -Math.floor(-x);\n    }\n  };\n  d3.scale.pow = function() {\n    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);\n  };\n  function d3_scale_pow(linear, exponent, domain) {\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\n    function scale(x) {\n      return linear(powp(x));\n    }\n    scale.invert = function(x) {\n      return powb(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      linear.domain((domain = x.map(Number)).map(powp));\n      return scale;\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      return scale.domain(d3_scale_linearNice(domain, m));\n    };\n    scale.exponent = function(x) {\n      if (!arguments.length) return exponent;\n      powp = d3_scale_powPow(exponent = x);\n      powb = d3_scale_powPow(1 / exponent);\n      linear.domain(domain.map(powp));\n      return scale;\n    };\n    scale.copy = function() {\n      return d3_scale_pow(linear.copy(), exponent, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_scale_powPow(e) {\n    return function(x) {\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n    };\n  }\n  d3.scale.sqrt = function() {\n    return d3.scale.pow().exponent(.5);\n  };\n  d3.scale.ordinal = function() {\n    return d3_scale_ordinal([], {\n      t: \"range\",\n      a: [ [] ]\n    });\n  };\n  function d3_scale_ordinal(domain, ranger) {\n    var index, range, rangeBand;\n    function scale(x) {\n      return range[((index.get(x) || (ranger.t === \"range\" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\n    }\n    function steps(start, step) {\n      return d3.range(domain.length).map(function(i) {\n        return start + step * i;\n      });\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = [];\n      index = new d3_Map();\n      var i = -1, n = x.length, xi;\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n      return scale[ranger.t].apply(scale, ranger.a);\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      rangeBand = 0;\n      ranger = {\n        t: \"range\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangePoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, \n      0) : (stop - start) / (domain.length - 1 + padding);\n      range = steps(start + step * padding / 2, step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangePoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundPoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), \n      0) : (stop - start) / (domain.length - 1 + padding) | 0;\n      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangeRoundPoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n      range = steps(start + step * outerPadding, step);\n      if (reverse) range.reverse();\n      rangeBand = step * (1 - padding);\n      ranger = {\n        t: \"rangeBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\n      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\n      if (reverse) range.reverse();\n      rangeBand = Math.round(step * (1 - padding));\n      ranger = {\n        t: \"rangeRoundBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBand = function() {\n      return rangeBand;\n    };\n    scale.rangeExtent = function() {\n      return d3_scaleExtent(ranger.a[0]);\n    };\n    scale.copy = function() {\n      return d3_scale_ordinal(domain, ranger);\n    };\n    return scale.domain(domain);\n  }\n  d3.scale.category10 = function() {\n    return d3.scale.ordinal().range(d3_category10);\n  };\n  d3.scale.category20 = function() {\n    return d3.scale.ordinal().range(d3_category20);\n  };\n  d3.scale.category20b = function() {\n    return d3.scale.ordinal().range(d3_category20b);\n  };\n  d3.scale.category20c = function() {\n    return d3.scale.ordinal().range(d3_category20c);\n  };\n  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);\n  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);\n  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);\n  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);\n  d3.scale.quantile = function() {\n    return d3_scale_quantile([], []);\n  };\n  function d3_scale_quantile(domain, range) {\n    var thresholds;\n    function rescale() {\n      var k = 0, q = range.length;\n      thresholds = [];\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n      return scale;\n    }\n    function scale(x) {\n      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.quantiles = function() {\n      return thresholds;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantile(domain, range);\n    };\n    return rescale();\n  }\n  d3.scale.quantize = function() {\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\n  };\n  function d3_scale_quantize(x0, x1, range) {\n    var kx, i;\n    function scale(x) {\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n    }\n    function rescale() {\n      kx = range.length / (x1 - x0);\n      i = range.length - 1;\n      return scale;\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return [ x0, x1 ];\n      x0 = +x[0];\n      x1 = +x[x.length - 1];\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      y = y < 0 ? NaN : y / kx + x0;\n      return [ y, y + 1 / kx ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantize(x0, x1, range);\n    };\n    return rescale();\n  }\n  d3.scale.threshold = function() {\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\n  };\n  function d3_scale_threshold(domain, range) {\n    function scale(x) {\n      if (x <= x) return range[d3.bisect(domain, x)];\n    }\n    scale.domain = function(_) {\n      if (!arguments.length) return domain;\n      domain = _;\n      return scale;\n    };\n    scale.range = function(_) {\n      if (!arguments.length) return range;\n      range = _;\n      return scale;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return [ domain[y - 1], domain[y] ];\n    };\n    scale.copy = function() {\n      return d3_scale_threshold(domain, range);\n    };\n    return scale;\n  }\n  d3.scale.identity = function() {\n    return d3_scale_identity([ 0, 1 ]);\n  };\n  function d3_scale_identity(domain) {\n    function identity(x) {\n      return +x;\n    }\n    identity.invert = identity;\n    identity.domain = identity.range = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(identity);\n      return identity;\n    };\n    identity.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    identity.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    identity.copy = function() {\n      return d3_scale_identity(domain);\n    };\n    return identity;\n  }\n  d3.svg = {};\n  function d3_zero() {\n    return 0;\n  }\n  d3.svg.arc = function() {\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\n    function arc() {\n      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;\n      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\n      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : \"\") + \"Z\";\n      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\n      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\n        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\n        if (!cw) p1 *= -1;\n        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\n        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\n      }\n      if (r1) {\n        x0 = r1 * Math.cos(a0 + p1);\n        y0 = r1 * Math.sin(a0 + p1);\n        x1 = r1 * Math.cos(a1 - p1);\n        y1 = r1 * Math.sin(a1 - p1);\n        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;\n        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\n          var h1 = (a0 + a1) / 2;\n          x0 = r1 * Math.cos(h1);\n          y0 = r1 * Math.sin(h1);\n          x1 = y1 = null;\n        }\n      } else {\n        x0 = y0 = 0;\n      }\n      if (r0) {\n        x2 = r0 * Math.cos(a1 - p0);\n        y2 = r0 * Math.sin(a1 - p0);\n        x3 = r0 * Math.cos(a0 + p0);\n        y3 = r0 * Math.sin(a0 + p0);\n        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;\n        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\n          var h0 = (a0 + a1) / 2;\n          x2 = r0 * Math.cos(h0);\n          y2 = r0 * Math.sin(h0);\n          x3 = y3 = null;\n        }\n      } else {\n        x2 = y2 = 0;\n      }\n      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\n        cr = r0 < r1 ^ cw ? 0 : 1;\n        var rc1 = rc, rc0 = rc;\n        if (da < π) {\n          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n        }\n        if (x1 != null) {\n          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);\n          if (rc === rc1) {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t30[1], \"A\", r1, \",\", r1, \" 0 \", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), \",\", cw, \" \", t12[1], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t12[0]);\n          } else {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 1,\", cr, \" \", t12[0]);\n          }\n        } else {\n          path.push(\"M\", x0, \",\", y0);\n        }\n        if (x3 != null) {\n          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);\n          if (rc === rc0) {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t21[1], \"A\", r0, \",\", r0, \" 0 \", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), \",\", 1 - cw, \" \", t03[1], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          } else {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          }\n        } else {\n          path.push(\"L\", x2, \",\", y2);\n        }\n      } else {\n        path.push(\"M\", x0, \",\", y0);\n        if (x1 != null) path.push(\"A\", r1, \",\", r1, \" 0 \", l1, \",\", cw, \" \", x1, \",\", y1);\n        path.push(\"L\", x2, \",\", y2);\n        if (x3 != null) path.push(\"A\", r0, \",\", r0, \" 0 \", l0, \",\", 1 - cw, \" \", x3, \",\", y3);\n      }\n      path.push(\"Z\");\n      return path.join(\"\");\n    }\n    function circleSegment(r1, cw) {\n      return \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + r1;\n    }\n    arc.innerRadius = function(v) {\n      if (!arguments.length) return innerRadius;\n      innerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.outerRadius = function(v) {\n      if (!arguments.length) return outerRadius;\n      outerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.cornerRadius = function(v) {\n      if (!arguments.length) return cornerRadius;\n      cornerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.padRadius = function(v) {\n      if (!arguments.length) return padRadius;\n      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\n      return arc;\n    };\n    arc.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return arc;\n    };\n    arc.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return arc;\n    };\n    arc.padAngle = function(v) {\n      if (!arguments.length) return padAngle;\n      padAngle = d3_functor(v);\n      return arc;\n    };\n    arc.centroid = function() {\n      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\n    };\n    return arc;\n  };\n  var d3_svg_arcAuto = \"auto\";\n  function d3_svg_arcInnerRadius(d) {\n    return d.innerRadius;\n  }\n  function d3_svg_arcOuterRadius(d) {\n    return d.outerRadius;\n  }\n  function d3_svg_arcStartAngle(d) {\n    return d.startAngle;\n  }\n  function d3_svg_arcEndAngle(d) {\n    return d.endAngle;\n  }\n  function d3_svg_arcPadAngle(d) {\n    return d && d.padAngle;\n  }\n  function d3_svg_arcSweep(x0, y0, x1, y1) {\n    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\n  }\n  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\n    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\n    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\n  }\n  function d3_svg_line(projection) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\n    function line(data) {\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points), tension));\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\n        } else if (points.length) {\n          segment();\n          points = [];\n        }\n      }\n      if (points.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    line.x = function(_) {\n      if (!arguments.length) return x;\n      x = _;\n      return line;\n    };\n    line.y = function(_) {\n      if (!arguments.length) return y;\n      y = _;\n      return line;\n    };\n    line.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return line;\n    };\n    line.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      return line;\n    };\n    line.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return line;\n    };\n    return line;\n  }\n  d3.svg.line = function() {\n    return d3_svg_line(d3_identity);\n  };\n  var d3_svg_lineInterpolators = d3.map({\n    linear: d3_svg_lineLinear,\n    \"linear-closed\": d3_svg_lineLinearClosed,\n    step: d3_svg_lineStep,\n    \"step-before\": d3_svg_lineStepBefore,\n    \"step-after\": d3_svg_lineStepAfter,\n    basis: d3_svg_lineBasis,\n    \"basis-open\": d3_svg_lineBasisOpen,\n    \"basis-closed\": d3_svg_lineBasisClosed,\n    bundle: d3_svg_lineBundle,\n    cardinal: d3_svg_lineCardinal,\n    \"cardinal-open\": d3_svg_lineCardinalOpen,\n    \"cardinal-closed\": d3_svg_lineCardinalClosed,\n    monotone: d3_svg_lineMonotone\n  });\n  d3_svg_lineInterpolators.forEach(function(key, value) {\n    value.key = key;\n    value.closed = /-closed$/.test(key);\n  });\n  function d3_svg_lineLinear(points) {\n    return points.length > 1 ? points.join(\"L\") : points + \"Z\";\n  }\n  function d3_svg_lineLinearClosed(points) {\n    return points.join(\"L\") + \"Z\";\n  }\n  function d3_svg_lineStep(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p[0] + (p = points[i])[0]) / 2, \"V\", p[1]);\n    if (n > 1) path.push(\"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepBefore(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepAfter(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineCardinalOpen(points, tension) {\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineCardinalClosed(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\n  }\n  function d3_svg_lineCardinal(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineHermite(points, tangents) {\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n      return d3_svg_lineLinear(points);\n    }\n    var quad = points.length != tangents.length, path = \"\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\n    if (quad) {\n      path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\n      p0 = points[1];\n      pi = 2;\n    }\n    if (tangents.length > 1) {\n      t = tangents[1];\n      p = points[pi];\n      pi++;\n      path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      for (var i = 2; i < tangents.length; i++, pi++) {\n        p = points[pi];\n        t = tangents[i];\n        path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      }\n    }\n    if (quad) {\n      var lp = points[pi];\n      path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\n    }\n    return path;\n  }\n  function d3_svg_lineCardinalTangents(points, tension) {\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\n    while (++i < n) {\n      p0 = p1;\n      p1 = p2;\n      p2 = points[i];\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineBasis(points) {\n    if (points.length < 3) return d3_svg_lineLinear(points);\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \",\", y0, \"L\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    points.push(points[n - 1]);\n    while (++i <= n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    points.pop();\n    path.push(\"L\", pi);\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisOpen(points) {\n    if (points.length < 4) return d3_svg_lineLinear(points);\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\n    while (++i < 3) {\n      pi = points[i];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n    --i;\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisClosed(points) {\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\n    while (++i < 4) {\n      pi = points[i % n];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    --i;\n    while (++i < m) {\n      pi = points[i % n];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBundle(points, tension) {\n    var n = points.length - 1;\n    if (n) {\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\n      while (++i <= n) {\n        p = points[i];\n        t = i / n;\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n      }\n    }\n    return d3_svg_lineBasis(points);\n  }\n  function d3_svg_lineDot4(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n  }\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\n  function d3_svg_lineBasisBezier(path, x, y) {\n    path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n  }\n  function d3_svg_lineSlope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n  function d3_svg_lineFiniteDifferences(points) {\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\n    while (++i < j) {\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n    }\n    m[i] = d;\n    return m;\n  }\n  function d3_svg_lineMonotoneTangents(points) {\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\n    while (++i < j) {\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\n      if (abs(d) < ε) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n    i = -1;\n    while (++i <= j) {\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n      tangents.push([ s || 0, m[i] * s || 0 ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineMonotone(points) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n  }\n  d3.svg.line.radial = function() {\n    var line = d3_svg_line(d3_svg_lineRadial);\n    line.radius = line.x, delete line.x;\n    line.angle = line.y, delete line.y;\n    return line;\n  };\n  function d3_svg_lineRadial(points) {\n    var point, i = -1, n = points.length, r, a;\n    while (++i < n) {\n      point = points[i];\n      r = point[0];\n      a = point[1] - halfπ;\n      point[0] = r * Math.cos(a);\n      point[1] = r * Math.sin(a);\n    }\n    return points;\n  }\n  function d3_svg_area(projection) {\n    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \"L\", tension = .7;\n    function area(data) {\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\n        return x;\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\n        return y;\n      } : d3_functor(y1), x, y;\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\n        } else if (points0.length) {\n          segment();\n          points0 = [];\n          points1 = [];\n        }\n      }\n      if (points0.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    area.x = function(_) {\n      if (!arguments.length) return x1;\n      x0 = x1 = _;\n      return area;\n    };\n    area.x0 = function(_) {\n      if (!arguments.length) return x0;\n      x0 = _;\n      return area;\n    };\n    area.x1 = function(_) {\n      if (!arguments.length) return x1;\n      x1 = _;\n      return area;\n    };\n    area.y = function(_) {\n      if (!arguments.length) return y1;\n      y0 = y1 = _;\n      return area;\n    };\n    area.y0 = function(_) {\n      if (!arguments.length) return y0;\n      y0 = _;\n      return area;\n    };\n    area.y1 = function(_) {\n      if (!arguments.length) return y1;\n      y1 = _;\n      return area;\n    };\n    area.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return area;\n    };\n    area.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      interpolateReverse = interpolate.reverse || interpolate;\n      L = interpolate.closed ? \"M\" : \"L\";\n      return area;\n    };\n    area.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return area;\n    };\n    return area;\n  }\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n  d3.svg.area = function() {\n    return d3_svg_area(d3_identity);\n  };\n  d3.svg.area.radial = function() {\n    var area = d3_svg_area(d3_svg_lineRadial);\n    area.radius = area.x, delete area.x;\n    area.innerRadius = area.x0, delete area.x0;\n    area.outerRadius = area.x1, delete area.x1;\n    area.angle = area.y, delete area.y;\n    area.startAngle = area.y0, delete area.y0;\n    area.endAngle = area.y1, delete area.y1;\n    return area;\n  };\n  d3.svg.chord = function() {\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\n    function chord(d, i) {\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\n      return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\n    }\n    function subgroup(self, f, d, i) {\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;\n      return {\n        r: r,\n        a0: a0,\n        a1: a1,\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\n      };\n    }\n    function equals(a, b) {\n      return a.a0 == b.a0 && a.a1 == b.a1;\n    }\n    function arc(r, p, a) {\n      return \"A\" + r + \",\" + r + \" 0 \" + +(a > π) + \",1 \" + p;\n    }\n    function curve(r0, p0, r1, p1) {\n      return \"Q 0,0 \" + p1;\n    }\n    chord.radius = function(v) {\n      if (!arguments.length) return radius;\n      radius = d3_functor(v);\n      return chord;\n    };\n    chord.source = function(v) {\n      if (!arguments.length) return source;\n      source = d3_functor(v);\n      return chord;\n    };\n    chord.target = function(v) {\n      if (!arguments.length) return target;\n      target = d3_functor(v);\n      return chord;\n    };\n    chord.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return chord;\n    };\n    chord.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return chord;\n    };\n    return chord;\n  };\n  function d3_svg_chordRadius(d) {\n    return d.radius;\n  }\n  d3.svg.diagonal = function() {\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\n    function diagonal(d, i) {\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\n        x: p0.x,\n        y: m\n      }, {\n        x: p3.x,\n        y: m\n      }, p3 ];\n      p = p.map(projection);\n      return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n    }\n    diagonal.source = function(x) {\n      if (!arguments.length) return source;\n      source = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.target = function(x) {\n      if (!arguments.length) return target;\n      target = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.projection = function(x) {\n      if (!arguments.length) return projection;\n      projection = x;\n      return diagonal;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalProjection(d) {\n    return [ d.x, d.y ];\n  }\n  d3.svg.diagonal.radial = function() {\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\n    diagonal.projection = function(x) {\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalRadialProjection(projection) {\n    return function() {\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;\n      return [ r * Math.cos(a), r * Math.sin(a) ];\n    };\n  }\n  d3.svg.symbol = function() {\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\n    function symbol(d, i) {\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n    }\n    symbol.type = function(x) {\n      if (!arguments.length) return type;\n      type = d3_functor(x);\n      return symbol;\n    };\n    symbol.size = function(x) {\n      if (!arguments.length) return size;\n      size = d3_functor(x);\n      return symbol;\n    };\n    return symbol;\n  };\n  function d3_svg_symbolSize() {\n    return 64;\n  }\n  function d3_svg_symbolType() {\n    return \"circle\";\n  }\n  function d3_svg_symbolCircle(size) {\n    var r = Math.sqrt(size / π);\n    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n  }\n  var d3_svg_symbols = d3.map({\n    circle: d3_svg_symbolCircle,\n    cross: function(size) {\n      var r = Math.sqrt(size / 5) / 2;\n      return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n    },\n    diamond: function(size) {\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\n      return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\n    },\n    square: function(size) {\n      var r = Math.sqrt(size) / 2;\n      return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\n    },\n    \"triangle-down\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n    },\n    \"triangle-up\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n    }\n  });\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n  d3_selectionPrototype.transition = function(name) {\n    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\n      time: Date.now(),\n      ease: d3_ease_cubicInOut,\n      delay: 0,\n      duration: 250\n    };\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_selectionPrototype.interrupt = function(name) {\n    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\n  };\n  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\n  function d3_selection_interruptNS(ns) {\n    return function() {\n      var lock, activeId, active;\n      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        if (--lock.count) delete lock[activeId]; else delete this[ns];\n        lock.active += .5;\n        active.event && active.event.interrupt.call(this, this.__data__, active.index);\n      }\n    };\n  }\n  function d3_transition(groups, ns, id) {\n    d3_subclass(groups, d3_transitionPrototype);\n    groups.namespace = ns;\n    groups.id = id;\n    return groups;\n  }\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\n  d3.transition = function(selection, name) {\n    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\n  };\n  d3.transition.prototype = d3_transitionPrototype;\n  d3_transitionPrototype.select = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, ns, id, node[ns][id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.selectAll = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          transition = node[ns][id];\n          subnodes = selector.call(node, node.__data__, i, j);\n          subgroups.push(subgroup = []);\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_transition(subgroups, this.namespace, this.id);\n  };\n  d3_transitionPrototype.tween = function(name, tween) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function(node) {\n      node[ns][id].tween.remove(name);\n    } : function(node) {\n      node[ns][id].tween.set(name, tween);\n    });\n  };\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id, ns = groups.namespace;\n    return d3_selection_each(groups, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function(node) {\n      node[ns][id].tween.set(name, value);\n    }));\n  }\n  d3_transitionPrototype.attr = function(nameNS, value) {\n    if (arguments.length < 2) {\n      for (value in nameNS) this.attr(value, nameNS[value]);\n      return this;\n    }\n    var interpolate = nameNS == \"transform\" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrTween(b) {\n      return b == null ? attrNull : (b += \"\", function() {\n        var a = this.getAttribute(name), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttribute(name, i(t));\n        });\n      });\n    }\n    function attrTweenNS(b) {\n      return b == null ? attrNullNS : (b += \"\", function() {\n        var a = this.getAttributeNS(name.space, name.local), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      });\n    }\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function(t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function(t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.style(priority, name[priority], value);\n        return this;\n      }\n      priority = \"\";\n    }\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleString(b) {\n      return b == null ? styleNull : (b += \"\", function() {\n        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;\n        return a !== b && (i = d3_interpolate(a, b), function(t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      });\n    }\n    return d3_transition_tween(this, \"style.\" + name, value, styleString);\n  };\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\n    if (arguments.length < 3) priority = \"\";\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\n      return f && function(t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n    return this.tween(\"style.\" + name, styleTween);\n  };\n  d3_transitionPrototype.text = function(value) {\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\n  };\n  function d3_transition_text(b) {\n    if (b == null) b = \"\";\n    return function() {\n      this.textContent = b;\n    };\n  }\n  d3_transitionPrototype.remove = function() {\n    var ns = this.namespace;\n    return this.each(\"end.transition\", function() {\n      var p;\n      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n  d3_transitionPrototype.ease = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].ease;\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function(node) {\n      node[ns][id].ease = value;\n    });\n  };\n  d3_transitionPrototype.delay = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].delay;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].delay = +value.call(node, node.__data__, i, j);\n    } : (value = +value, function(node) {\n      node[ns][id].delay = value;\n    }));\n  };\n  d3_transitionPrototype.duration = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].duration;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n    } : (value = Math.max(1, value), function(node) {\n      node[ns][id].duration = value;\n    }));\n  };\n  d3_transitionPrototype.each = function(type, listener) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\n      try {\n        d3_transitionInheritId = id;\n        d3_selection_each(this, function(node, i, j) {\n          d3_transitionInherit = node[ns][id];\n          type.call(node, node.__data__, i, j);\n        });\n      } finally {\n        d3_transitionInherit = inherit;\n        d3_transitionInheritId = inheritId;\n      }\n    } else {\n      d3_selection_each(this, function(node) {\n        var transition = node[ns][id];\n        (transition.event || (transition.event = d3.dispatch(\"start\", \"end\", \"interrupt\"))).on(type, listener);\n      });\n    }\n    return this;\n  };\n  d3_transitionPrototype.transition = function() {\n    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = node[ns][id0];\n          d3_transitionNode(node, i, ns, id1, {\n            time: transition.time,\n            ease: transition.ease,\n            delay: transition.delay + transition.duration,\n            duration: transition.duration\n          });\n        }\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id1);\n  };\n  function d3_transitionNamespace(name) {\n    return name == null ? \"__transition__\" : \"__transition_\" + name + \"__\";\n  }\n  function d3_transitionNode(node, i, ns, id, inherit) {\n    var lock = node[ns] || (node[ns] = {\n      active: 0,\n      count: 0\n    }), transition = lock[id], time, timer, duration, ease, tweens;\n    function schedule(elapsed) {\n      var delay = transition.delay;\n      timer.t = delay + time;\n      if (delay <= elapsed) return start(elapsed - delay);\n      timer.c = start;\n    }\n    function start(elapsed) {\n      var activeId = lock.active, active = lock[activeId];\n      if (active) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        --lock.count;\n        delete lock[activeId];\n        active.event && active.event.interrupt.call(node, node.__data__, active.index);\n      }\n      for (var cancelId in lock) {\n        if (+cancelId < id) {\n          var cancel = lock[cancelId];\n          cancel.timer.c = null;\n          cancel.timer.t = NaN;\n          --lock.count;\n          delete lock[cancelId];\n        }\n      }\n      timer.c = tick;\n      d3_timer(function() {\n        if (timer.c && tick(elapsed || 1)) {\n          timer.c = null;\n          timer.t = NaN;\n        }\n        return 1;\n      }, 0, time);\n      lock.active = id;\n      transition.event && transition.event.start.call(node, node.__data__, i);\n      tweens = [];\n      transition.tween.forEach(function(key, value) {\n        if (value = value.call(node, node.__data__, i)) {\n          tweens.push(value);\n        }\n      });\n      ease = transition.ease;\n      duration = transition.duration;\n    }\n    function tick(elapsed) {\n      var t = elapsed / duration, e = ease(t), n = tweens.length;\n      while (n > 0) {\n        tweens[--n].call(node, e);\n      }\n      if (t >= 1) {\n        transition.event && transition.event.end.call(node, node.__data__, i);\n        if (--lock.count) delete lock[id]; else delete node[ns];\n        return 1;\n      }\n    }\n    if (!transition) {\n      time = inherit.time;\n      timer = d3_timer(schedule, 0, time);\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        time: time,\n        timer: timer,\n        delay: inherit.delay,\n        duration: inherit.duration,\n        ease: inherit.ease,\n        index: i\n      };\n      inherit = null;\n      ++lock.count;\n    }\n  }\n  d3.svg.axis = function() {\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\n    function axis(g) {\n      g.each(function() {\n        var g = d3.select(this);\n        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\n        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(\".tick\").data(ticks, scale1), tickEnter = tick.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", ε), tickExit = d3.transition(tick.exit()).style(\"opacity\", ε).remove(), tickUpdate = d3.transition(tick.order()).style(\"opacity\", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;\n        var range = d3_scaleRange(scale1), path = g.selectAll(\".domain\").data([ 0 ]), pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), \n        d3.transition(path));\n        tickEnter.append(\"line\");\n        tickEnter.append(\"text\");\n        var lineEnter = tickEnter.select(\"line\"), lineUpdate = tickUpdate.select(\"line\"), text = tick.select(\"text\").text(tickFormat), textEnter = tickEnter.select(\"text\"), textUpdate = tickUpdate.select(\"text\"), sign = orient === \"top\" || orient === \"left\" ? -1 : 1, x1, x2, y1, y2;\n        if (orient === \"bottom\" || orient === \"top\") {\n          tickTransform = d3_svg_axisX, x1 = \"x\", y1 = \"y\", x2 = \"x2\", y2 = \"y2\";\n          text.attr(\"dy\", sign < 0 ? \"0em\" : \".71em\").style(\"text-anchor\", \"middle\");\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + sign * outerTickSize + \"V0H\" + range[1] + \"V\" + sign * outerTickSize);\n        } else {\n          tickTransform = d3_svg_axisY, x1 = \"y\", y1 = \"x\", x2 = \"y2\", y2 = \"x2\";\n          text.attr(\"dy\", \".32em\").style(\"text-anchor\", sign < 0 ? \"end\" : \"start\");\n          pathUpdate.attr(\"d\", \"M\" + sign * outerTickSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + sign * outerTickSize);\n        }\n        lineEnter.attr(y2, sign * innerTickSize);\n        textEnter.attr(y1, sign * tickSpacing);\n        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\n        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\n        if (scale1.rangeBand) {\n          var x = scale1, dx = x.rangeBand() / 2;\n          scale0 = scale1 = function(d) {\n            return x(d) + dx;\n          };\n        } else if (scale0.rangeBand) {\n          scale0 = scale1;\n        } else {\n          tickExit.call(tickTransform, scale1, scale0);\n        }\n        tickEnter.call(tickTransform, scale0, scale1);\n        tickUpdate.call(tickTransform, scale1, scale1);\n      });\n    }\n    axis.scale = function(x) {\n      if (!arguments.length) return scale;\n      scale = x;\n      return axis;\n    };\n    axis.orient = function(x) {\n      if (!arguments.length) return orient;\n      orient = x in d3_svg_axisOrients ? x + \"\" : d3_svg_axisDefaultOrient;\n      return axis;\n    };\n    axis.ticks = function() {\n      if (!arguments.length) return tickArguments_;\n      tickArguments_ = d3_array(arguments);\n      return axis;\n    };\n    axis.tickValues = function(x) {\n      if (!arguments.length) return tickValues;\n      tickValues = x;\n      return axis;\n    };\n    axis.tickFormat = function(x) {\n      if (!arguments.length) return tickFormat_;\n      tickFormat_ = x;\n      return axis;\n    };\n    axis.tickSize = function(x) {\n      var n = arguments.length;\n      if (!n) return innerTickSize;\n      innerTickSize = +x;\n      outerTickSize = +arguments[n - 1];\n      return axis;\n    };\n    axis.innerTickSize = function(x) {\n      if (!arguments.length) return innerTickSize;\n      innerTickSize = +x;\n      return axis;\n    };\n    axis.outerTickSize = function(x) {\n      if (!arguments.length) return outerTickSize;\n      outerTickSize = +x;\n      return axis;\n    };\n    axis.tickPadding = function(x) {\n      if (!arguments.length) return tickPadding;\n      tickPadding = +x;\n      return axis;\n    };\n    axis.tickSubdivide = function() {\n      return arguments.length && axis;\n    };\n    return axis;\n  };\n  var d3_svg_axisDefaultOrient = \"bottom\", d3_svg_axisOrients = {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  };\n  function d3_svg_axisX(selection, x0, x1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = x0(d);\n      return \"translate(\" + (isFinite(v0) ? v0 : x1(d)) + \",0)\";\n    });\n  }\n  function d3_svg_axisY(selection, y0, y1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = y0(d);\n      return \"translate(0,\" + (isFinite(v0) ? v0 : y1(d)) + \")\";\n    });\n  }\n  d3.svg.brush = function() {\n    var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\n    function brush(g) {\n      g.each(function() {\n        var g = d3.select(this).style(\"pointer-events\", \"all\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\n        var background = g.selectAll(\".background\").data([ 0 ]);\n        background.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\n        g.selectAll(\".extent\").data([ 0 ]).enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\n        var resize = g.selectAll(\".resize\").data(resizes, d3_identity);\n        resize.exit().remove();\n        resize.enter().append(\"g\").attr(\"class\", function(d) {\n          return \"resize \" + d;\n        }).style(\"cursor\", function(d) {\n          return d3_svg_brushCursor[d];\n        }).append(\"rect\").attr(\"x\", function(d) {\n          return /[ew]$/.test(d) ? -3 : null;\n        }).attr(\"y\", function(d) {\n          return /^[ns]/.test(d) ? -3 : null;\n        }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\n        resize.style(\"display\", brush.empty() ? \"none\" : null);\n        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;\n        if (x) {\n          range = d3_scaleRange(x);\n          backgroundUpdate.attr(\"x\", range[0]).attr(\"width\", range[1] - range[0]);\n          redrawX(gUpdate);\n        }\n        if (y) {\n          range = d3_scaleRange(y);\n          backgroundUpdate.attr(\"y\", range[0]).attr(\"height\", range[1] - range[0]);\n          redrawY(gUpdate);\n        }\n        redraw(gUpdate);\n      });\n    }\n    brush.event = function(g) {\n      g.each(function() {\n        var event_ = event.of(this, arguments), extent1 = {\n          x: xExtent,\n          y: yExtent,\n          i: xExtentDomain,\n          j: yExtentDomain\n        }, extent0 = this.__chart__ || extent1;\n        this.__chart__ = extent1;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.brush\", function() {\n            xExtentDomain = extent0.i;\n            yExtentDomain = extent0.j;\n            xExtent = extent0.x;\n            yExtent = extent0.y;\n            event_({\n              type: \"brushstart\"\n            });\n          }).tween(\"brush:brush\", function() {\n            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);\n            xExtentDomain = yExtentDomain = null;\n            return function(t) {\n              xExtent = extent1.x = xi(t);\n              yExtent = extent1.y = yi(t);\n              event_({\n                type: \"brush\",\n                mode: \"resize\"\n              });\n            };\n          }).each(\"end.brush\", function() {\n            xExtentDomain = extent1.i;\n            yExtentDomain = extent1.j;\n            event_({\n              type: \"brush\",\n              mode: \"resize\"\n            });\n            event_({\n              type: \"brushend\"\n            });\n          });\n        } else {\n          event_({\n            type: \"brushstart\"\n          });\n          event_({\n            type: \"brush\",\n            mode: \"resize\"\n          });\n          event_({\n            type: \"brushend\"\n          });\n        }\n      });\n    };\n    function redraw(g) {\n      g.selectAll(\".resize\").attr(\"transform\", function(d) {\n        return \"translate(\" + xExtent[+/e$/.test(d)] + \",\" + yExtent[+/^s/.test(d)] + \")\";\n      });\n    }\n    function redrawX(g) {\n      g.select(\".extent\").attr(\"x\", xExtent[0]);\n      g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", xExtent[1] - xExtent[0]);\n    }\n    function redrawY(g) {\n      g.select(\".extent\").attr(\"y\", yExtent[0]);\n      g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", yExtent[1] - yExtent[0]);\n    }\n    function brushstart() {\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed(\"extent\"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;\n      var w = d3.select(d3_window(target)).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\n      if (d3.event.changedTouches) {\n        w.on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend);\n      } else {\n        w.on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend);\n      }\n      g.interrupt().selectAll(\"*\").interrupt();\n      if (dragging) {\n        origin[0] = xExtent[0] - origin[0];\n        origin[1] = yExtent[0] - origin[1];\n      } else if (resizing) {\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\n        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\n        origin[0] = xExtent[ex];\n        origin[1] = yExtent[ey];\n      } else if (d3.event.altKey) center = origin.slice();\n      g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n      d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n      event_({\n        type: \"brushstart\"\n      });\n      brushmove();\n      function keydown() {\n        if (d3.event.keyCode == 32) {\n          if (!dragging) {\n            center = null;\n            origin[0] -= xExtent[1];\n            origin[1] -= yExtent[1];\n            dragging = 2;\n          }\n          d3_eventPreventDefault();\n        }\n      }\n      function keyup() {\n        if (d3.event.keyCode == 32 && dragging == 2) {\n          origin[0] += xExtent[1];\n          origin[1] += yExtent[1];\n          dragging = 0;\n          d3_eventPreventDefault();\n        }\n      }\n      function brushmove() {\n        var point = d3.mouse(target), moved = false;\n        if (offset) {\n          point[0] += offset[0];\n          point[1] += offset[1];\n        }\n        if (!dragging) {\n          if (d3.event.altKey) {\n            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];\n            origin[0] = xExtent[+(point[0] < center[0])];\n            origin[1] = yExtent[+(point[1] < center[1])];\n          } else center = null;\n        }\n        if (resizingX && move1(point, x, 0)) {\n          redrawX(g);\n          moved = true;\n        }\n        if (resizingY && move1(point, y, 1)) {\n          redrawY(g);\n          moved = true;\n        }\n        if (moved) {\n          redraw(g);\n          event_({\n            type: \"brush\",\n            mode: dragging ? \"move\" : \"resize\"\n          });\n        }\n      }\n      function move1(point, scale, i) {\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\n        if (dragging) {\n          r0 -= position;\n          r1 -= size + position;\n        }\n        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\n        if (dragging) {\n          max = (min += position) + size;\n        } else {\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n          if (position < min) {\n            max = min;\n            min = position;\n          } else {\n            max = position;\n          }\n        }\n        if (extent[0] != min || extent[1] != max) {\n          if (i) yExtentDomain = null; else xExtentDomain = null;\n          extent[0] = min;\n          extent[1] = max;\n          return true;\n        }\n      }\n      function brushend() {\n        brushmove();\n        g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n        d3.select(\"body\").style(\"cursor\", null);\n        w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\n        dragRestore();\n        event_({\n          type: \"brushend\"\n        });\n      }\n    }\n    brush.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.clamp = function(z) {\n      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\n      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;\n      return brush;\n    };\n    brush.extent = function(z) {\n      var x0, x1, y0, y1, t;\n      if (!arguments.length) {\n        if (x) {\n          if (xExtentDomain) {\n            x0 = xExtentDomain[0], x1 = xExtentDomain[1];\n          } else {\n            x0 = xExtent[0], x1 = xExtent[1];\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\n          }\n        }\n        if (y) {\n          if (yExtentDomain) {\n            y0 = yExtentDomain[0], y1 = yExtentDomain[1];\n          } else {\n            y0 = yExtent[0], y1 = yExtent[1];\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\n          }\n        }\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\n      }\n      if (x) {\n        x0 = z[0], x1 = z[1];\n        if (y) x0 = x0[0], x1 = x1[0];\n        xExtentDomain = [ x0, x1 ];\n        if (x.invert) x0 = x(x0), x1 = x(x1);\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];\n      }\n      if (y) {\n        y0 = z[0], y1 = z[1];\n        if (x) y0 = y0[1], y1 = y1[1];\n        yExtentDomain = [ y0, y1 ];\n        if (y.invert) y0 = y(y0), y1 = y(y1);\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];\n      }\n      return brush;\n    };\n    brush.clear = function() {\n      if (!brush.empty()) {\n        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\n        xExtentDomain = yExtentDomain = null;\n      }\n      return brush;\n    };\n    brush.empty = function() {\n      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\n    };\n    return d3.rebind(brush, event, \"on\");\n  };\n  var d3_svg_brushCursor = {\n    n: \"ns-resize\",\n    e: \"ew-resize\",\n    s: \"ns-resize\",\n    w: \"ew-resize\",\n    nw: \"nwse-resize\",\n    ne: \"nesw-resize\",\n    se: \"nwse-resize\",\n    sw: \"nesw-resize\"\n  };\n  var d3_svg_brushResizes = [ [ \"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\" ], [ \"e\", \"w\" ], [ \"n\", \"s\" ], [] ];\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n  var d3_time_formatUtc = d3_time_format.utc;\n  var d3_time_formatIso = d3_time_formatUtc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n  d3_time_format.iso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\") ? d3_time_formatIsoNative : d3_time_formatIso;\n  function d3_time_formatIsoNative(date) {\n    return date.toISOString();\n  }\n  d3_time_formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n  d3_time.second = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 1e3) * 1e3);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n  }, function(date) {\n    return date.getSeconds();\n  });\n  d3_time.seconds = d3_time.second.range;\n  d3_time.seconds.utc = d3_time.second.utc.range;\n  d3_time.minute = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 6e4) * 6e4);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n  }, function(date) {\n    return date.getMinutes();\n  });\n  d3_time.minutes = d3_time.minute.range;\n  d3_time.minutes.utc = d3_time.minute.utc.range;\n  d3_time.hour = d3_time_interval(function(date) {\n    var timezone = date.getTimezoneOffset() / 60;\n    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n  }, function(date) {\n    return date.getHours();\n  });\n  d3_time.hours = d3_time.hour.range;\n  d3_time.hours.utc = d3_time.hour.utc.range;\n  d3_time.month = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setDate(1);\n    return date;\n  }, function(date, offset) {\n    date.setMonth(date.getMonth() + offset);\n  }, function(date) {\n    return date.getMonth();\n  });\n  d3_time.months = d3_time.month.range;\n  d3_time.months.utc = d3_time.month.utc.range;\n  function d3_time_scale(linear, methods, format) {\n    function scale(x) {\n      return linear(x);\n    }\n    scale.invert = function(x) {\n      return d3_time_scaleDate(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n      linear.domain(x);\n      return scale;\n    };\n    function tickMethod(extent, count) {\n      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);\n      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {\n        return d / 31536e6;\n      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\n    }\n    scale.nice = function(interval, skip) {\n      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" && tickMethod(extent, interval);\n      if (method) interval = method[0], skip = method[1];\n      function skipped(date) {\n        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\n      }\n      return scale.domain(d3_scale_nice(domain, skip > 1 ? {\n        floor: function(date) {\n          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\n          return date;\n        },\n        ceil: function(date) {\n          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\n          return date;\n        }\n      } : interval));\n    };\n    scale.ticks = function(interval, skip) {\n      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" ? tickMethod(extent, interval) : !interval.range && [ {\n        range: interval\n      }, skip ];\n      if (method) interval = method[0], skip = method[1];\n      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\n    };\n    scale.tickFormat = function() {\n      return format;\n    };\n    scale.copy = function() {\n      return d3_time_scale(linear.copy(), methods, format);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_time_scaleDate(t) {\n    return new Date(t);\n  }\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\n  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\n  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ \".%L\", function(d) {\n    return d.getMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getDay() && d.getDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  var d3_time_scaleMilliseconds = {\n    range: function(start, stop, step) {\n      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\n    },\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  d3_time_scaleLocalMethods.year = d3_time.year;\n  d3_time.scale = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n  };\n  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {\n    return [ m[0].utc, m[1] ];\n  });\n  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ \".%L\", function(d) {\n    return d.getUTCMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getUTCSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getUTCMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getUTCHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getUTCDay() && d.getUTCDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getUTCDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getUTCMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  d3_time_scaleUtcMethods.year = d3_time.year.utc;\n  d3_time.scale.utc = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\n  };\n  d3.text = d3_xhrType(function(request) {\n    return request.responseText;\n  });\n  d3.json = function(url, callback) {\n    return d3_xhr(url, \"application/json\", d3_json, callback);\n  };\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n  d3.html = function(url, callback) {\n    return d3_xhr(url, \"text/html\", d3_html, callback);\n  };\n  function d3_html(request) {\n    var range = d3_document.createRange();\n    range.selectNode(d3_document.body);\n    return range.createContextualFragment(request.responseText);\n  }\n  d3.xml = d3_xhrType(function(request) {\n    return request.responseXML;\n  });\n  if (typeof define === \"function\" && define.amd) this.d3 = d3, define(d3); else if (typeof module === \"object\" && module.exports) module.exports = d3; else this.d3 = d3;\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/d3/d3.js\n// module id = 271\n// module chunks = 0 1","module.exports = require(\"./crossfilter\").crossfilter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/dc/node_modules/crossfilter2/index.js\n// module id = 272\n// module chunks = 0 1","(function(exports){\ncrossfilter.version = \"1.3.14\";\nfunction crossfilter_identity(d) {\n  return d;\n}\ncrossfilter.permute = permute;\n\nfunction permute(array, index) {\n  for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\nvar bisect = crossfilter.bisect = bisect_by(crossfilter_identity);\n\nbisect.by = bisect_by;\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\nvar heap = crossfilter.heap = heap_by(crossfilter_identity);\n\nheap.by = heap_by;\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\nvar heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);\n\nheapselect.by = heapselect_by;\n\nfunction heapselect_by(f) {\n  var heap = heap_by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        x,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (x = f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\nvar insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);\n\ninsertionsort.by = insertionsort_by;\n\nfunction insertionsort_by(f) {\n\n  function insertionsort(a, lo, hi) {\n    for (var i = lo + 1; i < hi; ++i) {\n      for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {\n        a[j] = a[j - 1];\n      }\n      a[j] = t;\n    }\n    return a;\n  }\n\n  return insertionsort;\n}\n// Algorithm designed by Vladimir Yaroslavskiy.\n// Implementation based on the Dart project; see lib/dart/LICENSE for details.\n\nvar quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);\n\nquicksort.by = quicksort_by;\n\nfunction quicksort_by(f) {\n  var insertionsort = insertionsort_by(f);\n\n  function sort(a, lo, hi) {\n    return (hi - lo < quicksort_sizeThreshold\n        ? insertionsort\n        : quicksort)(a, lo, hi);\n  }\n\n  function quicksort(a, lo, hi) {\n    // Compute the two pivots by looking at 5 elements.\n    var sixth = (hi - lo) / 6 | 0,\n        i1 = lo + sixth,\n        i5 = hi - 1 - sixth,\n        i3 = lo + hi - 1 >> 1,  // The midpoint.\n        i2 = i3 - sixth,\n        i4 = i3 + sixth;\n\n    var e1 = a[i1], x1 = f(e1),\n        e2 = a[i2], x2 = f(e2),\n        e3 = a[i3], x3 = f(e3),\n        e4 = a[i4], x4 = f(e4),\n        e5 = a[i5], x5 = f(e5);\n\n    var t;\n\n    // Sort the selected 5 elements using a sorting network.\n    if (x1 > x2) t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n    if (x1 > x3) t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x1 > x4) t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;\n    if (x3 > x4) t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;\n    if (x2 > x5) t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;\n    if (x2 > x3) t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;\n    if (x4 > x5) t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;\n\n    var pivot1 = e2, pivotValue1 = x2,\n        pivot2 = e4, pivotValue2 = x4;\n\n    // e2 and e4 have been saved in the pivot variables. They will be written\n    // back, once the partitioning is finished.\n    a[i1] = e1;\n    a[i2] = a[lo];\n    a[i3] = e3;\n    a[i4] = a[hi - 1];\n    a[i5] = e5;\n\n    var less = lo + 1,   // First element in the middle partition.\n        great = hi - 2;  // Last element in the middle partition.\n\n    // Note that for value comparison, <, <=, >= and > coerce to a primitive via\n    // Object.prototype.valueOf; == and === do not, so in order to be consistent\n    // with natural order (such as for Date objects), we must do two compares.\n    var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;\n    if (pivotsEqual) {\n\n      // Degenerated case where the partitioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (var k = less; k <= great; ++k) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else if (xk > pivotValue1) {\n\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ek:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          while (true) {\n            var greatValue = f(a[great]);\n            if (greatValue > pivotValue1) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (greatValue < pivotValue1) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ek;\n              break;\n            } else {\n              a[k] = a[great];\n              a[great--] = ek;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk < pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          ++less;\n        } else {\n          if (xk > pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue > pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[lo] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[hi - 1] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don't include the pivot values.)\n    sort(a, lo, less - 1);\n    sort(a, great + 2, hi);\n\n    if (pivotsEqual) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return a;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < i1 && great > i5) {\n      var lessValue, greatValue;\n      while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1) ++less;\n      while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2) --great;\n\n      // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (var k = less; k <= great; k++) {\n        var ek = a[k], xk = f(ek);\n        if (xk <= pivotValue1 && xk >= pivotValue1) {\n          if (k !== less) {\n            a[k] = a[less];\n            a[less] = ek;\n          }\n          less++;\n        } else {\n          if (xk <= pivotValue2 && xk >= pivotValue2) {\n            while (true) {\n              var greatValue = f(a[great]);\n              if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                if (greatValue < pivotValue1) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ek;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ek;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // The second partition has now been cleared of pivot elements and looks\n    // as follows:\n    // [  *  |  > pivot1 && < pivot2  | * ]\n    //        ^                      ^\n    //       less                  great\n    // Sort the second partition using recursive descent.\n\n    // The second partition looks as follows:\n    // [  *  |  >= pivot1 && <= pivot2  | * ]\n    //        ^                        ^\n    //       less                    great\n    // Simply sort it by recursive descent.\n\n    return sort(a, less, great + 1);\n  }\n\n  return sort;\n}\n\nvar quicksort_sizeThreshold = 32;\nvar crossfilter_array8 = crossfilter_arrayUntyped,\n    crossfilter_array16 = crossfilter_arrayUntyped,\n    crossfilter_array32 = crossfilter_arrayUntyped,\n    crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped,\n    crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;\n\nif (typeof Uint8Array !== \"undefined\") {\n  crossfilter_array8 = function(n) { return new Uint8Array(n); };\n  crossfilter_array16 = function(n) { return new Uint16Array(n); };\n  crossfilter_array32 = function(n) { return new Uint32Array(n); };\n\n  crossfilter_arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  crossfilter_arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = crossfilter_array16(array.length); break;\n      case 32: copy = crossfilter_array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction crossfilter_arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction crossfilter_arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\nfunction crossfilter_filterExact(bisect, value) {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nfunction crossfilter_filterRange(bisect, range) {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nfunction crossfilter_filterAll(values) {\n  return [0, values.length];\n}\nfunction crossfilter_null() {\n  return null;\n}\nfunction crossfilter_zero() {\n  return 0;\n}\nfunction crossfilter_reduceIncrement(p) {\n  return p + 1;\n}\n\nfunction crossfilter_reduceDecrement(p) {\n  return p - 1;\n}\n\nfunction crossfilter_reduceAdd(f) {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nfunction crossfilter_reduceSubtract(f) {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\nexports.crossfilter = crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      m = 0, // a bit mask representing which dimensions are in use\n      M = 8, // number of dimensions that can fit in `filters`\n      filters = crossfilter_array8(0), // M bits per record; 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = []; // when data is removed\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters = crossfilter_arrayLengthen(filters, n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters.\n  function removeData() {\n    var newIndex = crossfilter_index(n, n),\n        removed = [];\n    for (var i = 0, j = 0; i < n; ++i) {\n      if (filters[i]) newIndex[i] = j++;\n      else removed.push(i);\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(0, [], removed); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var i = 0, j = 0, k; i < n; ++i) {\n      if (k = filters[i]) {\n        if (i !== j) filters[j] = k, data[j] = data[i];\n        ++j;\n      }\n    }\n    data.length = j;\n    while (n > j) filters[--n] = 0;\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value) {\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var one = ~m & -~m, // lowest unset bit as mask, e.g., 00001000\n        zero = ~one, // inverted one, e.g., 11110111\n        values, // sorted, cached array\n        index, // value rank ↦ object id\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        sort = quicksort_by(function(i) { return newValues[i]; }),\n        refilter = crossfilter_filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Incorporate any existing data into this dimension, and make sure that the\n    // filter bitset is wide enough to handle the new dimension.\n    m |= one;\n    if (M >= 32 ? !one : m & -(1 << M)) {\n      filters = crossfilter_arrayWiden(filters, M <<= 1);\n    }\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n\n      // Permute new values into natural order using a sorted index.\n      newValues = newData.map(value);\n      newIndex = sort(crossfilter_range(n1), 0, n1);\n      newValues = permute(newValues, newIndex);\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1], i;\n      if (refilterFunction) {\n        for (i = 0; i < n1; ++i) {\n          if (!refilterFunction(newValues[i], i)) filters[newIndex[i] + n0] |= one;\n        }\n      } else {\n        for (i = 0; i < lo1; ++i) filters[newIndex[i] + n0] |= one;\n        for (i = hi1; i < n1; ++i) filters[newIndex[i] + n0] |= one;\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n      var oldValues = values,\n          oldIndex = index,\n          i0 = 0,\n          i1 = 0;\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = new Array(n);\n      index = crossfilter_index(n, n);\n\n      // Merge the old and new sorted values, and old and new index.\n      for (i = 0; i0 < n0 && i1 < n1; ++i) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[i] = oldValues[i0];\n          index[i] = oldIndex[i0++];\n        } else {\n          values[i] = newValues[i1];\n          index[i] = newIndex[i1++] + n0;\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++i) {\n        values[i] = oldValues[i0];\n        index[i] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++i) {\n        values[i] = newValues[i1];\n        index[i] = newIndex[i1] + n0;\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      for (var i = 0, j = 0, k; i < n; ++i) {\n        if (filters[k = index[i]]) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[k];\n          ++j;\n        }\n      }\n      values.length = j;\n      while (j < n) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; });\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [];\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          added.push(k);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          filters[k = index[i]] ^= one;\n          removed.push(k);\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, added, removed); });\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      return filterIndexBounds((refilter = crossfilter_filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      refilter = crossfilter_filterAll;\n\n      filterIndexFunction(refilterFunction = f);\n\n      lo0 = 0;\n      hi0 = n;\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [];\n\n      for (i = 0; i < n; ++i) {\n        if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n          if (x) filters[k] &= zero, added.push(k);\n          else filters[k] |= one, removed.push(k);\n        }\n      }\n      filterListeners.forEach(function(l) { l(one, added, removed); });\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k) {\n      var array = [],\n          i = hi0,\n          j;\n\n      while (--i >= lo0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k) {\n      var array = [],\n          i = lo0,\n          j;\n\n      while (i < hi0 && k > 0) {\n        if (!filters[j = index[i]]) {\n          array.push(data[j]);\n          --k;\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = crossfilter_capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = crossfilter_null,\n          reset = crossfilter_null,\n          resetNeeded = true,\n          groupAll = key === crossfilter_null;\n\n      if (arguments.length < 1) key = crossfilter_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n        var oldGroups = groups,\n            reIndex = crossfilter_index(k, groupCapacity),\n            add = reduceAdd,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = crossfilter_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            if (g0 = oldGroups[++i0]) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n          while (!(x1 > x)) {\n            groupIndex[j = newIndex[i1] + n0] = k;\n            if (!(filters[j] & zero)) g.value = add(g.value, data[j]);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater than all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if (k > i0) for (i0 = 0; i0 < n0; ++i0) {\n          groupIndex[i0] = reIndex[groupIndex[i0]];\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = crossfilter_null;\n            reset = crossfilter_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if (++k === groupCapacity) {\n            reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);\n            groupCapacity = crossfilter_capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData() {\n        if (k > 1) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = crossfilter_index(oldK, oldK);\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          for (var i = 0, j = 0; i < n; ++i) {\n            if (filters[i]) {\n              seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n              ++j;\n            }\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1) {\n            // Reindex the group index using seenGroups to find the new index.\n            for (var i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = crossfilter_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var i = 0; i < n; ++i) if (filters[i]) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = crossfilter_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      function updateMany(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g;\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      function updateOne(filterOne, added, removed) {\n        if (filterOne === one || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (!(filters[k = added[i]] & zero)) {\n            g.value = reduceAdd(g.value, data[k]);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if ((filters[k = removed[i]] & zero) === filterOne) {\n            g.value = reduceRemove(g.value, data[k]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // Add any selected records.\n        for (i = 0; i < n; ++i) {\n          if (!(filters[i] & zero)) {\n            g.value = reduceAdd(g.value, data[i]);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = heapselect_by(valueOf);\n        heap = heap_by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(crossfilter_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(crossfilter_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      m &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = n0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, added, removed) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (!filters[k = added[i]]) {\n          reduceValue = reduceAdd(reduceValue, data[k]);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters[k = removed[i]] === filterOne) {\n          reduceValue = reduceRemove(reduceValue, data[k]);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      for (i = 0; i < n; ++i) {\n        if (!filters[i]) {\n          reduceValue = reduceAdd(reduceValue, data[i]);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction crossfilter_index(n, m) {\n  return (m < 0x101\n      ? crossfilter_array8 : m < 0x10001\n      ? crossfilter_array16\n      : crossfilter_array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction crossfilter_range(n) {\n  var range = crossfilter_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction crossfilter_capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n})(typeof exports !== 'undefined' && exports || this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/dc/node_modules/crossfilter2/crossfilter.js\n// module id = 273\n// module chunks = 0 1","import React, { PureComponent } from \"react\";\r\nimport { findDOMNode } from \"react-dom\";\r\nimport { Col, Button } from \"reactstrap\";\r\nimport PropTypes from \"prop-types\";\r\nimport dc from \"dc\";\r\n\r\nexport default class Chart extends PureComponent {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.reset = this.reset.bind(this);\r\n  }\r\n  static contextTypes = {\r\n    ndx: PropTypes.object.isRequired\r\n  };\r\n\r\n  static defaultProps = {\r\n    type: \"row\",\r\n    nullValue: \"\",\r\n    legend: true\r\n  };\r\n\r\n  static propTypes = {\r\n    type: PropTypes.string,\r\n    nullValue: PropTypes.string,\r\n    legend: PropTypes.bool,\r\n    field: PropTypes.string.isRequired,\r\n    chartOptions: PropTypes.object,\r\n    wrapperProps: PropTypes.object\r\n  };\r\n\r\n  componentDidMount() {\r\n    var dim = this.context.ndx.dimension(d => {\r\n      let output = d[this.props.field];\r\n\r\n      if (output === null || output.length === 0) {\r\n        return this.props.nullValue;\r\n      } else return output;\r\n    });\r\n    var group = dim.group();\r\n\r\n    var chart = dc[`${this.props.type}Chart`](findDOMNode(this.refs.el))\r\n      .dimension(dim)\r\n      .group(group);\r\n\r\n    if (this.props.chartOptions) {\r\n      chart.options(this.props.chartOptions);\r\n    }\r\n\r\n    chart.render();\r\n    this.chart = chart;\r\n  }\r\n\r\n  reset() {\r\n    this.chart.filterAll().redrawGroup();\r\n  }\r\n\r\n  render() {\r\n    const { field, legend, wrapperProps } = this.props;\r\n    return (\r\n      <Col {...wrapperProps}>\r\n        <div ref=\"el\">\r\n          {legend && (\r\n            <legend>\r\n              {field}{\" \"}\r\n              <Button\r\n                size=\"sm\"\r\n                onClick={this.reset}\r\n                className=\"reset\"\r\n                style={{ display: \"none\" }}\r\n              >\r\n                reset\r\n              </Button>\r\n            </legend>\r\n          )}\r\n        </div>\r\n      </Col>\r\n    );\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/Chart.jsx"],"sourceRoot":""}